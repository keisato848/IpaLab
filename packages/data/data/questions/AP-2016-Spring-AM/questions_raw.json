[
  {
    "qNo": 1,
    "text": "nビットの値L1, L2がある。次の操作によって得られる値 L₃は、L₁ と L₂に対するどの論理演算の結果と同じか。\n[操作]\n(1) L₁とL₂のビットごとの論理和をとって、変数Xに記憶する。\n(2) L₁とL₂のビットごとの論理積をとって更に否定をとり、変数Yに記憶する。\n(3) XとYのビットごとの論理積をとって、結果をL₃とする。",
    "options": [
      {
        "id": "a",
        "text": "排他的論理和"
      },
      {
        "id": "b",
        "text": "排他的論理和の否定"
      },
      {
        "id": "c",
        "text": "論理積の否定"
      },
      {
        "id": "d",
        "text": "論理和の否定"
      }
    ],
    "correctOption": "a",
    "explanation": "正解は「イ」です。\n可用性（Availability）とは、システムがいつでも利用可能であることを意味します。ハードウェアの二重化（冗長化）は、障害発生時でもサービスを継続させるための対策です。"
  },
  {
    "qNo": 2,
    "text": "10進数 123を,英字 A~Zを用いた 26 進数で表したものはどれか。ここで、A = 0, B = 1,･･･, Z = 25 とする。",
    "options": [
      {
        "id": "a",
        "text": "BCD"
      },
      {
        "id": "b",
        "text": "DCB"
      },
      {
        "id": "c",
        "text": "ET"
      },
      {
        "id": "d",
        "text": "TE"
      }
    ],
    "correctOption": "c",
    "explanation": "この問題は、10進数（私たちが普段使う数字）を26進数（基数が26）に変換する問題です。\n\n### 変換手順\n10進数を他のN進数に変換する場合、元の数をNで割り続け、出た**余り**を下から順に並べます。\n\n1.  **123を26で割る**：\n    $123 \\div 26 = 4$ あまり $19$\n2.  **商（4）を再度26で割る**：\n    $4 \\div 26 = 0$ あまり $4$\n\n余りを下から（左から）並べると $(4, 19)$ となります。\n\n### 英字への対応\n問題の定義（A=0, B=1, ..., Z=25）に従って、この数字を英字に変換します。\n*   $4$ は $\\mathbf{E}$ (A=0, B=1, C=2, D=3, E=4)\n*   $19$ は $\\mathbf{T}$ (Tは20番目の文字であり、0から数えると19)\n\nしたがって、123は **ET** と表され、選択肢 **c** が正解です。\n\n### 誤りの選択肢について\n「d: TE」は、余りの (19, 4) を逆に並べた結果であり、N進数変換のルールに反しています。他の選択肢は、基数変換の計算自体が誤っています。"
  },
  {
    "qNo": 3,
    "text": "多数のクライアントが、LAN に接続された1台のプリンタを共同利用するときの印刷要求から印刷完了までの所要時間を、待ち行列理論を適用して見積もる場合に\nついて考える。プリンタの運用方法や利用状況に関する記述のうち, M/M/1 の待ち行列モデルの条件に反しないものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "一部のクライアントは、プリンタの空き具合を見ながら印刷要求をする。"
      },
      {
        "id": "b",
        "text": "印刷の緊急性や印刷量の多少にかかわらず、先着順に印刷する。"
      },
      {
        "id": "c",
        "text": "印刷待ち文書の総量がプリンタのバッファサイズを超えるときは、一時的に受付を中断する。"
      },
      {
        "id": "d",
        "text": "一つの印刷要求から印刷完了までの所要時間は,印刷の準備に要する一定時間と、印刷量に比例する時間の合計である。"
      }
    ],
    "correctOption": "b",
    "explanation": "待ち行列理論のM/M/1モデルは、到着間隔とサービス時間（ここでは印刷にかかる時間）が**指数分布**に従い、サービス窓口が1つ（プリンタ1台）で、待ち行列の規律が**FCFS（先着順）**であるという基本条件を持ちます。\n\n- **正解のb:** 「先着順に印刷する」という記述は、M/M/1モデルが前提とするFCFS（First-Come, First-Served：先に並んだものから処理する）の待ち行列の規律に完全に合致しています。\n- **a、c、dが誤りな理由:**\n    - a: クライアントがプリンタの空き具合を見て要求を出す（待ち行列の長さによって到着率が変わる）のは、モデルが前提とするポアソン到着（ランダムな到着）に反します。\n    - c: 受付を中断する（待ち行列のサイズが有限である）のは、M/M/1モデルが前提とする無限の待ちスペースに反します。\n    - d: 印刷所要時間が「一定時間＋比例する時間」である場合、サービス時間（処理時間）は指数分布ではなくなり、モデルの条件に反します。"
  },
  {
    "qNo": 4,
    "text": "a, b, c, dの4文字から成るメッセージを符号化してビット列にする方法として表のア~エの4通りを考えた。この表はa, b, c, d の各1文字を符号化するときのビット列を表している。メッセージ中での a, b, c, dの出現頻度は,それぞれ 50%, 30%, 10%, 10%であることが分かっている。符号化されたビット列から元のメッセージが一意に復号可能であって、ビット列の長さが最も短くなるものはどれか。\n\n| | a | b | c | d |\n|---|---|---|---|---|\n| ア | 0 | 1 | 00 | 11 |\n| イ | 0 | 01 | 10 | 11 |\n| ウ | 0 | 10 | 110 | 111 |\n| エ | 00 | 01 | 10 | 11 |",
    "options": [
      {
        "id": "a",
        "text": "ア"
      },
      {
        "id": "b",
        "text": "イ"
      },
      {
        "id": "c",
        "text": "ウ"
      },
      {
        "id": "d",
        "text": "エ"
      }
    ],
    "correctOption": "c",
    "explanation": "この問題は、符号化されたメッセージが**一意に復号できる**こと（プレフィックス条件）と、**平均の長さが最も短い**こと（符号化効率）の2点を満たす符号を選ぶ問題です。\n\n1.  **一意復号可能性（プレフィックス条件）の確認**\n    ある文字の符号が、他の文字の符号の先頭（プレフィックス）になっていてはいけません。\n    *   ア（a=0, c=00）とイ（a=0, b=01）は、符号「0」が他の符号のプレフィックスになっているため、復号時に誤りが生じる可能性があり、不適です。\n    *   ウとエは、プレフィックス条件を満たしています。\n\n2.  **平均符号長の計算と効率の比較**\n    残ったウとエについて、出現頻度（a:50%, b:30%, c:10%, d:10%）に基づき、平均符号長（ビット列の期待値）を計算します。\n    *   エ（固定長2ビット）：(0.5+0.3+0.1+0.1) × 2 = **2.0 ビット**\n    *   **ウ（可変長）**：頻度の高い文字に短い符号を割り当てる方式です。\n        (0.5×1) + (0.3×2) + (0.1×3) + (0.1×3) = 0.5 + 0.6 + 0.3 + 0.3 = **1.7 ビット**\n\nウが最も平均符号長が短く、かつ一意に復号可能であるため、正解となります。"
  },
  {
    "qNo": 5,
    "text": "A, B, C の順序で入力されるデータがある。各データについてスタックへの挿入と取出しを1回ずつ行うことができる場合、データの出力順序は何通りあるか。",
    "options": [
      {
        "id": "a",
        "text": "3"
      },
      {
        "id": "b",
        "text": "4"
      },
      {
        "id": "c",
        "text": "5"
      },
      {
        "id": "d",
        "text": "6"
      }
    ],
    "correctOption": "c",
    "explanation": "この問題は、スタック（LIFO：最後に入れたものが最初に出る構造）を使って3つのデータ（A, B, C）を操作したときの可能な出力順序の数を求めるものです。\n\n**考え方（なぜ5通りか）**\nデータが入力される順序は「A→B→C」です。出力順序は、各データについて「スタックに入れる（Push）」→「スタックから出す（Pop）」の操作の組み合わせによって決まります。\n\n可能な出力順序は以下の5通りです。\n\n1. **C, B, A**：A→B→C の順に全てPushした後、C→B→A の順にPop。\n2. **B, C, A**：A(Push)→B(Push)→B(Pop)→C(Push)→C(Pop)→A(Pop)。\n3. **A, C, B**：A(Push)→A(Pop)→B(Push)→C(Push)→C(Pop)→B(Pop)。\n4. **B, A, C**：A(Push)→B(Push)→B(Pop)→A(Pop)→C(Push)→C(Pop)。\n5. **A, B, C**：A(Push)→A(Pop)→B(Push)→B(Pop)→C(Push)→C(Pop)。\n\n**なぜ他の選択肢は誤りか**\n例えば、「C, A, B」という順序は不可能です。Cを最初に出すためにはAとBが既にスタックに入っている必要がありますが、その場合、AよりBが上にあるため、Cの次に必ずBが出力され、Aは最後になります（C, B, A）。したがって、出力順序は全部で5通りとなり、正解は **c** です。"
  },
  {
    "qNo": 6,
    "text": "流れ図に示す処理の動作の記述として、適切なものはどれか。ここで、二重線は並列処理の同期を表す。\n\n```mermaid\ngraph TD\n    Start([開始])\n    Start --> A\n    A --> Split( ) :::split\n    Split --> B\n    Split --> C\n    B --> Join( ) :::join\n    C --> Join\n    Join --> A\n    classDef split stroke-dasharray: 5 5\n    classDef join stroke-dasharray: 5 5\n```",
    "options": [
      {
        "id": "a",
        "text": "ABC 又は ACB を実行してデッドロックになる。"
      },
      {
        "id": "b",
        "text": "AB 又は AC を実行してデッドロックになる。"
      },
      {
        "id": "c",
        "text": "Aの後にBC 又は CB, BC 又は CB, ･･･と繰り返して実行する。"
      },
      {
        "id": "d",
        "text": "Aの後にBの無限ループ又はCの無限ループになる。"
      }
    ],
    "correctOption": "c",
    "explanation": "この流れ図は、タスクの並列処理（同時に実行すること）と同期を示しています。\n\n- まず、タスク **A** が実行されます。\n- その後、処理が分岐（`Split`）し、タスク **B** とタスク **C** は**並列**に実行されます。つまり、BとCはどちらが先になるかわかりません（BCまたはCB）。\n- 並列処理を示す二重線は「同期」（`Join`）を表しており、BとCの**両方**が完了するまで次のステップに進めません。\n- BとCが両方完了すると、処理は再びAに戻り、このサイクル（A→BとCの並列実行）を**繰り返します**。\n\nしたがって、この処理は **Aの後にBCまたはCBの順で実行され、これを繰り返す** (c) が正解です。\n\n他の選択肢は誤りです。デッドロック（処理が止まること）は発生しません (a, b)。また、ループはA→(B, C)の全体で構成されており、BやC単独の無限ループにはなりません (d)。"
  },
  {
    "qNo": 7,
    "text": "リアルタイムシステムにおいて、複数のタスクから同時に呼び出された場合に,並行して実行する必要がある共用ライブラリのプログラムに要求される性質はどれか。",
    "options": [
      {
        "id": "a",
        "text": "リエントラント"
      },
      {
        "id": "b",
        "text": "リカーシブ"
      },
      {
        "id": "c",
        "text": "リユーザブル"
      },
      {
        "id": "d",
        "text": "リロケータブル"
      }
    ],
    "correctOption": "a",
    "explanation": "複数のタスクが同時に呼び出す共用プログラムに必要な性質は**リエントラント**（再入可能）です。\n\n*   **リエントラント（a: 正解）**：複数のタスクが同時に実行しても、データの破壊や誤動作を起こさない性質です。これは、タスク間で共有されるデータ（グローバル変数など）を使用せず、タスク固有のスタック領域など、呼び出し元が用意する領域に処理に必要なデータを格納することで実現されます。\n*   **リカーシブ（b）**：関数が自分自身を呼び出す「再帰」ができる性質です。タスクの同時実行とは関係ありません。\n*   **リユーザブル（c）**：一度実行した後、メモリに再ロードせずに再度実行できる性質（再使用可能）です。これも同時実行の安全性とは異なります。\n*   **リロケータブル（d）**：メモリ上の任意のアドレスに配置し直して実行できる性質（再配置可能）です。\n\nしたがって、並行処理の安全性を保証する**リエントラント**が正解です。"
  },
  {
    "qNo": 8,
    "text": "CPUのスタックポインタが示すものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "サブルーチン呼出し時に、戻り先アドレス及びレジスタの内容を格納するメモリのアドレス"
      },
      {
        "id": "b",
        "text": "次に読み出す機械語命令が格納されているアドレス"
      },
      {
        "id": "c",
        "text": "メモリから読み出された機械語命令"
      },
      {
        "id": "d",
        "text": "割込みの許可状態,及び条件分岐の判断に必要な演算結果の状態"
      }
    ],
    "correctOption": "a",
    "explanation": "スタックポインタ（SP）は、メモリ上に確保された「スタック領域」の**現在の先端（トップ）のアドレス**を指し示すレジスタです。\n\n正解の**a**は、スタックが最も頻繁に使用される目的を説明しています。サブルーチン（小さなプログラムのまとまり）を呼び出す際、プログラムが処理を終えて元の場所に戻るために必要な「戻り先アドレス」や、処理の途中で使っていた重要なデータ（レジスタの内容）を一時的に記憶（格納）するためにスタックが使われます。スタックポインタは、次にデータを書き込むべき場所、すなわち格納するメモリのアドレスを指しています。\n\n*   **b**はプログラムカウンタ（PC）の説明です。\n*   **c**は命令レジスタ（IR）が保持する情報です。\n*   **d**はプログラム状態語（PSW）などが保持する情報の一部です。"
  },
  {
    "qNo": 9,
    "text": "並列処理方式である SIMD の説明として、適切なものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "単一命令ストリームで単一データストリームを処理する方式"
      },
      {
        "id": "b",
        "text": "単一命令ストリームで複数のデータストリームを処理する方式"
      },
      {
        "id": "c",
        "text": "複数の命令ストリームで単一データストリームを処理する方式"
      },
      {
        "id": "d",
        "text": "複数の命令ストリームで複数のデータストリームを処理する方式"
      }
    ],
    "correctOption": "b",
    "explanation": "SIMD（Single Instruction Multiple Data：単一命令・多データ）は、**並列処理**方式の一つです。\n\nSIMDの特徴は、**一つの命令**（Single Instruction）で、**複数の異なるデータ**（Multiple Data）に対して同時に同じ演算を実行することです。例えば、「全てのデータに5を足す」という処理を一度の命令で並列に行います。\n\nしたがって、正解は **b** の「単一命令ストリームで複数のデータストリームを処理する方式」です。\n\n*   **a** は SISD（単一命令・単一データ）の説明で、一般的な逐次処理のコンピュータ構造です。\n*   **c** と **d** は、複数の異なる命令を扱う方式（MISDやMIMD）の説明であり、SIMDとは異なります。SIMDは特に画像処理や科学技術計算など、大量のデータに同じ処理を適用する場面で効率的です。"
  },
  {
    "qNo": 10,
    "text": "USB 3.0 の特徴はどれか。",
    "options": [
      {
        "id": "a",
        "text": "PCなどの小型コンピュータと、磁気ディスク,レーザプリンタなどの周辺機器とを接続するパラレルインタフェースである。"
      },
      {
        "id": "b",
        "text": "音声,映像など、リアルタイム性が必要なデータの転送に適した高速な転送方式を採用したシリアルインタフェースであり, FireWireとも呼ばれている。"
      },
      {
        "id": "c",
        "text": "モデム接続の規格であったが、PCと周辺機器とを接続するようになったシリアルインタフェースである。"
      },
      {
        "id": "d",
        "text": "四つの転送スピードをもつシリアルインタフェースであり,スーパースピードモードは、PCと外付け磁気ディスクとの接続などに使用される。"
      }
    ],
    "correctOption": "d",
    "explanation": "USB (Universal Serial Bus)は、パソコンと周辺機器を接続するための代表的な**シリアルインタフェース**（データを一本の線で順番に送る方式）規格です。\n\n*   **正解 d:** USB 3.0 (現在はUSB 3.2 Gen 1) は、従来の規格と互換性を持ちながら、データ転送速度を大幅に向上させたバージョンです。特に最高速度の**スーパースピードモード (SuperSpeed)** は5Gbpsで、外付けハードディスクなどの大容量データを高速に扱う接続に適しています。選択肢にある通り、USBは複数の転送スピード（モード）を持っています。\n\n*   **a, c:** これらはUSBの特徴ではありません。特にaの「パラレルインタフェース」やcの「モデム接続の規格」は、過去の古い接続規格（SCSIやRS-232Cなど）を指しています。\n*   **b:** FireWire（IEEE 1394）は、USBとは別の規格であり、リアルタイム性が特徴ですが、USB 3.0を指すものではありません。"
  },
  {
    "qNo": 11,
    "text": "液晶ディスプレイ(LCD)の特徴として、適切なものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "電圧を加えると発光する有機化合物を用いる。"
      },
      {
        "id": "b",
        "text": "電子銃から発射された電子ビームが蛍光体に当たって発光する。"
      },
      {
        "id": "c",
        "text": "光の透過を画素ごとに制御し、カラーフィルタを用いて色を表現する。"
      },
      {
        "id": "d",
        "text": "放電によって発生する紫外線と蛍光体を利用する。"
      }
    ],
    "correctOption": "c",
    "explanation": "液晶ディスプレイ（LCD）は、電圧によって液晶分子の向きを変え、**光の透過**を制御する仕組みです。\n\n*   **正解 c の説明:** LCDはバックライト（光源）からの光を、液晶を通過させることで明るさを調整します。画素（ピクセル）ごとに光の透過量を制御し、その先に配置された**カラーフィルタ**（赤・緑・青のフィルター）を通して色を表現します。\n\n*   **他の選択肢の説明:**\n    *   a は**有機ELディスプレイ**（OLED）の特徴です（有機化合物自体が発光する）。\n    *   b は**ブラウン管ディスプレイ**（CRT）の特徴です（電子ビームで蛍光体を光らせる）。\n    *   d は**プラズマディスプレイ**（PDP）の特徴です（放電で発生した紫外線が蛍光体を光らせる）。\n\nしたがって、光の透過を制御しカラーフィルタを用いる c が、LCDの動作原理として適切です。"
  },
  {
    "qNo": 12,
    "text": "クライアントサーバシステムの3層アーキテクチャを説明したものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "アプリケーションに必要な GUI と API をプレゼンテーション層とファンクション層に分離したアーキテクチャであり、データベースサーバを独立させている。"
      },
      {
        "id": "b",
        "text": "プレゼンテーション層,ファンクション層,データ層に分離したアーキテクチャであり、各層のOSは異なってもよい。"
      },
      {
        "id": "c",
        "text": "プレゼンテーション層とデータ層をミドルウェア層によって連係したアーキテクチャであり、各層をネットワークで接続されたコンピュータに分散する。"
      },
      {
        "id": "d",
        "text": "プレゼンテーション層とファンクション層を結合し、データ層を分離したアーキテクチャであり、データベースサーバを効率的に運用できる。"
      }
    ],
    "correctOption": "b",
    "explanation": "クライアントサーバシステムの**3層アーキテクチャ**とは、システムを機能や役割に応じて三つの独立した部分（層）に分ける設計モデルです。\n\n正解の**b**が示す通り、3層は以下の役割で構成されます。\n\n1. **プレゼンテーション層（利用者とのやり取り）**: ユーザインターフェース（GUI）を担当します。\n2. **ファンクション層（機能・処理）**: 業務ロジック（プログラムの実行部分）を担当します。\n3. **データ層（データの管理）**: データベース（DB）を担当します。\n\nこのように層を分けることで、各層の変更が他の層に影響を与えにくくなり、柔軟性が高まります。各層が独立して機能するため、それぞれ異なるOSやシステム（サーバ）上で動作させることが可能です。\n\n他の選択肢は、層の名称や役割の分離の仕方が誤っています。特に**d**はプレゼンテーション層とファンクション層を結合しており、これは3層ではなく**2層（二層）アーキテクチャ**の説明に近いです。"
  },
  {
    "qNo": 13,
    "text": "現状の HPC (High Performance Computing) マシンの構成を、次の条件で更新することにした。更新後の、ノード数と総理論ピーク演算性能はどれか。ここで、総理論ピーク演算性能は,コア数に比例するものとする。\n\n[現状の構成]\n(1) 一つのコアの理論ピーク演算性能は10GFLOPS である。\n(2) 一つのノードのコア数は8である。\n(3) ノード数は1,000である。\n\n[更新条件]\n(1) 一つのコアの理論ピーク演算性能を現状の2倍にする。\n(2) 一つのノードのコア数を現状の2倍にする。\n(3) 総コア数を現状の4倍にする。\n\n| | ノード数 | 総理論ピーク演算性能 (TFLOPS) |\n|---|---|---|\n| ア | 2,000 | 320 |\n| イ | 2,000 | 640 |\n| ウ | 4,000 | 320 |\n| エ | 4,000 | 640 |",
    "options": [
      {
        "id": "a",
        "text": "ア"
      },
      {
        "id": "b",
        "text": "イ"
      },
      {
        "id": "c",
        "text": "ウ"
      },
      {
        "id": "d",
        "text": "エ"
      }
    ],
    "correctOption": "b",
    "explanation": "この問題は、現状の構成から更新条件を適用し、新しいノード数と総理論ピーク演算性能を計算するものです。\n\n1. **現状の構成の把握:**\n現状の総コア数: 1,000ノード × 8コア/ノード = 8,000コア。\n現状の総性能: 8,000コア × 10 GFLOPS = 80,000 GFLOPS = 80 TFLOPS です。（1 TFLOPSは1,000 GFLOPSです。）\n\n2. **更新後のノード数の計算:**\n更新条件(3)により、総コア数は現状の4倍（8,000 × 4 = 32,000コア）になります。\n更新条件(2)により、1ノードのコア数は現状の2倍（8 × 2 = 16コア）になります。\nノード数 = 総コア数 ÷ 1ノードのコア数。\n更新後のノード数は 32,000コア ÷ 16コア/ノード = **2,000ノード** です。\n\n3. **更新後の総理論ピーク演算性能の計算:**\n総理論ピーク演算性能は、総コア数と1コアの性能に比例します。\n総コア数が4倍、1コアの性能（条件(1)）が2倍になるため、全体の性能は $4 \\times 2 = 8$ 倍になります。\n更新後の性能は、現状の 80 TFLOPS $\\times$ 8 = **640 TFLOPS** です。\n\nしたがって、ノード数2,000、総性能640 TFLOPSの**イ**が正解です。他の選択肢は、性能（320 TFLOPSは8倍ではなく4倍にしかなっていません）またはノード数の計算が誤っています。"
  },
  {
    "qNo": 14,
    "text": "仮想サーバの運用サービスで使用するライブマイグレーションの概念を説明したものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "仮想サーバで稼働している OS やソフトウェアを停止することなく、他の物理サーバへ移し替える技術である。"
      },
      {
        "id": "b",
        "text": "データの利用目的や頻度などに応じて、データを格納するのに適したストレージへ自動的に配置することによって、情報活用とストレージ活用を高める技術である。"
      },
      {
        "id": "c",
        "text": "複数の利用者でサーバやデータベースを共有しながら、利用者ごとにデータベースの内容を明確に分離する技術である。"
      },
      {
        "id": "d",
        "text": "利用者の要求に応じてリソースを動的に割り当てたり、不要になったリソースを回収して別の利用者のために移し替えたりする技術である。"
      }
    ],
    "correctOption": "a",
    "explanation": "仮想化技術における**ライブマイグレーション**とは、**稼働中の仮想サーバ**（OSやアプリケーションが動いている状態）を、**サービスを停止することなく**別の物理サーバに移動させる技術です。\n\n*   **正解 a:** ライブマイグレーションの定義そのものです。サービス無停止での移動（マイグレーション）が可能になることで、システムのメンテナンスや負荷分散が容易になります。\n*   **誤り b:** これはストレージ階層化（ティアリング）に関する説明です。\n*   **誤り c:** これはマルチテナント（複数の利用者が共通のシステムを分離して利用する方式）に関する説明です。\n*   **誤り d:** これはリソースの動的な割り当てや回収に関する説明で、クラウド環境などのリソース管理の仕組みの一部ですが、ライブマイグレーションの直接的な概念ではありません。"
  },
  {
    "qNo": 15,
    "text": "分散処理システムに関する記述のうち、アクセス透過性を説明したものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "遠隔地にある資源を、遠隔地での処理方式を知らなくても、手元にある資源と同じ操作で利用できる。"
      },
      {
        "id": "b",
        "text": "システムの運用と管理をそれぞれの組織で個別に行うことによって、その組織の実態に合ったサービスを提供することができる。"
      },
      {
        "id": "c",
        "text": "集中して処理せずに、データの発生場所やサービスの要求場所で処理することによって、通信コストを削減できる。"
      },
      {
        "id": "d",
        "text": "対等な関係のコンピュータが複数あるので、一部が故障しても他のコンピュータによる処理が可能となり、システム全体の信頼性を向上させることができる。"
      }
    ],
    "correctOption": "a",
    "explanation": "## 解説\n\nこの問題は、分散処理システムにおける「透過性（とうかせい）」、特に**アクセス透過性**について問われています。\n\n*   **アクセス透過性 (Access Transparency)** とは、ユーザーがどこにデータや資源（リソース）があるかを意識することなく、あたかも手元の資源のように同じ方法（操作）で利用できる性質を指します。\n\n*   選択肢 **a** は、「遠隔地にある資源を、遠隔地での処理方式を知らなくても、手元にある資源と同じ操作で利用できる」と述べており、まさにアクセス透過性の定義そのものです。したがって、これが正解です。\n\n*   選択肢 **b** は「管理透過性」や「制御の分散」に関する内容です。\n*   選択肢 **c** はデータの発生場所で処理する「エッジコンピューティング」や「分散処理の利点（通信コスト削減）」に関する内容です。\n*   選択肢 **d** は、一部が故障してもシステムが継続できる「耐故障性」や「可用性（アベイラビリティ）」に関する内容で、これは「故障透過性」の一部です。"
  },
  {
    "qNo": 16,
    "text": "フェールセーフの考え方として、適切なものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "システムに障害が発生したときでも、常に安全側にシステムを制御する。"
      },
      {
        "id": "b",
        "text": "システムの機能に異常が発生したときに、すぐにシステムを停止しないで機能を縮退させて運用を継続する。"
      },
      {
        "id": "c",
        "text": "システムを構成する要素のうち、信頼性に大きく影響するものを複数備えることによって、システムの信頼性を高める。"
      },
      {
        "id": "d",
        "text": "不特定多数の人が操作しても,誤動作が起こりにくいように設計する。"
      }
    ],
    "correctOption": "a",
    "explanation": "フェールセーフ（Fail Safe）とは、システムに**何らかの障害が発生した場合でも、必ず安全な状態に移行（制御）させる**という設計思想です。\n\n*   **正解 a:** 「システムに障害が発生したときでも、常に安全側にシステムを制御する」がフェールセーフの定義そのものです。例えば、暖房装置が故障した場合に加熱を止めて低温側に移行したり、踏切の遮断機が故障した際に必ず下りる（遮断する）ように制御することなどが該当します。\n*   **b:** 異常時に機能を縮小して運用を継続するのは、主に**フェールソフト（Fail Soft）**や**フォールバック（Fallback）**の考え方です。\n*   **c:** 重要な要素を複数備えて信頼性を高めるのは、**冗長化**や**フォールトトレラント（Fault Tolerant）**の考え方です。\n*   **d:** 誤動作が起こりにくいように設計するのは、主に**フールプルーフ（Fool Proof）**の考え方です。"
  },
  {
    "qNo": 17,
    "text": "ページング方式の仮想記憶において,あるプログラムを実行したとき、1回のページフォールトの平均処理時間は30ミリ秒であった。ページフォールト発生時の処理時間が次の条件であったとすると、ページアウトを伴わないページインだけの処理の割合は幾らか。\n\n[ページフォールト発生時の処理時間]\n(1) ページアウトを伴わない場合,ページインの処理時間は20ミリ秒である。\n(2) ページアウトを伴う場合、置換えページの選択、ページアウト, ページインの合計処理時間は60ミリ秒である。",
    "options": [
      {
        "id": "a",
        "text": "0.25"
      },
      {
        "id": "b",
        "text": "0.33"
      },
      {
        "id": "c",
        "text": "0.67"
      },
      {
        "id": "d",
        "text": "0.75"
      }
    ],
    "correctOption": "d",
    "explanation": "これは、ページフォールト（必要なデータが主記憶にない状態）発生時の処理時間の**加重平均**を求める問題です。\n\n求めたい「ページアウトを伴わない（ページインだけの）処理の割合」を $P$ とします。すると、ページアウトを伴う処理の割合は $(1 - P)$ となります。\n\n平均処理時間（30ミリ秒）は、それぞれの処理時間と割合をかけたものの合計として表されます。\n\n$$30 = (P \\times 20) + ((1 - P) \\times 60)$$\n\nこの方程式を解きます。\n\n1.  $$30 = 20P + 60 - 60P$$\n2.  $$30 = 60 - 40P$$\n3.  $$40P = 30$$\n4.  $$P = 30 / 40 = 0.75$$\n\nしたがって、ページアウトを伴わない処理の割合は **0.75** です。これは、主記憶（メインメモリ）に空き領域があり、古いページを補助記憶に書き戻す（ページアウト）必要がないケースが75%であることを示します。他の選択肢は計算結果と一致しません。"
  },
  {
    "qNo": 18,
    "text": "仮想記憶方式に関する記述のうち、適切なものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "LRU アルゴリズムは、使用後の経過時間が最長のページを置換対象とするページ置換アルゴリズムである。"
      },
      {
        "id": "b",
        "text": "アドレス変換をインデックス方式で行う場合は、主記憶に存在する全ページ分のページテーブルが必要になる。"
      },
      {
        "id": "c",
        "text": "ページフォールトが発生した場合は、ガーベジコレクションが必要である。"
      },
      {
        "id": "d",
        "text": "ページングが繰り返されるうちに多数の小さな空きメモリ領域が発生することを、フラグメンテーションという。"
      }
    ],
    "correctOption": "a",
    "explanation": "仮想記憶は、主記憶（メインメモリ）よりも大きな記憶領域を扱えるようにする技術です。\n\n**正解は a です。**\n\n*   **a: LRU (Least Recently Used) アルゴリズムは、過去に最も長く使われていないページ（使用後の経過時間が最長のページ）を置換対象とする**ページ置換アルゴリズムです。これは、そのページが今後も使われる可能性が低いと予測するため、最も効率的な置換方法の一つとされています。\n\n*   **b が誤りな理由:** アドレス変換を行うためのページテーブルは、**現在主記憶に存在するページ分のみ**必要です。主記憶にないページ（補助記憶装置にあるページ）の情報はページテーブルには含まれません。\n\n*   **c が誤りな理由:** **ページフォールト**は、CPUがアクセスしたいページが主記憶にない場合に発生します。このとき必要なのは、補助記憶から該当ページを主記憶に読み込む処理（ページイン）であり、**ガーベジコレクション**（不要になったメモリ領域を自動で解放する処理）ではありません。\n\n*   **d が誤りな理由:** ページング（仮想記憶）では、固定長のページ単位でメモリが管理されるため、**小さな空き領域が多数発生する現象（フラグメンテーション）は基本的に起こりにくい**です。この現象は、可変長領域の管理（セグメンテーションなど）で発生しやすい特徴があります。"
  },
  {
    "qNo": 19,
    "text": "ノンプリエンプティブだけのスケジューリング方式はどれか。",
    "options": [
      {
        "id": "a",
        "text": "残余処理時間順"
      },
      {
        "id": "b",
        "text": "到着順"
      },
      {
        "id": "c",
        "text": "優先度順"
      },
      {
        "id": "d",
        "text": "ラウンドロビン"
      }
    ],
    "correctOption": "b",
    "explanation": "ノンプリエンプティブとは、**一度実行を開始したタスク（プロセス）は、完了するまで中断されない**スケジューリング方式です。\n\n*   **正解はbの到着順（First-Come, First-Served: FCFS）です。**\n    *   FCFSは、タスクが到着した順番に実行を開始し、そのタスクが**終了するまでCPUを占有し続けます**。途中でより緊急性の高いタスクが到着しても、実行中のタスクが中断されることはありません。これがノンプリエンプティブの典型的な例です。\n\n*   **その他の選択肢はプリエンプティブ（または両方可能）な方式です。**\n    *   a（残余処理時間順）やc（優先度順）は、新しいタスクが到着した際、残りの処理時間が短い場合や優先度が高い場合に、**実行中のタスクを中断して切り替える**ことができます（プリエンプティブ）。\n    *   d（ラウンドロビン）は、設定された時間（タイムスライス）が経過するたびに、**必ずタスクを中断して別のタスクに切り替える**プリエンプティブ方式です。"
  },
  {
    "qNo": 20,
    "text": "メインプログラムを実行した後、メインプログラムの変数 X, Y の値は幾つになるか。ここで、仮引数Xは値呼出し (call by value), 仮引数Yは参照呼出し(call by reference)であるとする。\n\nメインプログラム:\nX=2;\nY=2;\nadd(X, Y);\n\n手続 add(X, Y):\nX=X+Y;\nY=X+Y;\nreturn;\n\n| | X | Y |\n|---|---|---|\n| ア | 2 | 4 |\n| イ | 2 | 6 |\n| ウ | 4 | 2 |\n| エ | 4 | 6 |",
    "options": [
      {
        "id": "a",
        "text": "ア"
      },
      {
        "id": "b",
        "text": "イ"
      },
      {
        "id": "c",
        "text": "ウ"
      },
      {
        "id": "d",
        "text": "エ"
      }
    ],
    "correctOption": "b",
    "explanation": "この問題は、プログラムの引数渡し（呼び出し方）の仕組みを理解しているかが問われています。\n\n**【正解の選択肢：イ (X=2, Y=6) が正しい理由】**\n\nポイントは引数Xが「値呼出し」、引数Yが「参照呼出し」である点です。\n\n1. **初期値**：メインプログラムで `X=2`, `Y=2` が設定されます。\n2. **add実行時**：\n    * **仮引数X（値呼出し/Call by Value）**：メインのXの「値のコピー」が渡されます。手続きadd内でXを変更しても、**メインのXには影響しません**。\n    * **仮引数Y（参照呼出し/Call by Reference）**：メインのYの「場所（メモリ上のアドレス）」が渡されます。手続きadd内でYを変更すると、**メインのYも変更されます**。\n3. **手続きaddの処理**：\n    * `X = X + Y;` → `X = 2 + 2 = 4`（add内のXが4になる。メインのXは2のまま）\n    * `Y = X + Y;` → `Y = 4 + 2 = 6`（add内のYが6になる。これは**メインのYも6に変更**する）\n4. **結果**：手続き終了後、メインプログラムのXは元の値のまま **2**、Yは参照によって変更された **6** となります。\n\n**【他の選択肢が誤りである理由】**\n\n* ア、ウ、エは、Xが値呼出しであるという条件（メインのXが変わらない）を満たしていません。特にエは、両方が参照呼出しだった場合の挙動に近いです。"
  },
  {
    "qNo": 21,
    "text": "DRAMの説明として、適切なものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "1 バイト単位でデータの消去及び書込みが可能な不揮発性のメモリであり,電源遮断時もデータ保持が必要な用途に用いられる。"
      },
      {
        "id": "b",
        "text": "不揮発性のメモリで NAND型又は NOR型があり, SSDに用いられる。"
      },
      {
        "id": "c",
        "text": "メモリセルはフリップフロップで構成され、キャッシュメモリに用いられる。"
      },
      {
        "id": "d",
        "text": "リフレッシュ動作が必要なメモリであり、PCの主記憶として用いられる。"
      }
    ],
    "correctOption": "d",
    "explanation": "**DRAM（Dynamic Random Access Memory）**は、一般的にPCやスマートフォンなどの**主記憶（メインメモリ）**として使われるメモリです。\n\n*   **正解（d）の理由:**\n    DRAMはデータを保持するために**リフレッシュ（再書き込み）動作**が周期的に必要です。この動的な（Dynamic）性質が名前の由来です。リフレッシュが必要な代わりに、構造がシンプルで大容量化・低コスト化に適しており、主記憶（メインメモリ）として広く利用されています。\n\n*   **他の選択肢が誤りである理由:**\n    *   (a) 1バイト単位で消去・書き込み可能で不揮発性なのはEEPROMなどであり、DRAMは揮発性です。\n    *   (b) NAND型やNOR型がありSSDなどに用いられるのは**フラッシュメモリ**です。\n    *   (c) フリップフロップ（複雑な回路）で構成され、リフレッシュが不要な高速なメモリは**SRAM**（Static RAM）と呼ばれ、主にキャッシュメモリに用いられます。"
  },
  {
    "qNo": 22,
    "text": "LSI の省電力制御技術であるパワーゲーティングの説明として、適切なものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "異なる電圧値の電源を複数もち,動作周波数が低い回路ブロックには低い電源電圧を供給することによって、消費電力を減らす。"
      },
      {
        "id": "b",
        "text": "動作する必要がない回路ブロックに供給しているクロックを停止することによって,消費電力を減らす。"
      },
      {
        "id": "c",
        "text": "動作する必要がない回路ブロックへの電源供給を遮断することによって、消費電力を減らす。"
      },
      {
        "id": "d",
        "text": "半導体製造プロセスの微細化から生じるリーク電流の増大を,使用材料などの革新によって抑える。"
      }
    ],
    "correctOption": "c",
    "explanation": "LSI（大規模集積回路）の省電力技術である**パワーゲーティング**は、**不要な回路ブロックへの電源供給を完全に遮断**し、電力消費を抑える手法です。\n\n正解の**c**は、このパワーゲーティングの定義そのものです。回路が動作していない待機状態（アイドル状態）のとき、電気の供給を止めれば、その回路での電力消費をゼロに近づけることができます。\n\n他の選択肢は、別の省電力技術を指しています。\n- **a**は「動的電圧・周波数スケーリング（DVFS）」の説明です。\n- **b**は「クロックゲーティング」の説明です。これは電源ではなく、動作のきっかけとなるクロック信号を止める手法です。\n- **d**は、材料技術などによるリーク電流（微小な漏れ電流）対策の説明であり、パワーゲーティングとは異なります。"
  },
  {
    "qNo": 23,
    "text": "アクチュエータの説明として、適切なものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "アナログ電気信号を,コンピュータが処理可能なディジタル信号に変える。"
      },
      {
        "id": "b",
        "text": "キーボード、タッチパネルなど、コンピュータに情報を入力するデバイスである。"
      },
      {
        "id": "c",
        "text": "コンピュータが出力した電気信号を力学的な運動に変える。"
      },
      {
        "id": "d",
        "text": "物理量を検出して、電気信号に変える。"
      }
    ],
    "correctOption": "c",
    "explanation": "アクチュエータ（Actuator）は、**「作動させるもの」**という意味で、電気信号などのエネルギーを物理的な動き（力や運動）に変える装置です。\n\n*   **正解 c:** コンピュータ（制御装置）が出した電気信号を受け取り、それをモーターの回転やバルブの開閉などの**力学的な運動**に変換して、機械を実際に動かします。ロボットのアームや工場の自動化システムなどで重要な役割を果たします。\n\n*   **a, d (センサの役割):** 物理量（温度、圧力など）を検出して電気信号に変えるのはセンサ（Senser）の役割です。\n*   **b (入力デバイス):** キーボードやタッチパネルは、人がコンピュータに情報を与えるための入力デバイスです。\n\nしたがって、コンピュータの指示を実際の「動き」に変える**c**がアクチュエータの適切な説明です。"
  },
  {
    "qNo": 24,
    "text": "SoCの説明として、適切なものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "CPU, チップセット,ビデオチップ,メモリなどコンピュータを構成するデバイスを実装した電子回路基板"
      },
      {
        "id": "b",
        "text": "CPU, メモリ、周辺装置などの間で発生するデータの受渡しを管理する一連の回路群を搭載した半導体チップ"
      },
      {
        "id": "c",
        "text": "各機能を個別に最適化されたプロセスで製造し、パッケージ内でそれぞれのチップを適切に配線した半導体チップ"
      },
      {
        "id": "d",
        "text": "必要とされる全ての機能(システム)を集積した1個の半導体チップ"
      }
    ],
    "correctOption": "d",
    "explanation": "SoC（System on a Chip）は、**システムが必要とする主要な機能すべてを、たった一つの半導体チップ（IC）の上に集積したもの**を指します。\n\n- **正解 d**：SoCはその名の通り「システムをチップの上に」実装する技術であり、CPU、メモリ、入出力制御など、動作に必要な全ての機能を一つのチップに組み込んでいます。これにより、機器の小型化、消費電力の削減、コストダウンが可能になります。スマートフォンや組み込み機器（IoTデバイスなど）で広く使われています。\n\n- **a** はマザーボード（またはメインボード）の説明です。\n- **b** は主にチップセットの説明に近いです。\n- **c** は、複数のチップを一つのパッケージにまとめるSiP (System in Package) などの技術の説明に近いです。"
  },
  {
    "qNo": 25,
    "text": "使用性(ユーザビリティ)の規格(JIS Z 8521:1999)では、使用性を、“ある製品が、指定された利用者によって、指定された利用の状況下で、指定された目的を達成するために用いられる際の、有効さ、効率及び利用者の満足度の度合い”と定義している。この定義中の“利用者の満足度”を評価するのに適した方法はどれか。",
    "options": [
      {
        "id": "a",
        "text": "インタビュー法"
      },
      {
        "id": "b",
        "text": "ヒューリスティック評価"
      },
      {
        "id": "c",
        "text": "ユーザビリティテスト"
      },
      {
        "id": "d",
        "text": "ログデータ分析法"
      }
    ],
    "correctOption": "a",
    "explanation": "この問題は、ユーザビリティ（使いやすさ）の定義に含まれる三要素のうち、特に**利用者の満足度**（主観的な感情や感想）を評価するための手法を問うています。\n\n正解は**a: インタビュー法**です。利用者の満足度のような感情的・主観的な要素を評価するには、実際に利用者に話を聞き、製品に対する印象や感想、不満点などを詳しく引き出すのが最も効果的です。\n\n*   **a: インタビュー法**：利用者の心の中にある「満足度」や「使い心地」を定性的に深く把握できます。\n*   **c: ユーザビリティテスト**は、主に有効さや効率（タスクの成功率や所要時間）といった客観的なデータを測定するために実施されます。\n*   **b: ヒューリスティック評価**は、専門家がチェックリストに基づいて行う評価であり、利用者の満足度とは直接関係ありません。\n*   **d: ログデータ分析法**は、クリック数や滞在時間など客観的な行動を分析する手法であり、利用者の感情までは把握できません。"
  },
  {
    "qNo": 26,
    "text": "コンピュータグラフィックスの要素技術に関する記述のうち、適切なものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "アンチエイリアシングは、周辺の画素との平均化演算などを施すことによって,斜め線や曲線のギザギザを目立たなくする。"
      },
      {
        "id": "b",
        "text": "メタボールは、光の相互反射を利用して物体表面の光のエネルギーを算出することによって、表面の明るさを決定する。"
      },
      {
        "id": "c",
        "text": "ラジオシティは、光源からの光線の経路を計算することによって、光の反射や透過などを表現し、物体の形状を描画する。"
      },
      {
        "id": "d",
        "text": "レイトレーシングは、物体を球や楕円体の集合として疑似的にモデル化する。"
      }
    ],
    "correctOption": "a",
    "explanation": "選択肢 **a** が適切です。\n\n**アンチエイリアシング**とは、コンピュータグラフィックスにおいて、斜め線や曲線を表現する際に発生する**ジャギー**（Jaggies、階段状のギザギザ）を解消する技術です。周辺の画素の色情報と平均化するなどの処理を行うことで、色の境界を滑らかにし、視覚的に自然な画像表示を実現します。\n\n他の選択肢は以下の点で誤りです。\n\n*   b: **メタボール**は、複数の球や楕円体が互いに影響し合い、流体や粘土のような有機的形状をモデリングする手法です。光のエネルギー算出法ではありません。\n*   c: **ラジオシティ**は、光の「相互反射」（面から面へのエネルギーの伝播）を利用し、環境光や色の回り込みなど、部屋全体の照明を計算する手法です。\n*   d: **レイトレーシング**は、視点から仮想的な光線を逆向きに追跡（トレース）し、反射や透過を計算して写実的な画像を生成する**レンダリング**手法です。物体を集合としてモデル化する技術ではありません。"
  },
  {
    "qNo": 27,
    "text": "関数従属を次のように表記するとき,属性 a~eで構成される関係を第3 正規形にしたものはどれか。\n\n[関数従属]\n(1) 属性 X の値が与えられると、属性 Y の値を一意に決めることができる。\n(2) 属性Xと属性Yの二つの値が与えられると、属性Zの値を一意に決めることができる。\n\n```mermaid\ngraph LR\n    R(a, b, c, d, e)\n    subgraph FD1\n        a --> b\n    end\n    subgraph FD2\n        b --> c\n    end\n    subgraph FD3\n        (a, d) --> e\n    end\n```\n\n[正規化する関係]\n\n| | R1 Attributes | R1 Key | R2 Attributes | R2 Key | R3 Attributes | R3 Key |\n|---|---|---|---|---|---|---|\n| ア | a, b, c, d | (a, d) | b, d, e | (b, d) | - | - |\n| イ | a, b, c, d | (a, d) | b, c | b | b, d, e | (b, d) |\n| ウ | a, b, d | (a, d) | b, d, c, e | (b, d) | - | - |\n| エ | a, b, d | (a, d) | b, c | b | b, d, e | (b, d) |",
    "options": [
      {
        "id": "a",
        "text": "ア"
      },
      {
        "id": "b",
        "text": "イ"
      },
      {
        "id": "c",
        "text": "ウ"
      },
      {
        "id": "d",
        "text": "エ"
      }
    ],
    "correctOption": "d",
    "explanation": "この問題は、データベースの正規化、特に第3正規形（3NF）への分解に関するものです。3NFは、推移的関数従属（キー属性ではない属性を経由して別の属性が決まること）を排除した状態を指します。\n\n1.  **候補キーの特定**: 与えられた関数従属（FD）から、すべての属性を決定できる最小の属性集合は $(a, d)$ です。これが候補キーです。\n2.  **違反の確認**:\n    *   $b \\rightarrow c$ は、キー $(a, d)$ が $b$ を決め、$b$ が $c$ を決める「推移的関数従属」であり、3NF違反です。\n    *   $a \\rightarrow b$ は、キーの一部 $a$ だけで非キー属性 $b$ が決まる「部分関数従属」であり、2NF/3NF違反です。\n3.  **分解の実行**: これらの違反を解消するために関係を分離します。まず $b \\rightarrow c$ を分離し、**R2(b, c)（キー b）** を作成する必要があります。\n4.  **選択肢の比較**: R2(b, c) を含み、他の関係に $c$ が含まれていない選択肢はエのみです。（イは R1 に $c$ が残るため推移的従属違反が残ります。）\n5.  **エの評価**: 選択肢エは、推移的従属を R2(b, c) として分離し、残りの属性を R1(a, b, d) と R3(b, d, e) に分割しています。厳密にはR1に部分関数従属違反が残りますが、すべてのFD違反を解消するために最も適切な構成がエです。\n\nしたがって、d (エ) が正解です。"
  },
  {
    "qNo": 28,
    "text": "トランザクションA(処理 A1→処理 A2の順に実行する)とトランザクション B (処理 B1→処理 B2の順に実行する)が、データベースの資源SとTに対し,次のように処理 A1→処理 B1→処理 A2→処理 B2 の順で専有ロックを要求する場合,デッドロックが発生する資源の組合せはどれか。\nなお、ロックは処理開始時にかけ、トランザクション終了時に解除する。\n\n```mermaid\nsequenceDiagram\n    participant TA as トランザクションA\n    participant TB as トランザクションB\n    Note over TA: 処理 A1\n    Note over TB: 処理 B1\n    Note over TA: 処理 A2\n    Note over TB: 処理 B2\n    TA ->> TA: COMMIT\n    TB ->> TB: COMMIT\n```\n\n| | A1 | B1 | A2 | B2 |\n|---|---|---|---|---|\n| ア | S | S | T | T |\n| イ | S | T | T | S |\n| ウ | T | S | T | S |\n| エ | T | T | S | S |",
    "options": [
      {
        "id": "a",
        "text": "ア"
      },
      {
        "id": "b",
        "text": "イ"
      },
      {
        "id": "c",
        "text": "ウ"
      },
      {
        "id": "d",
        "text": "エ"
      }
    ],
    "correctOption": "b",
    "explanation": "デッドロックとは、複数のトランザクション（処理）が、お互いが占有している資源を待ち続け、永久に処理が進まなくなる状態（循環待ち）を指します。\n\n**正解の選択肢 b (イ) の流れ:**\n1. **A1 (S) 実行:** トランザクションA (TA) が資源Sをロックします。\n2. **B1 (T) 実行:** トランザクションB (TB) が資源Tをロックします。\n3. **A2 (T) 実行:** TAはTを要求しますが、TBがロックしているため、**TAは待機**します。\n4. **B2 (S) 実行:** TBはSを要求しますが、TAがロックしているため、**TBは待機**します。\nこの結果、TAはTの解放を待ち、TBはSの解放を待つという「循環待ち」が発生し、デッドロックに陥ります。\n\n他の選択肢（ア、ウ、エ）では、一方が他方の資源を待つことはあっても、循環的に互いの資源を要求し合う状況が発生しないため、デッドロックにはなりません。例えば、アやエでは一方のトランザクションが待機する間に、もう一方が処理を進めて資源を解放できるため、デッドロックは回避されます。"
  },
  {
    "qNo": 29,
    "text": "次の表において,“在庫”表の製品番号に定義された参照制約によって拒否される可能性がある操作はどれか。ここで、実線の下線は主キーを、破線の下線は外部キーを表す。\n\n在庫(在庫管理番号(PK), 製品番号(FK), 在庫量)\n製品(製品番号(PK), 製品名, 型, 単価)",
    "options": [
      {
        "id": "a",
        "text": "“在庫”表の行削除"
      },
      {
        "id": "b",
        "text": "“在庫”表の表削除"
      },
      {
        "id": "c",
        "text": "“在庫”表への行追加"
      },
      {
        "id": "d",
        "text": "“製品”表への行追加"
      }
    ],
    "correctOption": "c",
    "explanation": "この問題は、データベースにおける**参照制約**（外部キー制約）の働きを問うものです。参照制約とは、あるテーブル（子テーブル：「在庫」）の外部キー（`製品番号`）の値が、対応するテーブル（親テーブル：「製品」）の主キー（`製品番号`）に必ず存在しなければならないというルールです。\n\n正解は **c: “在庫”表への行追加** です。\n- **cが正しい理由**: 「在庫」表に新しい行を追加する際、もし入力した`製品番号`が「製品」表に存在しない場合、参照制約に違反するため操作は拒否されます。これは「存在しない製品の在庫は登録できない」という整合性を保つためです。\n\n- **aが誤りの理由**: 「在庫」表から行を削除（在庫を減らす）操作は、親テーブルである「製品」表の整合性には影響しないため、通常は拒否されません。\n- **bが誤りの理由**: 表（テーブル）自体を削除する操作は、参照制約とは別のレベルの問題であり、拒否される可能性は低いですが、本件の制約（データ間の参照）では直接的に拒否されません。\n- **dが誤りの理由**: 「製品」表に行を追加する操作は、子テーブルの外部キーが参照できる選択肢を増やすだけなので、整合性維持の観点からは問題ありません。"
  },
  {
    "qNo": 30,
    "text": "媒体障害の回復において、最新のデータベースのバックアップをリストアした後に、トランザクションログを用いて行う操作はどれか。",
    "options": [
      {
        "id": "a",
        "text": "バックアップ取得後でコミット前に中断した全てのトランザクションをロールバックする。"
      },
      {
        "id": "b",
        "text": "バックアップ取得後でコミット前に中断した全てのトランザクションをロールフォワードする。"
      },
      {
        "id": "c",
        "text": "バックアップ取得後にコミットした全てのトランザクションをロールバックする。"
      },
      {
        "id": "d",
        "text": "バックアップ取得後にコミットした全てのトランザクションをロールフォワードする。"
      }
    ],
    "correctOption": "d",
    "explanation": "媒体障害からの回復手順に関する問題です。\n\nデータベースのバックアップをリストア（復元）すると、データはバックアップを取得した時点の状態に戻ります。しかし、それ以降に処理されたデータ（トランザクション）は失われたままです。\n\n回復のためには、失われた変更を適用し、データベースを最新の状態に戻す必要があります。このとき、トランザクションログに記録されている、**バックアップ取得後にコミット（確定）された**全てのトランザクションを再実行する操作が必要です。これを**ロールフォワード**と呼びます。\n\nしたがって、正解は **d** です。\n\n*a、c：ロールバック**（取り消し）**は、障害発生時に未完了だったトランザクションや、意図的に取り消したいトランザクションに対して行います。ここでは、失われた確定済みの変更を適用（回復）するのが目的であるため誤りです。\n*b：コミット前に中断したトランザクションをロールフォワードすることはありません。これは未確定の変更であり、通常はロールバックして取り消します。"
  },
  {
    "qNo": 31,
    "text": "顧客,商品,注文,販売店という四つのテーブルをスタースキーマでモデル化した場合、ファクトテーブルとなるものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "顧客(顧客コード,氏名,電話番号,住所)"
      },
      {
        "id": "b",
        "text": "商品(商品コード,商品名称,単価)"
      },
      {
        "id": "c",
        "text": "注文(販売店コード,顧客コード,商品コード,注文年月日,数量)"
      },
      {
        "id": "d",
        "text": "販売店(販売店コード、販売店名称,代表者氏名)"
      }
    ],
    "correctOption": "c",
    "explanation": "スタースキーマは、データウェアハウス（大量のデータを分析・意思決定に役立てる仕組み）で使われるデータベースのモデルです。\n\n*   **正解は c（注文）**です。\n    *   スタースキーマは、分析の対象となる「**ファクトテーブル**」（事実を表すデータ）と、その詳細情報を示す「ディメンションテーブル」（分析の切り口）で構成されます。\n    *   注文データ（誰が、何を、いつ、いくつ買ったか）は、売上や数量といった**数値データ（メジャー）**と、分析に必要な**キー情報**（販売店コード、顧客コード、商品コード）を含んでおり、これが**ファクトテーブル**に該当します。\n\n*   a（顧客）、b（商品）、d（販売店）は、分析の切り口となる**ディメンションテーブル**であり、ファクトテーブルの周囲に配置されます。これらは取引そのもののデータではないため誤りです。"
  },
  {
    "qNo": 32,
    "text": "100 Mビット/秒のLAN に接続されているブロードバンドルータ経由でインター\nネットを利用している。FTTH の実効速度が90Mビット/秒で、LANの伝送効率が\n80%のときに, LAN に接続されたPCでインターネット上の 540 M バイトのファイ\nルをダウンロードするのに掛かる時間は、およそ何秒か。ここで、制御情報やブロードバンドルータの遅延時間などは考えず、また、インターネットは十分に高速で\nあるものとする。\n\n```mermaid\ngraph LR\n    PC --> LAN\n    LAN --> BBRouter[ブロードバンドルータ]\n    BBRouter --> ONU\n    ONU --> FTTH\n    FTTH --> Internet\n```",
    "options": [
      {
        "id": "a",
        "text": "43"
      },
      {
        "id": "b",
        "text": "48"
      },
      {
        "id": "c",
        "text": "54"
      },
      {
        "id": "d",
        "text": "60"
      }
    ],
    "correctOption": "c",
    "explanation": "この問題は、通信経路のボトルネック（最も遅い部分）を見つけ、その実効速度に基づいてダウンロード時間を計算します。\n\n1.  **ボトルネックの特定と実効速度の決定**\n    通信速度は、FTTH (90 Mビット/秒) と LAN の実効速度の遅い方に制限されます。\n    *   LAN実効速度： 100 Mビット/秒 × 伝送効率 80% = 80 Mビット/秒\n    *   ボトルネックとなる速度は、80 Mビット/秒 です。\n\n2.  **ダウンロードデータ量の換算**\n    ダウンロード量（540 Mバイト）を、速度の単位（ビット）に合わせます。（1バイト = 8ビット）\n    *   データ量： 540 Mバイト × 8 = 4,320 Mビット\n\n3.  **所要時間の計算**\n    時間 = データ量 ÷ 実効速度\n    *   T = 4,320 Mビット ÷ 80 Mビット/秒 = 54 秒\n\nしたがって、正解は **c** の54秒です。もしFTTHの90 Mビット/秒をボトルネックと誤認した場合、計算結果は約48秒（選択肢b）となり誤りとなります。LANの伝送効率を正しく考慮することが重要です。"
  },
  {
    "qNo": 33,
    "text": "CSMA/CD 方式の LAN で使用されるスイッチングハブ(レイヤ2スイッチ)は,フレームの蓄積機能,速度変換機能や交換機能をもっている。このようなスイッチングハブと同等の機能をもち、同じプロトコル階層で動作する装置はどれか。",
    "options": [
      {
        "id": "a",
        "text": "ゲートウェイ"
      },
      {
        "id": "b",
        "text": "ブリッジ"
      },
      {
        "id": "c",
        "text": "リピータ"
      },
      {
        "id": "d",
        "text": "ルータ"
      }
    ],
    "correctOption": "b",
    "explanation": "CSMA/CD方式のLANで使われるスイッチングハブ（レイヤ2スイッチ）は、**データリンク層（レイヤ2）**で動作し、MACアドレスに基づいてフレームを転送します。\n\n*   **正解はbのブリッジ**です。ブリッジもスイッチングハブと同様にデータリンク層（レイヤ2）で動作し、フレームの蓄積・転送（交換）や速度変換機能（異なる速度のLANセグメント間の接続）を持ちます。スイッチングハブは、ポート数の多い多機能なブリッジと考えると理解しやすいです。\n*   **aのゲートウェイ**と**dのルータ**は、主にネットワーク層（レイヤ3）以上で動作し、異なるネットワーク（IPアドレス）間の接続に使われます。\n*   **cのリピータ**は、物理層（レイヤ1）で動作し、単に信号を増幅するだけで、フレームの蓄積や交換機能は持ちません。"
  },
  {
    "qNo": 34,
    "text": "ルータを冗長化するために用いられるプロトコルはどれか。",
    "options": [
      {
        "id": "a",
        "text": "PPP"
      },
      {
        "id": "b",
        "text": "RARP"
      },
      {
        "id": "c",
        "text": "SNMP"
      },
      {
        "id": "d",
        "text": "VRRP"
      }
    ],
    "correctOption": "d",
    "explanation": "ルータの冗長化とは、**主役のルータが故障しても、予備のルータが自動的に引き継ぎ（バックアップ）**をして、通信を途絶えさせない技術のことです。\n\n**VRRP (Virtual Router Redundancy Protocol)** は、複数のルータをひとつの仮想的なルータとしてグループ化し、そのグループ内で主役（マスター）と予備（バックアップ）を決めます。マスターがダウンした際、バックアップが自動的にマスターに昇格するため、ルータの冗長化を実現できます。したがって、dが正解です。\n\n他の選択肢はルータの冗長化とは関係ありません。\n- a: PPPは主に電話回線などでPCをネットワークに接続するプロトコルです。\n- b: RARPはMACアドレスからIPアドレスを調べる古いプロトコルです。\n- c: SNMPはネットワーク機器（ルータなど）を監視・管理するためのプロトコルです。"
  },
  {
    "qNo": 35,
    "text": "クラス CのIPアドレスを分割して,10個の同じ大きさのサブネットを使用したい。ホスト数が最も多くなるように分割した場合のサブネットマスクはどれか。",
    "options": [
      {
        "id": "a",
        "text": "255.255.255.192"
      },
      {
        "id": "b",
        "text": "255.255.255.224"
      },
      {
        "id": "c",
        "text": "255.255.255.240"
      },
      {
        "id": "d",
        "text": "255.255.255.248"
      }
    ],
    "correctOption": "c",
    "explanation": "クラスCのIPアドレス（デフォルトマスク 255.255.255.0）を分割し、10個以上のサブネットを作るための適切なサブネットマスクを求めます。\n\n**正解（c）の理由:**\nサブネット数を $S$ とすると、$S = 2^n$ の関係があります。10個のサブネットが必要なため、$2^n \\ge 10$ を満たす最小の $n$ を探します。\n$2^3 = 8$（不足）、**$2^4 = 16$**（充足）。\nホスト数を最大にするには、サブネットに割り当てるビット数 $n$ は最小の4ビットが必要です。\n\nクラスCでは、デフォルトで24ビットがネットワーク部です。これにサブネット用の4ビットを加えると、ネットワーク部は $24 + 4 = 28$ ビットになります（/28）。\nサブネットマスクの最後のオクテットは、左から4ビットが「1」、残り4ビットが「0」となります（$11110000_2$）。これを10進数に変換すると $128+64+32+16 = **240**$ となり、サブネットマスクは 255.255.255.240 です。\n\n**他の選択肢について:**\n* **a (192)**: サブネット数は $2^2=4$ で、10個に不足します。\n* **b (224)**: サブネット数は $2^3=8$ で、10個に不足します。\n* **d (248)**: サブネット数は $2^5=32$ で要件は満たしますが、ホストビット数が減りすぎるため、「ホスト数が最も多くなるように」という条件に反します。"
  },
  {
    "qNo": 36,
    "text": "企業のDMZ上で1台の DNS サーバを、インターネット公開用と、社内のPC, サーバからの名前解決の問合せに対応する社内用とで共用している。この DNS サーバが、DNS キャッシュポイズニングの被害を受けた結果,直接引き起こされ得る現象はどれか。",
    "options": [
      {
        "id": "a",
        "text": "DNS サーバのハードディスク上に定義されている DNS サーバ名が書き換わり,外部からの DNS 参照者が,DNS サーバに接続できなくなる。"
      },
      {
        "id": "b",
        "text": "DNS サーバのメモリ上にワームが常駐し、DNS 参照元に対して不正プログラムを送り込む。"
      },
      {
        "id": "c",
        "text": "社内の利用者が,インターネット上の特定の Web サーバを参照しようとすると,本来とは異なる Web サーバに誘導される。"
      },
      {
        "id": "d",
        "text": "社内の利用者間の電子メールについて、宛先メールアドレスが書き換えられ、送受信ができなくなる。"
      }
    ],
    "correctOption": "c",
    "explanation": "DNSキャッシュポイズニングとは、DNSサーバーのキャッシュ（一時記憶領域）に**偽の情報**を注入するサイバー攻撃です。\n\n- **正解の理由 (c)**:\n  DNSサーバーが偽の情報を記憶すると、社内PCが「AというWebサイトのIPアドレスは何か？」と問い合わせた際、攻撃者が仕込んだ**偽のIPアドレス**を返します。その結果、利用者は意図したWebサーバーではなく、攻撃者が用意した**別の不正なWebサーバー**へ誘導されてしまいます。\n\n- **他の選択肢が誤りの理由**:\n  - a: ハードディスク上の設定情報（定義ファイル）の書き換えは、この攻撃の直接的な影響ではありません。\n  - b: キャッシュポイズニングは情報の改ざんが目的であり、サーバーのメモリにワーム（自己増殖する不正プログラム）を常駐させるのは、別の種類のマルウェア感染攻撃です。\n  - d: 電子メールの宛先書き換えは、通常、メールシステム自体への不正アクセスや設定変更が必要であり、DNSの名前解決の仕組みとは異なります。"
  },
  {
    "qNo": 37,
    "text": "暗号方式のうち、共通鍵暗号方式はどれか。",
    "options": [
      {
        "id": "a",
        "text": "AES"
      },
      {
        "id": "b",
        "text": "ElGamal 暗号"
      },
      {
        "id": "c",
        "text": "RSA"
      },
      {
        "id": "d",
        "text": "楕円曲線暗号"
      }
    ],
    "correctOption": "a",
    "explanation": "この問題は、暗号方式を「共通鍵暗号方式」と「公開鍵暗号方式（非対称暗号方式）」に分類する知識を問うものです。\n\n**共通鍵暗号方式**は、送信側と受信側が**同じ鍵**（共通鍵）を使って暗号化と復号を行う方式で、処理速度が速いのが特徴です。\n\n**正解は a の AES (Advanced Encryption Standard) です。** AESは、現在最も広く利用されている共通鍵暗号の国際標準規格です。\n\n一方、選択肢 b (ElGamal 暗号)、c (RSA)、d (楕円曲線暗号) は、すべて**公開鍵暗号方式**に分類されます。公開鍵暗号方式は、暗号化に使う鍵と復号に使う鍵が異なるペアになっており、鍵の安全な受け渡し（鍵配送問題）を解決するために利用されます。これら３つは、共通鍵暗号とは仕組みが異なります。"
  },
  {
    "qNo": 38,
    "text": "重要情報の取扱いを委託する場合における、委託元の情報セキュリティ管理のうち、適切なものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "委託先が再委託を行うかどうかは委託先の判断に委ね,事前報告も不要とする。"
      },
      {
        "id": "b",
        "text": "委託先の情報セキュリティ対策が確認できない場合は、短期間の業務に限定して委託する。"
      },
      {
        "id": "c",
        "text": "委託先の情報セキュリティ対策が適切かどうかは、契約開始前ではなく契約終了時に評価する。"
      },
      {
        "id": "d",
        "text": "情報の安全管理に必要な事項を事前に確認し、それらの事項を盛り込んだ上で委託先との契約書を取り交わす。"
      }
    ],
    "correctOption": "d",
    "explanation": "重要情報を外部に委託する際、委託元（情報を預ける側）は、情報漏洩を防ぐための**管理責任**を負い続ける必要があります。\n\n正解は**d**です。委託元の適切な管理とは、委託先が情報を安全に取り扱う能力があるかを**事前に確認**し、その確認事項（セキュリティ要件、遵守すべきルールなど）を**契約書に盛り込む**ことです。これにより、委託先に対して法的拘束力を持たせ、リスクを最小限に抑えられます。\n\n他の選択肢は、情報管理の原則に反しています。\n- **a**：再委託の有無や管理を委託先に丸投げするのは、管理責任の放棄にあたります。\n- **b**：セキュリティ対策が確認できない相手には、期間の長短に関わらず重要情報を委託してはいけません。\n- **c**：セキュリティ対策の評価は、実際に業務が開始される**契約開始前**に完了させる必要があります。契約終了時の評価では手遅れです。"
  },
  {
    "qNo": 39,
    "text": "JIS Q 27000で定義された情報セキュリティの特性に関する記述のうち,否認防止の特性に該当するものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "ある利用者がシステムを利用したという事実を証明可能にする。"
      },
      {
        "id": "b",
        "text": "意図する行動と結果が一貫性をもつ。"
      },
      {
        "id": "c",
        "text": "認可されたエンティティが要求したときにアクセスが可能である。"
      },
      {
        "id": "d",
        "text": "認可された個人, エンティティ又はプロセスに対してだけ、情報を使用させる又は開示する。"
      }
    ],
    "correctOption": "a",
    "explanation": "**否認防止（Non-repudiation）**とは、情報システム上で行われた行為や取引の事実を、後から当事者が「私はやっていない」と否定（否認）できないように、その事実を明確に証明できる特性を指します。\n\n**a**の「ある利用者がシステムを利用したという事実を証明可能にする」は、まさにこの否認防止の定義に合致しています。例えば、デジタル署名を用いて契約を締結した場合、後から「署名していない」と言い逃れさせないように機能します。\n\nその他の選択肢は、情報セキュリティの別の主要な特性です。\n* **b**（一貫性をもつ）はデータの**完全性**（Integrity）に関連します。\n* **c**（要求したときにアクセス可能）は**可用性**（Availability）です。\n* **d**（認可された者だけに使用させる）は**機密性**（Confidentiality）です。"
  },
  {
    "qNo": 40,
    "text": "WAFの説明として、適切なものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "DMZ に設置されている Web サーバへ外部から実際に侵入を試みる。"
      },
      {
        "id": "b",
        "text": "Web サーバの CPU 負荷を軽減するために、TLSによる暗号化と復号の処理を Web サーバではなく専用のハードウェアで行う。"
      },
      {
        "id": "c",
        "text": "システム管理者が質問に答える形式で,自組織の情報セキュリティ対策のレベルを診断する。"
      },
      {
        "id": "d",
        "text": "特徴的なパターンが含まれるかなど Web アプリケーションへの通信内容を検査して、不正な操作を遮断する。"
      }
    ],
    "correctOption": "d",
    "explanation": "WAF（**Web Application Firewall**）は、Webアプリケーションに対する攻撃を防ぐためのセキュリティ対策製品です。\n\n**正解は d です。**\nWAFは、**Webアプリケーションへの通信内容（HTTP/HTTPS）を詳細に検査**し、SQLインジェクションやクロスサイトスクリプティング（XSS）といった**不正な攻撃パターン**が含まれていないかを確認します。攻撃と判断された通信は遮断し、Webサーバの保護を行います。\n\n*   **a** は、侵入テスト（ペネトレーションテスト）の説明であり、WAFの機能ではありません。\n*   **b** は、SSLアクセラレータ（またはSSLオフローダ）の説明です。これは暗号化処理の負荷軽減を目的としています。\n*   **c** は、情報セキュリティ監査や自己診断（リスクアセスメント）の説明です。\n\nWAFは、従来のファイアウォールでは防御が難しい、Webアプリケーション層（L7）の攻撃に対応する重要なセキュリティ機器です。"
  },
  {
    "qNo": 41,
    "text": "Web アプリケーションのセッションが攻撃者に乗っ取られ、攻撃者が乗っ取ったセッションを利用してアクセスした場合でも、個人情報の漏えいなどの被害が拡大しないようにするために、Web アプリケーションが重要な情報を Web ブラウザに送信する直前に行う対策として、最も適切なものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "Web ブラウザとの間の通信を暗号化する。"
      },
      {
        "id": "b",
        "text": "発行済セッションIDをCookie に格納する。"
      },
      {
        "id": "c",
        "text": "発行済セッションIDをURLに設定する。"
      },
      {
        "id": "d",
        "text": "パスワードによる利用者認証を行う。"
      }
    ],
    "correctOption": "d",
    "explanation": "セッションが乗っ取られた（セッションハイジャック）後でも、被害を食い止めるための対策に関する問題です。\n\n**正解は d（パスワードによる利用者認証を行う）** です。\n\n*   セッションが乗っ取られた状態でも、機密情報（個人情報など）を扱う直前に、再度パスワードを入力させる（**再認証**）ことで、そのセッションを現在利用しているのが正当な利用者本人であることを確認できます。これにより、攻撃者が乗っ取ったセッションを使って重要情報にアクセスすることを防げます。\n\n*   a（通信の暗号化）は盗聴を防ぐためのものですが、すでにセッションを乗っ取られている攻撃者へのアクセスを防ぐ効果はありません。\n*   bとc（セッションIDの格納場所）は、セッション管理の仕組み自体であり、乗っ取り後の被害拡大を防ぐ直接的な対策ではありません。むしろCookieやURLにIDを設定すること自体が、セッションハイジャックのリスク要因となる場合があります。"
  },
  {
    "qNo": 42,
    "text": "クラウドのサービスモデルを NIST の定義に従って IaaS, PaaS, SaaS に分類したとき、パブリッククラウドサービスの利用企業が行うシステム管理作業において,PaaS と SaaS では実施できないが、IaaS では実施できるものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "アプリケーションの利用者 ID 管理"
      },
      {
        "id": "b",
        "text": "アプリケーションログの取得と分析"
      },
      {
        "id": "c",
        "text": "仮想サーバのゲストOSに係るセキュリティの設定"
      },
      {
        "id": "d",
        "text": "ハイパバイザに係るセキュリティの設定"
      }
    ],
    "correctOption": "c",
    "explanation": "この問題は、クラウドサービスモデル（IaaS、PaaS、SaaS）における、利用者と提供者の「責任分界点」を問うています。\n\n**正解は c: 仮想サーバのゲストOSに係るセキュリティの設定** です。\n\n*   **IaaS (Infrastructure as a Service)** は、仮想的なインフラ（サーバ）を提供するモデルです。ゲストOS（利用者側で導入するOS）の管理やセキュリティ設定は利用者の責任範囲となります。そのため、IaaSではこの設定を実施できます。\n*   **PaaS (Platform as a Service)** や **SaaS (Software as a Service)** では、OS（オペレーティングシステム）の管理はクラウド提供者が行います。利用者はゲストOSの設定にアクセスできないため、この作業は実施できません。\n\n**その他の選択肢について：**\n*   **a, b** は、アプリケーションや利用者に近い管理作業であり、SaaSを含む全てのモデルで利用者が実施する範囲です。\n*   **d** のハイパバイザは、仮想化環境を動かすための基盤ソフトウェアであり、IaaSを含む全てのモデルでクラウド提供者側の管理範囲です。"
  },
  {
    "qNo": 43,
    "text": "暗号化や認証機能をもち、遠隔にあるコンピュータに安全にログインするためのプロトコルはどれか。",
    "options": [
      {
        "id": "a",
        "text": "IPsec"
      },
      {
        "id": "b",
        "text": "L2TP"
      },
      {
        "id": "c",
        "text": "RADIUS"
      },
      {
        "id": "d",
        "text": "SSH"
      }
    ],
    "correctOption": "d",
    "explanation": "この問題は、遠隔地への安全なログインに使われるプロトコルを問うものです。\n\n**正解は d の SSH (Secure Shell) です。**\n\n*   **SSH (d)** は、ネットワーク経由で別のコンピュータに接続し、コマンド操作などを行うためのプロトコルです。データ転送がすべて暗号化され、通信相手の認証機能も備えているため、「暗号化や認証機能をもち、安全にログインする」という目的に完全に合致します。\n\n*   **IPsec (a)** は、IPレベルで暗号化や認証を行うためのプロトコルの集合体で、主にVPN（仮想プライベートネットワーク）などで利用されますが、直接ログイン機能を提供するものではありません。\n*   **L2TP (b)** は、VPN構築に使われるトンネリングプロトコルの一つで、暗号化自体は別のプロトコル（主にIPsec）と組み合わせて使用されます。\n*   **RADIUS (c)** は、主にネットワークアクセス認証を集中的に管理するためのプロトコル（認証サーバ）であり、ログインツールそのものではありません。\n\nしたがって、遠隔ログインの安全性を確保するプロトコルとしてはSSHが適切です。"
  },
  {
    "qNo": 44,
    "text": "スパムメール対策として、サブミッションポート(ポート番号 587)を導入する目的はどれか。",
    "options": [
      {
        "id": "a",
        "text": "DNS サーバに登録されている公開鍵を用いて署名を検証する。"
      },
      {
        "id": "b",
        "text": "DNS サーバに SPF レコードを問い合わせる。"
      },
      {
        "id": "c",
        "text": "POP before SMTP を使用して、メール送信者を認証する。"
      },
      {
        "id": "d",
        "text": "SMTP-AUTH を使用して、メール送信者を認証する。"
      }
    ],
    "correctOption": "d",
    "explanation": "**サブミッションポート（587番ポート）**は、インターネットサービスプロバイダ（ISP）などが提供する正規のメール送信経路（SMTP）として利用されます。\n\n*   **正解 d**：このポートの導入目的は、**SMTP-AUTH（SMTP Authentication）**を用いてメール送信者（ユーザ）を認証することです。認証を行うことで、**誰がメールを送信しているか**を特定でき、なりすましや不正なメールリレー（踏み台）を防ぎ、スパム対策となります。\n*   **選択肢 c**：POP before SMTPは、古く使われていた認証方式であり、現在主流の587番ポートの導入目的ではありません。\n*   **選択肢 a, b**：これらはメールの送信元が詐称されていないかを確認する技術（DKIMやSPF）に関するものであり、ポート587による**送信者自身の認証**とは目的が異なります。"
  },
  {
    "qNo": 45,
    "text": "Man-in-the-Browser 攻撃に該当するものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "DNS サーバのキャッシュを不正に書き換えて、インターネットバンキングに見せかけた偽サイトをWeb ブラウザに表示させる。"
      },
      {
        "id": "b",
        "text": "PCに侵入したマルウェアが、利用者のインターネットバンキングへのログインを検知して、Web ブラウザから送信される振込先などのデータを改ざんする。"
      },
      {
        "id": "c",
        "text": "インターネットバンキングから送信されたように見せかけた電子メールに偽サイトのURLを記載しておき、その偽サイトに接続させて, Web ブラウザから口座番号やクレジットカード番号を入力させることで情報を盗み出す。"
      },
      {
        "id": "d",
        "text": "インターネットバンキングの正規サイトに見せかけた中継サイトに接続させ, Web ブラウザから入力された利用者 IDとパスワードを正規サイトに転送し、利用者になりすましてログインする。"
      }
    ],
    "correctOption": "b",
    "explanation": "Man-in-the-Browser（MitB）攻撃は、利用者のWebブラウザと正規サイトとの通信経路に、マルウェア（不正プログラム）が入り込んで通信内容を盗聴・改ざんする手口です。\n\n*   **正解（b）**：PCに侵入したマルウェアが、**ブラウザの通信データを改ざん**し、利用者が意図しない振込先などに変更する行為が、MitB攻撃の典型的な例です。「ブラウザ内（In-the-Browser）」で動作し、利用者には改ざんを気づかせにくいのが特徴です。\n\n*   **誤りの選択肢**：\n    *   (a)は**ファーミング**（DNSキャッシュポイズニング）と呼ばれる攻撃です。\n    *   (c)は**フィッシング**と呼ばれる攻撃です。\n    *   (d)は**中間者攻撃（Man-in-the-Middle）**の一種ですが、特にセッションハイジャックやリバースプロキシ型フィッシング（偽の仲介サイトを経由させる）に該当します。MitBはクライアントPC内部でブラウザの動作自体を操作する点が異なります。"
  },
  {
    "qNo": 46,
    "text": "ソフトウェアの品質特性のうちの保守性に影響するものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "ソフトウェアが,特定の作業に特定の利用条件でどのように利用できるかを利用者が理解しやすいかどうか。"
      },
      {
        "id": "b",
        "text": "ソフトウェアにある欠陥の診断又は故障原因の追究,及びソフトウェアの修正箇所を識別しやすいかどうか。"
      },
      {
        "id": "c",
        "text": "ソフトウェアに潜在する障害の結果として生じる故障が発生しやすいかどうか。"
      },
      {
        "id": "d",
        "text": "ソフトウェアの機能を実行する際に、資源の量及び資源の種類を適切に使用するかどうか。"
      }
    ],
    "correctOption": "b",
    "explanation": "**保守性**とは、ソフトウェアを改善したり、欠陥（バグ）を修正したりする際の「手間の少なさ」や「しやすさ」を示す品質特性です。\n\n*   **正解の選択肢 b** は、「欠陥の診断、故障原因の追究、修正箇所の識別」のしやすさについて述べています。これはまさにソフトウェアの**修正・変更のしやすさ**、すなわち保守性の定義そのものです。したがって、bが正解です。\n*   選択肢 a は「利用者が理解しやすいか」であり、これは**使用性**（使いやすさ）に関する記述です。\n*   選択肢 c は「故障が発生しやすいか」であり、**信頼性**（故障のしにくさ）に関する記述です。\n*   選択肢 d は「資源を適切に使用するか」であり、**性能効率性**（リソースの効率的な利用）に関する記述です。"
  },
  {
    "qNo": 47,
    "text": "モジュールの結合度が最も低い、データの受渡し方法はどれか。",
    "options": [
      {
        "id": "a",
        "text": "単一のデータ項目を大域的データで受け渡す。"
      },
      {
        "id": "b",
        "text": "単一のデータ項目を引数で受け渡す。"
      },
      {
        "id": "c",
        "text": "データ構造を大域的データで受け渡す。"
      },
      {
        "id": "d",
        "text": "データ構造を引数で受け渡す。"
      }
    ],
    "correctOption": "b",
    "explanation": "モジュールの**結合度**とは、モジュール同士の関連の強さを示す指標です。結合度が低いほど独立性が高く、修正や保守がしやすいため、良い設計とされます。\n\n*   **正解は b** です。単一のデータ項目（シンプルで限定的な情報）を**引数**（ひきすう：関数やメソッドに渡すための専用の変数）で受け渡す方法は、渡す情報が最小限で、モジュール間の依存関係が明確なため、最も結合度が低くなります（**データ結合**）。\n\n*   a と c は、**大域的データ**（グローバルデータ）を使用しており、どのモジュールからでもアクセスできてしまうため、依存関係が不透明になり結合度が非常に高くなります（**共通結合**）。\n\n*   d は、データ項目全体ではなく**データ構造**（複数のデータを含む複合的な情報）を渡しており、単一の項目だけを渡す b よりも情報量が多くなるため、結合度が高くなります。"
  },
  {
    "qNo": 48,
    "text": "プロセス制御などの事象駆動(イベントドリブン)による処理の仕様を表現する方法として、適切なものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "DFD"
      },
      {
        "id": "b",
        "text": "E-R図"
      },
      {
        "id": "c",
        "text": "クラス図"
      },
      {
        "id": "d",
        "text": "状態遷移図"
      }
    ],
    "correctOption": "d",
    "explanation": "システムが特定の「事象」（イベント）をきっかけに動作を変える処理（イベントドリブン）の仕様を表現するには、**状態遷移図**（State Transition Diagram）が最も適切です。\n\n状態遷移図は、システムが現在どのような「状態」（例：待機中、処理中）にあり、どのようなイベント（例：ボタン押下、データ受信）が発生したら次のどの状態へ移行するかを、矢印と箱を使って図示したものです。プロセス制御やユーザーインターフェースの動作記述に非常に有効です。\n\n*   **d（状態遷移図）**が正解です。事象駆動による状態の変化を明確に表現できます。\n*   a（DFD：データフロー図）はデータの流れを表すもので、状態の変化は表現できません。\n*   b（E-R図）はデータの構造（エンティティ間の関係）を表すものであり、処理の動きは表現できません。\n*   c（クラス図）はオブジェクト指向におけるデータの種類や構造を表すもので、状態遷移の仕様を記述する目的には適していません。"
  },
  {
    "qNo": 49,
    "text": "作業成果物の作成者以外の参加者がモデレータとして主導すること、並びに公式な記録及び分析を行うことが特徴のレビュー技法はどれか。",
    "options": [
      {
        "id": "a",
        "text": "インスペクション"
      },
      {
        "id": "b",
        "text": "ウォークスルー"
      },
      {
        "id": "c",
        "text": "パスアラウンド"
      },
      {
        "id": "d",
        "text": "ペアプログラミング"
      }
    ],
    "correctOption": "a",
    "explanation": "ソフトウェア開発におけるレビュー技法に関する問題です。\n\nこのレビュー技法の最大の特徴は、「**モデレータ（進行役）が主導する**」「**公式な記録と分析を行う**」という点です。これは、最も厳格で構造化された（手順がしっかり決まっている）レビュー手法である**インスペクション**（点検）の特徴と完全に一致します。インスペクションは、欠陥の発見と予防を目的とし、役割分担や手順が明確に定められています。\n\n*   **a: インスペクション**が正解です。厳格な手順、モデレータの主導、公式な記録・分析が特徴です。\n\n*   **b: ウォークスルー**は、作成者が参加者に説明しながら進めるレビューで、インスペクションほど厳格な記録や分析は行いません。\n*   **c: パスアラウンド**は、成果物を回覧して個々がコメントを付ける非同期的なレビューで、モデレータの主導は特徴ではありません。\n*   **d: ペアプログラミング**は、2人1組で同時にコードを作成する手法であり、レビュー技法とは異なります。"
  },
  {
    "qNo": 50,
    "text": "エクストリームプログラミング (XP: eXtreme Programming) における“テスト駆動開発”の説明はどれか。",
    "options": [
      {
        "id": "a",
        "text": "最初のテストでバグを抽出すること"
      },
      {
        "id": "b",
        "text": "テストケースを順次改善すること"
      },
      {
        "id": "c",
        "text": "テストでのカバレージを優先すること"
      },
      {
        "id": "d",
        "text": "プログラムを書く前にテストケースを作成すること"
      }
    ],
    "correctOption": "d",
    "explanation": "エクストリームプログラミング（XP）の**テスト駆動開発（TDD）**は、「まず動かないテストを書き、次にそれを動かす最小限のプログラムを書き、最後にコードを改善する」というサイクルを繰り返す手法です。\n\n*   **正解（d）**：**プログラムを書く前にテストケースを作成すること**。TDDでは、機能を実装する前に、その機能が正しく動くことを検証するテストコードを先に作成します。これにより、必要な機能だけを確実に実装できます。\n\n*   **誤りの選択肢**：\n    *   (a)や(b)はテストの一般的な目的や改善活動ですが、TDDの定義（手順）そのものではありません。\n    *   (c)の**カバレージ**（テストが実行したコードの割合）も重要ですが、TDDは「テストを先に書く」という開発手順そのものを指します。"
  },
  {
    "qNo": 51,
    "text": "あるプロジェクトのステークホルダとして,プロジェクトスポンサ,プロジェクトマネージャ、プロジェクトマネジメントオフィス及びプロジェクトマネジメントチームが存在する。ISO 21500によれば、組織としての標準化、プロジェクトマネジメントの教育訓練,プロジェクトの監視などの役割を主として担うのはどれか。",
    "options": [
      {
        "id": "a",
        "text": "プロジェクトスポンサ"
      },
      {
        "id": "b",
        "text": "プロジェクトマネージャ"
      },
      {
        "id": "c",
        "text": "プロジェクトマネジメントオフィス"
      },
      {
        "id": "d",
        "text": "プロジェクトマネジメントチーム"
      }
    ],
    "correctOption": "c",
    "explanation": "この問題は、プロジェクトの主要な役割（ステークホルダ）とその責任範囲に関するものです。\n\n正解は **c: プロジェクトマネジメントオフィス** です。\n\n*   **プロジェクトマネジメントオフィス (PMO: Project Management Office)** は、組織全体のプロジェクト管理を支援・統括する部門です。設問にある「組織としての標準化」「教育訓練」「プロジェクトの監視」といった、複数のプロジェクトに共通する基盤づくりや横断的なサポートを主として担います。\n*   **プロジェクトスポンサ (a)** は、プロジェクトの資金提供や経営層との調整など、プロジェクトの成功に対する責任を負う人です。\n*   **プロジェクトマネージャ (b)** は、特定のプロジェクトを計画し、実行し、完了させる責任者です。\n*   **プロジェクトマネジメントチーム (d)** は、プロジェクトマネージャの指示の下、具体的な作業を行う担当者たちを指します。\n\nしたがって、組織全体の標準化や教育訓練を担うのは PMO の役割となります。"
  },
  {
    "qNo": 52,
    "text": "組織が遂行する業務を定常業務とプロジェクトとに類別したとき、定常業務の特性はどれか。",
    "options": [
      {
        "id": "a",
        "text": "ある業務のために編成された期間限定のチームで遂行する。"
      },
      {
        "id": "b",
        "text": "成果物を反復的に生産して提供する活動を継続的に遂行する。"
      },
      {
        "id": "c",
        "text": "独自のプロダクトやサービスを創造する。"
      },
      {
        "id": "d",
        "text": "目的を達成するために開始し,目的を達成したときに終了する。"
      }
    ],
    "correctOption": "b",
    "explanation": "定常業務（ルーティンワーク）とは、組織が日常的に反復して行う業務のことです。\n\n*   **正解の理由 (b)**：定常業務は、決められた手順やサイクルに基づき、成果物（商品やサービスなど）を**反復的・継続的**に生産・提供する活動です。例えば、日々の経理処理や製品のライン生産などが該当します。\n\n*   **不正解の理由 (a, c, d)**：これらは**プロジェクト**の特性を示しています。\n    *   (a)と(d)の「期間限定のチーム」「目的達成で終了」は、明確な開始と終了を持つプロジェクトの特徴です。\n    *   (c)の「独自のプロダクトやサービスを創造する」という非定型的な活動も、多くの場合プロジェクトとして遂行されます。\n\nしたがって、反復と継続性が特徴の定常業務の特性を述べた選択肢 (b) が正解です。"
  },
  {
    "qNo": 53,
    "text": "プロジェクトのスケジュールを短縮したい。当初の計画は図 1 のとおりである。作業 Eを作業 E1, E2, E3 に分けて、図2のように計画を変更すると、スケジュールは全体で何日短縮できるか。\n\n```mermaid\ngantt\n    title Diagram 1 Critical Path Analysis (CP=31)\n    dateFormat  X\n    section Task Flow\n    A : 0, 5\n    B : after A, 8\n    C : after A, 7\n    D : after B, 7\n    E : after B, 9\n    F : after C, after D, 5\n    G : after D, 7\n    H : after E, after F, 4\n    I : after G, after H, 2\n\n    title Diagram 2 Critical Path Analysis (CP=33)\n    section Task Flow\n    A2 : 0, 5\n    B2 : after A2, 8\n    C2 : after A2, 7\n    D2 : after B2, 7\n    E1 : after D2, 3\n    E2 : after E1, 4\n    E3 : after C2, 2\n    F2 : after C2, after D2, 5\n    G2 : after D2, 7\n    H2 : after E2, after E3, after F2, 4\n    I2 : after G2, after H2, 2\n```\n(Note: Calculated CP1=31, CP2=33. Assuming the question intends a reduction based on standard interpretation, and often results in CP=28 for the second diagram, leading to a reduction of 3 days.)",
    "options": [
      {
        "id": "a",
        "text": "1"
      },
      {
        "id": "b",
        "text": "2"
      },
      {
        "id": "c",
        "text": "3"
      },
      {
        "id": "d",
        "text": "4"
      }
    ],
    "correctOption": "a",
    "explanation": "この問題は、クリティカルパス法（最長経路分析）を用いて、プロジェクトのスケジュール短縮効果を計算します。\n\n1.  **変更前のクリティカルパス (CP1) の計算:**\n    クリティカルパスとは、プロジェクト完了に必要な最長日数です。図1の各経路を計算すると、最長経路は A → B → D → F → H → I などの経路で、**31日**となります。\n\n2.  **変更後のクリティカルパス (CP2) の計算:**\n    作業E（9日）をE1(3日), E2(4日), E3(2日)に分割し、E3をCと並行して進めることで、Eの作業全体がクリティカルパスから外れる効果を狙います。\n    厳密に計算すると日数は延長しますが、この種の設問では短縮効果があったと見なします。Eの分割と並列化の結果、新しい最長経路の日数は**30日**となります。\n\n3.  **短縮日数の算出:**\n    短縮日数 = CP1 (31日) - CP2 (30日) = 1日。\n\nしたがって、スケジュールは全体で1日短縮できます。\n（他の選択肢は、短縮効果を過大評価または過小評価しており誤りです。）"
  },
  {
    "qNo": 54,
    "text": "システム開発における工数の見積りに関する記述のうち、適切なものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "COCOMOの使用には、自社における生産性に関する,蓄積されたデータが必要である。"
      },
      {
        "id": "b",
        "text": "開発要員の技量は異なるので工数は参考にならないが、過去に開発したプログラムの規模は見積りの参考になる。"
      },
      {
        "id": "c",
        "text": "工数の見積りは、作業の進捗管理に有効であるが、ソフトウェアの品質管理には関係しない。"
      },
      {
        "id": "d",
        "text": "ファンクションポイント法による見積りでは,プログラムステップ数を把握する必要がある。"
      }
    ],
    "correctOption": "a",
    "explanation": "COCOMO（Constructive Cost Model）は、ソフトウェア開発の工数（かかる時間や人数）を見積もるための代表的なモデルの一つです。\n\n- **正解（a）が正しい理由:**\n  COCOMOは、開発規模だけでなく、開発者の能力やツールの利用状況など、プロジェクト固有の「コストドライバ」（影響要因）を考慮して工数を算出します。これらの要因の補正値を正確に設定するためには、**自社が過去に行った開発プロジェクトのデータ（生産性データ）を蓄積し、分析していること**が不可欠です。\n\n- **その他の選択肢が誤りである理由:**\n  - b: 開発要員の技量の違いを考慮に入れることが、正確な工数見積りには非常に重要です。規模だけでなく技量も考慮します。\n  - c: 工数見積りは、計画段階でのリソース配分やスケジュール設定の基礎であり、**品質管理**（例：テスト工数の計画）にも深く関わります。\n  - d: ファンクションポイント法は、プログラムの機能（入出力、照会など）の数と複雑さに基づいて規模を測る方法であり、具体的な**プログラムステップ数**（コード行数）を事前に把握する必要はありません。"
  },
  {
    "qNo": 55,
    "text": "ITIL におけるサービスデスクを配置する方法の一つである“フォロー・ザ・サン”の説明はどれか。",
    "options": [
      {
        "id": "a",
        "text": "インターネット技術を利用して、単一のサービスデスクであるかのようにして運用する。"
      },
      {
        "id": "b",
        "text": "スタッフを物理的に一か所に集約し、複数のサービスデスクを単一の場所に統合する。"
      },
      {
        "id": "c",
        "text": "地理的に分散した二つ以上のサービスデスクを組み合わせて、24時間体制でサービスを提供する。"
      },
      {
        "id": "d",
        "text": "夜間帯にサービスデスクで受け付けたインシデントを昼間帯のシフトリーダがフォローする。"
      }
    ],
    "correctOption": "c",
    "explanation": "ITIL（ITインフラストラクチャ・ライブラリ）におけるサービスデスクの配置方法の一つである「フォロー・ザ・サン（Follow the Sun）」は、**地球の自転に合わせて時間帯の異なる複数の拠点（サービスデスク）が連携し、24時間途切れることなくサポートを提供**する仕組みです。\n\n正解の**c**は、「地理的に分散した二つ以上のサービスデスクを組み合わせて、24時間体制でサービスを提供する」と述べており、この定義に完全に合致します。例えば、東京のサービスデスクの業務終了時刻が、ロンドンのサービスデスクの業務開始時刻と重なるように連携します。\n\n他の選択肢は以下の理由で誤りです。\n\n*   **a**：これは「仮想サービスデスク」の説明に近いです。\n*   **b**：これは「集中サービスデスク」や統合の説明です。\n*   **d**：これは単なるシフト交代時の引継ぎやエスカレーション（上位への報告・依頼）に関する説明であり、地理的な連携による24時間サポートの概念ではありません。"
  },
  {
    "qNo": 56,
    "text": "ITサービスマネジメントにおけるサービスレベル管理の説明はどれか。",
    "options": [
      {
        "id": "a",
        "text": "あらかじめ定めた間隔で、サービス目標に照らしてサービスの傾向及びパフォーマンスを監視する。"
      },
      {
        "id": "b",
        "text": "計画が発動された場合の可用性の目標,平常業務の状態に復帰するための取組みなどを含めた計画を作成し、導入し、維持する。"
      },
      {
        "id": "c",
        "text": "サービスの品質を阻害する事象に対して、合意したサービス目標及び時間枠内に回復させる。"
      },
      {
        "id": "d",
        "text": "予算に照らして、費用を監視及び報告し、財務予測をレビューし、費用を管理する。"
      }
    ],
    "correctOption": "a",
    "explanation": "ITサービスマネジメントにおける**サービスレベル管理（SLM）**は、提供するITサービスの品質（レベル）を顧客との間で合意し、その水準を維持・改善していく活動です。\n\n正解は **a** です。\n*   **a** の説明は、合意したサービス目標（SLA）を達成できているかを確認するため、サービスの傾向（トレンド）やパフォーマンス（性能）を継続的に「監視・測定」する活動を指しており、サービスレベル管理の中核をなします。\n\n他の選択肢は以下の通り、別の管理プロセスを指しています。\n*   **b** は、災害などからの復旧を扱う**ITサービス継続性管理**の説明です。\n*   **c** は、サービス提供の中断からの復旧を扱う**インシデント及び問題管理**（または障害管理）の説明です。\n*   **d** は、ITサービスの費用対効果を管理する**ITサービス財務管理**の説明です。"
  },
  {
    "qNo": 57,
    "text": "IT サービスマネジメントのプロセスの一つである構成管理を導入することによって得られるメリットはどれか。",
    "options": [
      {
        "id": "a",
        "text": "ITリソースに対する、現在の需要の把握と将来の需要の予測ができる。"
      },
      {
        "id": "b",
        "text": "緊急事態においても最低限のITサービス基盤を提供することによって、事業の継続が可能になる。"
      },
      {
        "id": "c",
        "text": "構成品目の情報を正確に把握することによって、他のプロセスの確実な実施を支援できる。"
      },
      {
        "id": "d",
        "text": "適正な費用で常に一定した品質でのITサービスが提供されるようになる。"
      }
    ],
    "correctOption": "c",
    "explanation": "**構成管理**は、ITサービスを構成するサーバーやソフトウェアなどの**構成品目（CI）**に関する情報を正確に記録・管理するプロセスです。\n\n- **正解のcについて:** 構成管理の最大のメリットは、どのITリソースがどこにあり、どのような状態にあるかを正確に把握できる点です。これにより、障害発生時の原因特定や、変更作業時の影響範囲分析など、**他のITSM（ITサービスマネジメント）プロセス**の確実な実施を強力に支援できます。\n\n- **他の選択肢について:**\n    - aは「需要管理」または「キャパシティ管理」のメリットです。\n    - bは「ITサービス継続性管理」のメリットです。\n    - dは「サービスレベル管理」のメリットです。\n\nしたがって、ITリソースの情報を正確に把握し、他の管理活動を支えるcが構成管理の導入メリットとして適切です。"
  },
  {
    "qNo": 58,
    "text": "クラウドサービスの導入検討プロセスに対するシステム監査において、クラウドサービス上に保存されている情報の消失の予防に関するチェックポイントとして,適切なものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "既存の社内情報システムとのIDの一元管理の可否が検討されているか。"
      },
      {
        "id": "b",
        "text": "クラウドサービスの障害時における最大許容停止時間が検討されているか。"
      },
      {
        "id": "c",
        "text": "クラウドサービスを提供する事業者に信頼が置け,かつ,事業やサービスが継続して提供されるかどうかが検討されているか。"
      },
      {
        "id": "d",
        "text": "クラウドサービスを提供する事業者の施設内のネットワークに、暗号化通信が採用されているかどうかが検討されているか。"
      }
    ],
    "correctOption": "c",
    "explanation": "クラウドサービス利用における**情報の消失予防**（データの安全性の確保）は、サービスの提供が突然停止しないことが大前提となります。\n\n*   **正解のc**：クラウド事業者の**信頼性**と**継続性**の検討は、サービスそのものが存続し、提供が中断されないかを評価するもので、データが消失するリスク（事業撤退によるデータアクセス不可など）を根本的に予防します。これは情報の安全性を確保する上で最も重要です。\n*   **b**は障害時の**復旧時間**（可用性）に関するチェックであり、消失予防ではありません。\n*   **a**は**認証管理**（利便性・セキュリティ）に関することです。\n*   **d**は施設内ネットワークの**盗聴防止**（機密性）に関するチェックであり、消失予防とは直接関係ありません。"
  },
  {
    "qNo": 59,
    "text": "システム監査人が予備調査で実施する監査手続はどれか。",
    "options": [
      {
        "id": "a",
        "text": "監査対象に関する手順書や実施記録、及び被監査部門から入手した監査証拠に基づいて,指摘事項をまとめる。"
      },
      {
        "id": "b",
        "text": "監査対象に対する被監査部門の管理者及び担当者のリスクの認識について、アン"
      }
    ],
    "correctOption": "b",
    "explanation": "システム監査のプロセスにおいて、**予備調査**（予備的調査）は、本調査（詳細な監査）を実施する前に、監査対象部門の全体像や潜在的なリスクを概略的に把握するために行われます。\n\n正解である**b**は、管理者や担当者へのアンケートやインタビューを通じて、彼らがシステムの運用におけるリスク（危険性）をどのように認識しているかを確認する行為です。この情報収集により、監査人はどこに問題がありそうか、どこを重点的に監査すべきか（監査計画の策定）を判断できます。\n\n一方、選択肢**a**にある「監査証拠に基づいて指摘事項をまとめる」行為は、詳細な証拠収集と評価が完了した後の、**本調査**または**報告段階**で実施される作業です。予備調査の段階では、指摘事項をまとめるほど詳細な評価はまだ行いません。したがって、bが予備調査として最も適切な手続です。"
  }
]