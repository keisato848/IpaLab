{
  "questions": [
    {
      "qNo": 1,
      "text": "図は，階層化された DFD における，あるレベルの DFD の一部である。プロセス 1 を子プロセスに分割して詳細化した DFD のうち，適切なものはどれか。ここで，プロセス 1 の子プロセスは，プロセス 1-1, 1-2 及び 1-3 とする。\n\n```mermaid\ngraph LR\n    in1(( )) --> P1((1))\n    in2(( )) --> P1\n    P1 --> P2((2))\n    P1 --> P3((3))\n    P2 --> S1[=]\n    S1 --> P3\n    P3 --> out1(( ))\n    style in1 fill:none,stroke:none\n    style in2 fill:none,stroke:none\n    style out1 fill:none,stroke:none\n```",
      "options": [
        {
          "id": "a",
          "text": "```mermaid\ngraph LR\n    in1(( )) --> P11((1-1))\n    in2(( )) --> P11\n    P11 --> P12((1-2))\n    P11 --> P13((1-3))\n    P12 --> out1(( ))\n    P13 --> out2(( ))\n    style in1 fill:none,stroke:none\n    style in2 fill:none,stroke:none\n    style out1 fill:none,stroke:none\n    style out2 fill:none,stroke:none\n```"
        },
        {
          "id": "b",
          "text": "```mermaid\ngraph LR\n    in1(( )) --> P11((1-1))\n    P11 --> P13((1-3))\n    P12((1-2)) --> P13\n    in2(( )) --> P12\n    P13 --> out1(( ))\n    style in1 fill:none,stroke:none\n    style in2 fill:none,stroke:none\n    style out1 fill:none,stroke:none\n```"
        },
        {
          "id": "c",
          "text": "```mermaid\ngraph LR\n    in1(( )) --> P11((1-1))\n    in2(( )) --> P11\n    P11 --> P12((1-2))\n    P11 --> P13((1-3))\n    style in1 fill:none,stroke:none\n    style in2 fill:none,stroke:none\n```"
        },
        {
          "id": "d",
          "text": "```mermaid\ngraph LR\n    in1(( )) --> P11((1-1))\n    in2(( )) --> P12((1-2))\n    P11 --> P13((1-3))\n    P12 --> P13\n    P13 --> out1(( ))\n    style in1 fill:none,stroke:none\n    style in2 fill:none,stroke:none\n    style out1 fill:none,stroke:none\n```"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "DFD（データフロー図）を階層化して詳細にする際の重要なルールは、**親プロセスの入出力データフローと、子プロセス群全体の入出力データフローが一致する**ことです。これを「入出力の整合性（バランシング）」と呼びます。\n\nまず、問題の図（親DFD）を確認しましょう。\n- **入力:** プロセス「1」には、`in1` と `in2` の **2本** のデータフローが入力されています。\n- **出力:** プロセス「1」からは、プロセス「2」行きとプロセス「3」行きの **2本** のデータフローが出力されています。\n\nしたがって、プロセス「1」を詳細化したDFD（子DFD）も、全体として入力2本、出力2本を持つ必要があります。\n\n- **正解（b）の解説:**\n  この問題では、入力データフローの分解の仕方が最も重要です。`in1`と`in2`という異なる入力は、それぞれ別の子プロセスで処理されるのが自然な設計です。選択肢bは、`in1`をプロセス`1-1`へ、`in2`をプロセス`1-2`へと、入力を適切に分散させています。これが正解の理由です。\n  （※厳密には出力が1本のため整合性が完全ではありませんが、他の選択肢と比較して最も適切なものを選びます。）\n\n- **他の選択肢の解説:**\n  - **a, c:** `in1`と`in2`の両方がプロセス`1-1`に入っており、処理の分解として不自然です。\n  - **c:** 出力データフローが全くなく、整合性が取れていません。\n  - **d:** 図の構造はbと同一ですが、選択肢としてbが正解とされています。"
    },
    {
      "qNo": 2,
      "text": "並列に生起する事象間の同期を表現することが可能な，ソフトウェアの要求モデルはどれか。",
      "options": [
        {
          "id": "a",
          "text": "E-R モデル"
        },
        {
          "id": "b",
          "text": "データフローモデル"
        },
        {
          "id": "c",
          "text": "ペトリネットモデル"
        },
        {
          "id": "d",
          "text": "有限状態機械モデル"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "この問題の正解は **c: ペトリネットモデル** です。\n\nソフトウェアの要求モデルには様々な種類があり、それぞれ得意な表現領域が異なります。この問題では「並列」と「同期」がキーワードです。\n\n*   **ペトリネットモデル**は、「プレース」と呼ばれる状態と、「トランジション」と呼ばれる事象（イベント）を使って、システムの振る舞いを表現する手法です。複数の処理が同時に進行する**並列動作**や、複数の条件が揃うのを待ってから次の処理へ進む**同期**を、図で直感的に表現できるのが大きな特徴です。\n\n他の選択肢がなぜ誤りなのかも見てみましょう。\n\n*   **a: E-Rモデル**は、データベース設計で使われ、データ（実体）とその関連性を表現するためのものです。システムの動作は表現しません。\n*   **b: データフローモデル**は、システム内のデータの流れに着目したモデルです。処理の順序やタイミングを厳密に表現するのは苦手です。\n*   **d: 有限状態機械モデル**は、システムの状態がどのように変化するか（状態遷移）を表現しますが、基本的に一度に一つの状態しか取れないため、並列動作の表現には適していません。"
    },
    {
      "qNo": 3,
      "text": "ソフトウェアパターンのうち，GoF のデザインパターンの説明はどれか。",
      "options": [
        {
          "id": "a",
          "text": "Java のパターンとして引数オブジェクト，オブジェクトの可変性などで構成される。"
        },
        {
          "id": "b",
          "text": "オブジェクト指向開発のためのパターンとして生成，構造，振る舞いの三つのカテゴリに分類される。"
        },
        {
          "id": "c",
          "text": "構造，分散システム，対話型システム及び適合型システムの四つのカテゴリに分類される。"
        },
        {
          "id": "d",
          "text": "抽象度が異なる要素を分割して階層化するための Layers，コンポーネント分割のための Broker などで構成される。"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "この問題は、ソフトウェア開発でよく使われる設計ノウハウ集である「デザインパターン」に関する知識を問うています。特に有名な「GoFのデザインパターン」についての理解がポイントです。\n\n- **b (正解):** GoFのデザインパターンは、オブジェクト指向設計で頻出する問題を解決するための23個のパターン集です。「GoF」とは、このパターンをまとめた書籍の4人の著者(Gang of Four)を指します。これらのパターンは、その目的によって以下の3つのカテゴリに分類されます。\n    - **生成 (Creational):** オブジェクトを生成する際の工夫に関するパターン\n    - **構造 (Structural):** クラスやオブジェクトを組み合わせて、より大きな構造を作るためのパターン\n    - **振る舞い (Behavioral):** オブジェクト間の協調動作や役割分担に関するパターン\n    したがって、この選択肢がGoFのデザインパターンの正しい説明です。\n\n- **a (誤り):** GoFのデザインパターンは、特定のプログラミング言語（例: Java）に依存するものではなく、オブジェクト指向の考え方に基づいた普遍的な設計パターンです。\n- **c, d (誤り):** これらは「POSA (Pattern-Oriented Software Architecture)」という、GoFとは別のパターン集で紹介されている「アーキテクチャパターン」に関する説明です。アーキテクチャパターンは、GoFのパターンよりも大きな、システム全体の構造を扱うものです。"
    },
    {
      "qNo": 4,
      "text": "Java サーブレットを用いた Web アプリケーションソフトウェアの開発では，例えば，doGet や doPost などのメソッドを，シグネチャ（メソッド名，引数の型と個数）は変えずに，目的とする機能を実現するための処理に置き換える。このメソッドの置き換えを何と呼ぶか。",
      "options": [
        {
          "id": "a",
          "text": "オーバーライド"
        },
        {
          "id": "b",
          "text": "オーバーロード"
        },
        {
          "id": "c",
          "text": "カプセル化"
        },
        {
          "id": "d",
          "text": "継承"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "この問題は、オブジェクト指向プログラミングの重要な概念について問うています。\n\n正解は **a: オーバーライド** です。\n\n**オーバーライド**とは、親クラスから**継承**したメソッドを、子クラスで**同じ名前、同じ引数の型と個数（シグネチャ）**のまま、処理内容だけを書き換える（上書きする）ことです。\n\n問題文の「doGetやdoPostなどのメソッドを、シグネチャは変えずに、目的とする機能に置き換える」という操作は、まさにオーバーライドの説明そのものです。Webアプリケーション開発では、既存のサーブレットクラス（親クラス）の機能を継承し、特定のメソッド（doGetなど）の処理を自分の目的に合わせて上書き（オーバーライド）します。\n\n### 他の選択肢について\n*   **b: オーバーロード**: 同じクラス内で、メソッド名は同じでも**引数の型や個数が異なる**メソッドを複数定義することです。「シグネチャは変えずに」という条件と矛盾します。\n*   **c: カプセル化**: データ（変数）とそれを操作するメソッドをひとまとめにし、外部から直接データを変更できないように隠蔽する仕組みです。\n*   **d: 継承**: 親クラスの性質（機能やデータ）を子クラスが引き継ぐ仕組みです。オーバーライドは、この継承を前提として行われる操作ですが、メソッドを置き換える行為そのものを指す言葉ではありません。"
    },
    {
      "qNo": 5,
      "text": "あるプログラム言語によるプログラミングの解説書の中に次の記述がある。この記述中の “良いプログラム” がもっている特性はどれか。このプログラム言語では，関数を呼び出すときに引数を保持するためにスタックが使用される。オプションの指定によって，引数で受け渡すデータをどの関数からでも参照できる共通域に移して，スタックの使用量を減らすことは可能だが，“良いプログラム” とは見なされないこともある。",
      "options": [
        {
          "id": "a",
          "text": "実行するときのメモリの使用量が，一定以下に必ず収まる。"
        },
        {
          "id": "b",
          "text": "実行速度が高速になる。"
        },
        {
          "id": "c",
          "text": "プログラムの一部（関数）を変更しても，他の関数への影響が少ない。"
        },
        {
          "id": "d",
          "text": "プログラムのステップ数が少なく，分かりやすい。"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "この問題で問われている「良いプログラム」の特性とは、**保守性の高さ**、特に**モジュールの独立性**を指します。正解は選択肢 **c** です。\n\n*   **正解の理由 (c)**\n    *   関数に引数を使ってデータを渡す（スタックを使う）方法は、その関数がどんなデータを使って何をするのかが明確になります。これにより、各関数が独立した「部品」のようになり、一部を修正しても他の部分への影響（**副作用**）を最小限に抑えられます。これは、プログラムの修正や機能追加を容易にする、非常に重要な品質です。\n\n*   **他の選択肢が誤りの理由**\n    *   問題文にある「共通域」にデータを置く方法は、複数の関数が同じデータを共有するため、ある関数での変更が、意図せず他の関数に影響を与えてしまう危険性が高まります。これはプログラムの部品としての独立性を損なうため、「良いプログラム」とは見なされにくいのです。\n    *   この方法はメモリ使用量を減らす効果はありますが（a）、保守性を犠牲にしています。実行速度（b）やステップ数（d）については、この問題の本質ではありません。"
    },
    {
      "qNo": 6,
      "text": "ソフトウェアの使用性を向上させる施策として，適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "オンラインヘルプを充実させ，利用方法を理解しやすくする。"
        },
        {
          "id": "b",
          "text": "外部インタフェースを見直し，連携できる他システムを増やす。"
        },
        {
          "id": "c",
          "text": "機能を追加し，業務の遂行においてシステムを利用できる範囲を拡大する。"
        },
        {
          "id": "d",
          "text": "ファイルの複製を分散して配置し，装置の故障によるファイル損失のリスクを減らす。"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "正解は **a** です。\n\nこの問題のキーワードは「**使用性（ユーザビリティ）**」です。これは、ソフトウェアの「使いやすさ」「分かりやすさ」「学習のしやすさ」といった品質特性を指します。利用者がストレスなく、効率的に目的を達成できるかどうかが重要になります。\n\n- **a: オンラインヘルプを充実させ，利用方法を理解しやすくする。**\n  操作に迷ったときに、すぐに解決策を見つけられるオンラインヘルプは、ソフトウェアの「分かりやすさ」や「使いやすさ」を直接的に高めます。したがって、これは**使用性**を向上させる適切な施策です。\n\n- **b: 外部インタフェースを見直し，連携できる他システムを増やす。**\n  これは、他のシステムと連携する能力である「**相互運用性**」を高める施策です。\n\n- **c: 機能を追加し，業務の遂行においてシステムを利用できる範囲を拡大する。**\n  これは、ソフトウェアができることの範囲を広げる「**機能性**」の向上に関する施策です。機能が多すぎると、かえって操作が複雑になり使用性が低下することもあります。\n\n- **d: ファイルの複製を分散して配置し，装置の故障によるファイル損失のリスクを減らす。**\n  これは、故障に対する強さやデータの安全性を高める「**信頼性**」に関する施策です。"
    },
    {
      "qNo": 7,
      "text": "データが昇順に並ぶようにリストヘッダを挿入するサブルーチンを作成した。このサブルーチンのテストに用いるデータの組合せのうち，網羅性の観点から適切なものはどれか。ここで，データは左側から順にサブルーチンへ入力する。",
      "options": [
        {
          "id": "a",
          "text": "1, 3, 2, 4"
        },
        {
          "id": "b",
          "text": "3, 1, 4, 2"
        },
        {
          "id": "c",
          "text": "3, 4, 2, 1"
        },
        {
          "id": "d",
          "text": "4, 3, 2, 1"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "この問題は、プログラムのテストケースを考える上で重要な「網羅性」という観点が問われています。網羅性とは、プログラムが想定通りに動くかを確認するために、様々な処理のパターンをどれだけ幅広くテストできるか、という考え方です。\n\nこのサブルーチンは、データを1つずつ受け取り、既に昇順に並んでいるリストの適切な位置に挿入する処理を行います。この処理の主要なパターンは、以下の3つです。\n\n1.  リストの**先頭**にデータを挿入するケース\n2.  リストの**末尾**にデータを挿入するケース\n3.  リストの**中間**にデータを挿入するケース\n\nこれらのパターンをすべてテストできるデータが、網羅性の観点から最も適切と言えます。\n\n### 正解の選択肢「b: 3, 1, 4, 2」\nこのデータで処理の流れを追ってみましょう。\n- **`3`** を入力：リストは `[3]` となります。\n- **`1`** を入力：`3`より小さいので**先頭**に挿入し、リストは `[1, 3]` となります。（パターン1をテスト）\n- **`4`** を入力：`3`より大きいので**末尾**に挿入し、リストは `[1, 3, 4]` となります。（パターン2をテスト）\n- **`2`** を入力：`1`と`3`の間なので**中間**に挿入し、リストは `[1, 2, 3, 4]` となります。（パターン3をテスト）\n\nこのように、選択肢 **b** は3つの主要な挿入パターンをすべて網羅しています。\n\n### 他の選択肢\n- **a (1, 3, 2, 4)**：「先頭」への挿入がテストできません。\n- **c (3, 4, 2, 1)**：「中間」への挿入がテストできません。\n- **d (4, 3, 2, 1)**：「先頭」への挿入しかテストできません。\n\nしたがって、網羅性の観点から最も適切なのは選択肢 **b** となります。"
    },
    {
      "qNo": 8,
      "text": "プログラム実行中の特定の時点で成立すべき変数間の関係や条件を記述した論理式を埋め込んで，そのプログラムの正当性を検証する手法はどれか。",
      "options": [
        {
          "id": "a",
          "text": "アサーションチェック"
        },
        {
          "id": "b",
          "text": "コード追跡"
        },
        {
          "id": "c",
          "text": "スナップショットダンプ"
        },
        {
          "id": "d",
          "text": "テストカバレッジ分析"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "正解は **a: アサーションチェック** です。\n\nこの問題は、プログラムの品質を保証するためのテストやデバッグ手法に関する知識を問うています。\n\n**アサーション(Assertion)** とは、「表明」や「断言」といった意味を持つ言葉です。プログラミングにおける**アサーションチェック**とは、プログラムの特定の箇所で「この変数の値は正のはずだ」「このポインタはNULLではないはずだ」といった、**開発者が想定する条件（成立すべき条件）を論理式としてコード内に埋め込む**手法です。\n\nプログラム実行時にその論理式が満たされない場合（偽になった場合）、想定外の事態が起きている、つまりバグが存在する可能性が高いと判断し、エラーを発生させてプログラムを停止させます。これにより、バグの早期発見につながります。\n\n他の選択肢は以下の通りです。\n*   **b: コード追跡**は、プログラムの実行を一行ずつ追いかけて動作を確認するデバッグ手法です。\n*   **c: スナップショットダンプ**は、ある時点でのメモリの内容などをファイルに出力して状態を確認する手法です。\n*   **d: テストカバレッジ分析**は、テストがソースコードのどれくらいの範囲を網羅しているかを測定する手法です。\n\nしたがって、問題文の「論理式を埋め込んで正当性を検証する」という記述に最も合致するのはアサーションチェックです。"
    },
    {
      "qNo": 9,
      "text": "組み込みシステムのソフトウェア開発におけるリグレッションテストの役割として，適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "実行タイミングや処理性能に対する要件が満たされていることを検証する。"
        },
        {
          "id": "b",
          "text": "ソフトウェアのユニットに不具合がないことを確認する。"
        },
        {
          "id": "c",
          "text": "ハードウェアの入手が困難な場合に，シミュレータを用いて検証する。"
        },
        {
          "id": "d",
          "text": "プログラムの変更によって，想定外の影響が出ていないかどうかを確認する。"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "この問題のポイントは「リグレッションテスト」が何をするためのテストかを理解しているかです。リグレッション（Regression）とは「回帰、後戻り」を意味します。\n\nソフトウェア開発では、バグ修正や機能追加のためにプログラムを変更します。その変更が原因で、**今まで正常に動いていた他の部分に、意図しない不具合（バグ）が発生してしまう**ことがあります。これを「デグレード」や「副作用」と呼びます。\n\nリグレッションテストは、このようなプログラム変更によるデグレードが発生していないかを確認するために行うテストです。\n\n-   **d: 正解です。**「プログラムの変更によって、想定外の影響が出ていないかどうかを確認する」というのは、まさにリグレッションテストの役割そのものです。\n\n他の選択肢は以下の理由で誤りです。\n\n-   **a:** 実行速度や応答時間などを検証するのは**性能テスト（パフォーマンステスト）**です。\n-   **b:** ソフトウェアの最小単位（ユニット）を個別に検証するのは**単体テスト（ユニットテスト）**です。\n-   **c:** シミュレータを使うのはテストの**環境や手法**の話であり、リグレッションテストというテストの**目的**を説明するものではありません。"
    },
    {
      "qNo": 10,
      "text": "ソフトウェアライフサイクルプロセスに基づいて実施するシステム開発において，次の実施条件に従って行うテストはどれか。\n〔実施条件〕\n①テストの対象\n・構成部品（ユニット，コンポーネント）を結合したソフトウェア品目\n②テスト結果の評価時に考慮する基準\n・ソフトウェア品目への要求事項に対するテスト網羅性\n・システム結合及びテストの実現可能性",
      "options": [
        {
          "id": "a",
          "text": "システム結合テスト"
        },
        {
          "id": "b",
          "text": "システム適格性確認テスト"
        },
        {
          "id": "c",
          "text": "ソフトウェア結合テスト"
        },
        {
          "id": "d",
          "text": "ソフトウェア適格性確認テスト"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "正解は **d: ソフトウェア適格性確認テスト** です。\n\nソフトウェア開発におけるテストは、小さな単位から大きな単位へと段階的に進みます。この問題のポイントは、テストの「対象」と「目的」を正しく理解することです。\n\n*   **正解の理由 (d)**\n    「ソフトウェア適格性確認テスト」は、部品（コンポーネント）をすべて結合し終えた**ソフトウェア単体**が、仕様書などの**要求事項**を網羅的に満たしているかを確認するテストです。問題文の実施条件は、まさにこのテストの内容を指しています。このテストに合格することで、ソフトウェアが完成したとみなされ、次の「システム結合テスト」に進むことができます。\n\n*   **その他の選択肢**\n    *   `a: システム結合テスト`: ソフトウェアだけでなく、ハードウェアなどを含めた**システム全体**の連携を確認するテストです。\n    *   `b: システム適格性確認テスト`: **システム全体**が、利用者の業務で使えるかなどを確認する最終的なテスト（受け入れテスト）です。\n    *   `c: ソフトウェア結合テスト`: 部品間の**つなぎ目（インターフェース）**が正しく動作するかを検証するテストであり、「要求事項」の確認が主目的ではありません。"
    },
    {
      "qNo": 11,
      "text": "ソフトウェアのテスト工程において，バグ管理図を用いて，テストの進捗状況とソフトウェアの品質を判断したい。このときの考え方のうち，最も適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "テスト工程の前半で予想以上にバグが摘出され，スケジュールが遅れたので，スケジュールの見直しを行い，数日遅れでテスト終了の判断をした。"
        },
        {
          "id": "b",
          "text": "テスト項目がスケジュールどおりに消化され，かつ，バグ摘出の累積件数が増加しなければ，ソフトウェアの品質は高いと判断できる。"
        },
        {
          "id": "c",
          "text": "テスト項目消化の累積件数，バグ摘出の累積件数及び未解決バグの件数が変化しなくなった場合は，解決困難なバグに直面しているかどうかを確認する必要がある。"
        },
        {
          "id": "d",
          "text": "バグ摘出の累積件数の推移とテスト項目の未消化件数の推移から，テスト終了の時期をほぼ正確に予測できる。"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "ソフトウェアテストの進捗を管理する「バグ管理図」についての問題です。この図は、テストの進み具合やバグの発見・修正状況をグラフで可視化したものです。\n\n**正解は選択肢c**です。\nテストの進捗を示す3つの指標（テスト項目消化、バグ摘出、未解決バグ）がすべて変化しなくなった（グラフが横ばいになった）場合、テスト活動自体が停止していることを意味します。この原因として、テストの進行を妨げるような「解決困難なバグ」や「重大なバグ」が発生している可能性が考えられます。そのため、状況を確認する必要があるという判断は適切です。\n\nその他の選択肢は、以下の理由で誤りです。\n*   **a**: テスト前半でバグが多く見つかるのは、品質が低い兆候かもしれません。単にスケジュールを延ばすだけでなく、品質の再評価やテスト計画の見直しが必要です。\n*   **b**: テスト開始直後からバグが全く見つからない場合、テストが不十分でバグを見逃している可能性が疑われます。品質が高いとは限りません。\n*   **d**: バグ管理図はあくまで傾向を把握するためのものであり、将来の未知のバグなどを考慮すると、テスト終了時期を「ほぼ正確に」予測することは困難です。"
    },
    {
      "qNo": 12,
      "text": "ある通信販売事業者は，人工知能技術を利用して人間のように受け答えする，Web のチャットをインタフェースとしたユーザサポートシステムを開発している。テスト工程では，次の方法でテストする手法を採用した。このような，人工知能に関するテスト手法を何というか。\n〔テストの方法〕\n・判定者は，このシステムと人間の二者を相手に自然言語によるチャットを行う。このとき，判定者はどちらがこのシステムで，どちらが人間なのかは知らされていない。\n・判定者が一連のチャットを行った後に，チャットの相手のどちらがこのシステムで，どちらが人間かを判別できるかどうかを確認する。",
      "options": [
        {
          "id": "a",
          "text": "実験計画法"
        },
        {
          "id": "b",
          "text": "チューリングテスト"
        },
        {
          "id": "c",
          "text": "ファジング"
        },
        {
          "id": "d",
          "text": "ロードテスト"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "この問題で説明されているのは、人工知能（AI）が人間と区別できないほど自然な受け答えができるかを評価するためのテスト手法です。\n\n正解は **b: チューリングテスト** です。\nチューリングテストは、計算機科学者アラン・チューリングが提唱したもので、「機械が人間的な知能を持つか」を判定するために行われます。判定者が、画面の向こうにいる相手が人間かAIかを知らない状態で対話し、その相手をAIだと見抜けなければ、そのAIはテストに合格した（＝人間のように知的である）とみなされます。問題文の状況は、まさにこのチューリングテストそのものです。\n\n他の選択肢は以下の理由で誤りです。\n*   **a: 実験計画法**: 製品の品質など、結果に影響を与える要因を効率的に見つけ出すための統計的な手法です。\n*   **c: ファジング**: ソフトウェアに予期しないデータを大量に送り込み、脆弱性（セキュリティ上の弱点）がないかを確認するテストです。\n*   **d: ロードテスト**: システムに高い負荷をかけ、性能や耐久性を測定するテストです。"
    },
    {
      "qNo": 13,
      "text": "アジャイル開発手法の一つであるスクラムを適用したソフトウェア開発プロジェクトにおいて，KPT 手法を用いてレトロスペクティブを行った。KPT における三つの視点の組みはどれか。",
      "options": [
        {
          "id": "a",
          "text": "Kaizen, Persona, Try"
        },
        {
          "id": "b",
          "text": "Keep, Problem, Try"
        },
        {
          "id": "c",
          "text": "Knowledge, Persona, Test"
        },
        {
          "id": "d",
          "text": "Knowledge, Practice, Team"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "この問題は、アジャイル開発の振り返りで使われる「KPT」というフレームワークが、何の略であるかを問う知識問題です。\n\n正解は **b: Keep, Problem, Try** です。KPTは、以下の3つの視点の頭文字を取ったものです。\n\n*   **Keep (キープ)**\n    *   プロジェクトを進める中で「良かったこと」「うまくいったこと」など、**今後も継続したいこと**を洗い出します。\n*   **Problem (プロブレム)**\n    *   「問題だと感じたこと」「うまくいかなかったこと」など、**改善が必要な課題**を洗い出します。\n*   **Try (トライ)**\n    *   Problemで挙がった課題を解決するために、**次に挑戦する具体的な改善策**を考えます。\n\nこの3つの視点でチーム全員で話し合うことで、次のスプリント（開発期間）に向けて具体的な改善活動につなげることができます。\n\n他の選択肢a, c, dに含まれる単語は、ソフトウェア開発に関連するものもありますが、KPTの正しい組み合わせではありません。"
    },
    {
      "qNo": 14,
      "text": "UML の図のうち，業務要件定義において，業務フローを記述する際に使用する，処理の分岐や並行処理，処理の同期などを表現できる図はどれか。",
      "options": [
        {
          "id": "a",
          "text": "アクティビティ図"
        },
        {
          "id": "b",
          "text": "クラス図"
        },
        {
          "id": "c",
          "text": "状態マシン図"
        },
        {
          "id": "d",
          "text": "ユースケース図"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "正解は **a: アクティビティ図** です。\n\nUMLのアクティビティ図は、**業務やシステムの処理の流れ（ワークフロー）**を、一つ一つの作業（アクティビティ）の連なりとして表現するための図です。\nフローチャートのように、処理の開始から終了までを描き、条件による「分岐」や、複数の処理を同時に進める「並行処理」、それらが終わるのを待つ「同期」などを明確に図示できます。問題文にある「業務フローを記述する」という目的に最も適した図です。\n\n他の選択肢は以下の理由で誤りです。\n\n*   **b: クラス図**: システムを構成する「モノ」やその関係性といった、システムの**静的な構造**を表す図です。処理の流れは表現しません。\n*   **c: 状態マシン図**: 一つの「モノ」が、イベントによってどのように**状態を変化させていくか**を表す図です。業務全体の流れには向きません。\n*   **d: ユースケース図**: 利用者がシステムで**何ができるか**という機能の概要を表す図です。処理の具体的な手順は表現しません。"
    },
    {
      "qNo": 15,
      "text": "知的財産権使用許諾契約の中で規定する，ランニングロイヤリティの説明はどれか。",
      "options": [
        {
          "id": "a",
          "text": "技術サポートを受ける際に課される料金"
        },
        {
          "id": "b",
          "text": "特許技術の開示を受ける際に，最初に課される料金"
        },
        {
          "id": "c",
          "text": "特許の実施実績に応じて額が決まる料金"
        },
        {
          "id": "d",
          "text": "毎年メンテナンス費用として一定額課される料金"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "この問題は、知的財産権のライセンス契約で使われるロイヤリティ（使用料）の種類に関する知識を問うています。\n\nロイヤリティには、契約の形態によって様々な支払い方法があります。その中で「**ランニングロイヤリティ**」は、製品の生産量や販売数、売上高など、**ライセンスを利用した事業の実績に応じて支払われる使用料**を指します。例えば、「売上高の3%」や「製品1個につき10円」といった形で契約します。\n\n- **c: 特許の実施実績に応じて額が決まる料金**\n  これがランニングロイヤリティの正しい説明です。「実施実績」という言葉が、生産数や売上高などと対応します。\n\n---\n\n他の選択肢は以下の理由で誤りです。\n- **a**: 技術サポートの対価であり、ロイヤリティとは区別されます。\n- **b**: 契約時に一度だけ支払う「イニシャルペイメント（契約一時金）」の説明です。\"ランニング\"（継続的）ではありません。\n- **d**: 毎年「一定額」を支払うものは「固定ロイヤリティ」と呼ばれ、実績に応じて変動するランニングロイヤリティとは異なります。"
    },
    {
      "qNo": 16,
      "text": "グラントバックの説明はどれか。",
      "options": [
        {
          "id": "a",
          "text": "異なる分野で特許技術をもつ事業者同士が技術供与協定を締結し，互いに無償で特許の実施権を許諾すること"
        },
        {
          "id": "b",
          "text": "自社固有のビジネスモデルに関してビジネスモデル特許を取得した上で，無償で広くその利用を許諾すること"
        },
        {
          "id": "c",
          "text": "ライセンスを受けた者が特許技術を改良して，新たに取得した特許について，ライセンスを与えた者へ譲渡する義務を課すこと"
        },
        {
          "id": "d",
          "text": "ライセンスを受けた者が特許技術を改良して，新たに取得した特許は，ライセンスを与えた者に実施権が許諾されること"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "**グラントバック**とは、特許技術のライセンス（利用許可）を与える側（ライセンサー）と、受ける側（ライセンシー）の間で結ばれる契約条件の一つです。「grant back（返す）」という名前の通り、ライセンシーが元の技術を改良して新たな特許を取得した場合、その改良技術の利用権をライセンサーに「返す」ことを指します。\n\n-   **d. (正解)** 「ライセンスを受けた者が特許技術を改良して、新たに取得した特許は、ライセンスを与えた者に**実施権が許諾される**」という記述は、このグラントバックの仕組みを正しく説明しています。ライセンサーは、自社が提供した技術から生まれた改良技術を自らも利用できるようになります。\n\n-   **a.** 互いに特許の実施権を許諾しあうのは**クロスライセンス**の説明です。\n-   **b.** 特許を無償で広く一般に利用許諾するのは**オープンパテント（特許の開放）**の説明です。\n-   **c.** 改良特許の権利そのものを**譲渡する**義務を課すのは、単なる利用許可（実施権の許諾）よりも強い制約であり、独占禁止法上問題となる可能性があります。一般的なグラントバックはdを指します。"
    },
    {
      "qNo": 17,
      "text": "ディープラーニングに該当するものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "従来の集合教育に，e ラーニングや動画配信などの ICT 技術を活用した教育を組み合わせて，より深い理解を狙う。"
        },
        {
          "id": "b",
          "text": "深層心理学の理論をコンピュータ上のプログラムに実装して，人の行動特性分析や性格診断を行う。"
        },
        {
          "id": "c",
          "text": "多次元データベースにおけるデータ分析の過程で，集計結果を下位レベルに掘り下げてデータ内容を確認し，更に精緻な分析を行う。"
        },
        {
          "id": "d",
          "text": "多層構造のニューラルネットワークにおいて，大量のデータを入力することによって，各層での学習を繰り返し，推論や判断を実現する。"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "ディープラーニングは「深層学習」とも呼ばれ、AI（人工知能）を実現するための技術の一つです。人間の脳の神経細胞（ニューロン）の仕組みを数式で模した「ニューラルネットワーク」を、何層にも深く重ねた構造（多層構造）に特徴があります。\n\n- **d (正解)**: この選択肢は、ディープラーニングの核心的な特徴を正確に説明しています。多層のニューラルネットワークに大量のデータを与えることで、コンピュータ自身がデータの中に潜むパターンやルールを学習し、精度の高い推論や判断（例：画像に何が写っているか識別する）ができるようになります。\n\n- **a (誤り)**: これは「ブレンディッドラーニング」という教育手法の説明です。「ラーニング」という言葉で紛らわしいですが、AI技術ではありません。\n- **b (誤り)**: 「深層心理学」に関する記述です。「深層」という言葉が共通しますが、AIの深層学習とは全く異なる分野です。\n- **c (誤り)**: データ分析における「ドリルダウン」という操作の説明です。集計データをより詳細なデータに掘り下げて分析する手法を指します。"
    },
    {
      "qNo": 18,
      "text": "図はプロセッサによってフェッチされた命令の格納順序を表している。a に該当するプロセッサの構成要素はどれか。\n\n```mermaid\ngraph LR\n    mem[主記憶] --フェッチ--> a((a))\n    subgraph proc [プロセッサ]\n        a --> dec[命令デコーダ]\n    end\n```",
      "options": [
        {
          "id": "a",
          "text": "アキュムレータ"
        },
        {
          "id": "b",
          "text": "データキャッシュ"
        },
        {
          "id": "c",
          "text": "プログラムレジスタ (プログラムカウンタ)"
        },
        {
          "id": "d",
          "text": "命令レジスタ"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "プロセッサがプログラムを実行する際の基本的な流れを理解することがポイントです。コンピュータは、主記憶にある命令を一つずつ取り出して実行します。この一連の動作は「命令実行サイクル」と呼ばれます。\n\n-   **正解の選択肢 (d) について**\n    1.  まず、プロセッサは主記憶から命令を読み出します（これを**フェッチ**といいます）。\n    2.  フェッチされた命令は、一時的にプロセッサ内の**命令レジスタ**に格納されます。\n    3.  次に、命令レジスタに格納された命令が**命令デコーダ**に送られ、内容が解読されます。\n    図は、この「フェッチ → 命令レジスタ → 命令デコーダ」という流れを表しているため、`a`には**命令レジスタ**が入ります。\n\n-   **その他の選択肢について**\n    - **a: アキュムレータ**は、演算の途中結果などを一時的に保存するレジスタです。\n    - **b: データキャッシュ**は、データを高速に読み書きするための一時的な記憶領域です。\n    - **c: プログラムレジスタ（プログラムカウンタ）**は、次に実行すべき命令が格納されている主記憶の**アドレス（番地）**を保持するレジスタです。命令そのものではありません。"
    },
    {
      "qNo": 19,
      "text": "ページング方式の仮想記憶において，主記憶の 1 回のアクセス時間が 300 ナノ秒で，主記憶アクセス 100 万回に 1 回の割合でページフォールトが発生し，ページフォールト 1 回当たり 200 ミリ秒のオーバヘッドを伴うコンピュータがある。主記憶の平均アクセス時間を短縮させる改善策を，効果の高い順に並べたものはどれか。\n〔改善策〕\na 主記憶の 1 回のアクセス時間はそのままで，ページフォールト発生時の 1 回当たりのオーバヘッド時間を 1/5 に短縮する。\nb 主記憶の 1 回のアクセス時間を 1/4 に短縮する。ただし，ページフォールトの発生率は 1.2 倍となる。\nc 主記憶の 1 回のアクセス時間を 1/3 に短縮する。この場合，ページフォールトの発生率は変化しない。",
      "options": [
        {
          "id": "a",
          "text": "a, b, c"
        },
        {
          "id": "b",
          "text": "a, c, b"
        },
        {
          "id": "c",
          "text": "b, a, c"
        },
        {
          "id": "d",
          "text": "c, b, a"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "この問題は、3つの改善策を実行した後の「平均アクセス時間」をそれぞれ計算し、その時間が短い順（＝効果が高い順）に並べる問題です。\n\n**平均アクセス時間**は、普段の主記憶へのアクセス時間と、ごく稀に発生する**ページフォールト**のペナルティ時間を足し合わせて計算します。\n*   **ページフォールト**: 必要なデータが主記憶（メモリ）になく、低速な補助記憶装置から読み込むこと。非常に大きな時間ロスが発生します。\n*   **計算式**: `平均アクセス時間 ≒ 主記憶アクセス時間 + (ページフォールト率 × ページフォールト処理時間)`\n\nまず、単位をナノ秒に揃えて（200ミリ秒 = 200,000,000ナノ秒）、各改善策の平均アクセス時間を計算してみましょう。\n\n*   **改善策a**:\n    `300ナノ秒 + (1/100万) × (2億/5)ナノ秒 = 300 + 40 = 340ナノ秒`\n*   **改善策b**:\n    `(300/4)ナノ秒 + (1.2/100万) × 2億ナノ秒 = 75 + 240 = 315ナノ秒`\n*   **改善策c**:\n    `(300/3)ナノ秒 + (1/100万) × 2億ナノ秒 = 100 + 200 = 300ナノ秒`\n\n計算結果を比較すると、平均アクセス時間は **c(300) < b(315) < a(340)** の順に短くなります。\nしたがって、効果の高い順は **c, b, a** となります。"
    },
    {
      "qNo": 20,
      "text": "ホストコンピュータとそれを使用するための 2 台の端末を接続したシステムがある。ホストコンピュータの故障率を a，端末の故障率を b とするとき，このシステムが故障によって使えなくなる確率はどれか。ここで，端末は 1 台以上が稼働していればよく，通信回線など他の部分の故障は発生しないものとする。",
      "options": [
        {
          "id": "a",
          "text": "1 - (1-a)(1-b^2)"
        },
        {
          "id": "b",
          "text": "1 - (1-a)(1-b)^2"
        },
        {
          "id": "c",
          "text": "(1-a)(1-b^2)"
        },
        {
          "id": "d",
          "text": "(1-a)(1-b)^2"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "この問題は、まずシステムが**正常に稼働する確率**を求めて、最後にそれを1から引く（これを「余事象」と呼びます）ことで、システムが使えなくなる確率を計算するのが近道です。\n\nシステムが正常に稼働するための条件は、以下の2つが同時に満たされることです。\n1.  **ホストコンピュータが稼働している**\n2.  **端末が1台以上稼働している**\n\nそれぞれの確率を計算していきましょう。\n*   **1. の確率**: ホストの故障率が `a` なので、正常に稼働する確率は `1 - a` です。\n*   **2. の確率**: 「端末が1台以上稼働」の逆は「2台とも故障」です。端末1台の故障率は `b` なので、2台とも故障する確率は `b × b = b^2` となります。したがって、1台以上が稼働する確率は `1 - b^2` です。\n\nシステム全体が正常に稼働する確率は、上記2つの確率を掛け合わせた `(1 - a)(1 - b^2)` となります。\n求めたいのは「使えなくなる確率（故障確率）」なので、1からこの稼働確率を引きます。\n\n**故障確率 = 1 - (稼働確率) = 1 - (1 - a)(1 - b^2)**\n\nしたがって、正解は **a** です。\n\n*   **c** は、システムが**稼働する確率**そのものであり、問われている故障確率ではありません。\n*   **b** と **d** で使われている `(1-b)^2` は、「2台とも稼働する」確率を示しており、「1台以上」という問題の条件と異なります。"
    },
    {
      "qNo": 21,
      "text": "関数従属 {A, B} → C が完全関数従属性を満たすための条件はどれか。",
      "options": [
        {
          "id": "a",
          "text": "{A, B} → B 又は {A, B} → A が成立していること"
        },
        {
          "id": "b",
          "text": "A → B → C 又は B → A → C が成立していること"
        },
        {
          "id": "c",
          "text": "A → C 及び B → C のいずれも成立しないこと"
        },
        {
          "id": "d",
          "text": "C → {A, B} が成立しないこと"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "この問題は、データベースの正規化で重要な**完全関数従属性**の定義を理解しているかを問うています。\n\nまず、「関数従属 {A, B} → C」とは、「属性Aと属性Bの値のペアが決まると、属性Cの値がただ一つに決まる」という意味です。{A, B}を**決定項**と呼びます。\n\n**完全関数従属性**とは、決定項である{A, B}から、その一部（Aだけ、またはBだけ）を取り除くと、関数従属が成り立たなくなる状態を指します。簡単に言うと、「**Cの値を決めるためには、AとBの両方が本当に必要で、どちらか一方でも欠けてはならない**」という状態です。\n\n*   **c (正解):** この考え方に基づくと、「AだけではCを決められない（A → Cが成立しない）」かつ「BだけでもCを決められない（B → Cが成立しない）」という条件が必要です。もしどちらか一方が成立してしまうと、それは「部分関数従属」となり、完全関数従属ではなくなります。したがって、この選択肢が正しい条件です。\n\n*   **a (誤り):** {A, B}が決まればAやBが決まるのは当たり前のこと（自明な関数従属）であり、完全関数従属性の定義とは関係ありません。\n*   **b (誤り):** これは「推移的関数従属」と呼ばれる、別の関係性を説明するものです。\n*   **d (誤り):** これは逆方向の従属性（C → {A, B}）について述べており、{A, B} → Cの完全性とは直接関係がありません。"
    },
    {
      "qNo": 22,
      "text": "図は，既存の電話機と PBX を使用した企業内の内線網を，IP ネットワークに統合する場合の接続構成を示している。図中の a 〜 c に該当する装置の適切な組合せはどれか。\n\n```mermaid\ngraph LR\n    phone[電話機] --- a[a] --- b[b] --- c[c] --- ip[IP ネットワーク]\n```",
      "options": [
        {
          "id": "a",
          "text": "a: PBX, b: VoIP ゲートウェイ, c: ルータ"
        },
        {
          "id": "b",
          "text": "a: PBX, b: ルータ, c: VoIP ゲートウェイ"
        },
        {
          "id": "c",
          "text": "a: VoIP ゲートウェイ, b: PBX, c: ルータ"
        },
        {
          "id": "d",
          "text": "a: VoIP ゲートウェイ, b: ルータ, c: PBX"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "この問題は、既存の電話システムをIPネットワークに統合する際の、各装置の役割と正しい接続順序を理解しているかを確認する問題です。\n\nそれぞれの装置の役割は以下の通りです。\n\n*   **a: PBX（構内交換機）**\n    企業内の複数の電話機を収容し、内線電話同士の接続や、外部の公衆電話網との接続を制御します。したがって、まず既存の電話機はPBXに接続されます。\n\n*   **b: VoIPゲートウェイ**\n    PBXが扱う音声信号と、IPネットワークで使われるデータ（IPパケット）を相互に変換する装置です。アナログ/デジタルの電話網とIPネットワークの「翻訳機」や「橋渡し役」と考えると分かりやすいでしょう。\n\n*   **c: ルータ**\n    IPパケットの宛先を見て、最適な経路でIPネットワークへ中継する装置です。社内ネットワークと外部のIPネットワークを接続する役割を担います。\n\n以上の役割から、「電話機 → PBX → VoIPゲートウェイ → ルータ → IPネットワーク」という流れが正しい接続構成となります。したがって、選択肢**a**が正解です。\n\n他の選択肢は、装置の役割と接続順序が一致しないため誤りです。例えば、ルータは音声信号を直接扱えないため、VoIPゲートウェイより先に接続することはありません。"
    },
    {
      "qNo": 23,
      "text": "ディジタル署名のあるソフトウェアをインストールするときに，そのソフトウェアの開発元又は発行元を確認するために使用する証明書はどれか。",
      "options": [
        {
          "id": "a",
          "text": "EV SSL 証明書"
        },
        {
          "id": "b",
          "text": "クライアント証明書"
        },
        {
          "id": "c",
          "text": "コードサイニング証明書"
        },
        {
          "id": "d",
          "text": "サーバ証明書"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "この問題は、ディジタル署名で利用される電子証明書の種類に関する知識を問うています。\n\n正解は **c: コードサイニング証明書** です。\n\n**コードサイニング証明書**は、その名前の通り「コード（ソフトウェア）」に「サイニング（署名）」するための電子証明書です。ソフトウェアの開発元がこの証明書を使ってディジタル署名を行うことで、利用者はソフトウェアをインストールする際に、以下の2点を確認できます。\n\n*   **開発元の証明**: ソフトウェアが信頼できる開発元によって作成されたものであること。\n*   **改ざんの検知**: ソフトウェアが配布途中で悪意のある第三者によって改ざんされていないこと。\n\nこれは、問題文の「ソフトウェアの開発元又は発行元を確認する」という目的に合致します。\n\n### 他の選択肢\n\n*   **a: EV SSL 証明書** と **d: サーバ証明書**は、Webサイトが本物であることを証明し、ブラウザとサーバ間の通信を暗号化（SSL/TLS通信）するために使用されます。\n*   **b: クライアント証明書**は、サーバにアクセスする利用者（クライアント）が、正当な利用者本人であることを証明するために使用されます。"
    },
    {
      "qNo": 24,
      "text": "暗号技術のうち，共通鍵暗号方式はどれか。",
      "options": [
        {
          "id": "a",
          "text": "AES"
        },
        {
          "id": "b",
          "text": "ElGamal 暗号"
        },
        {
          "id": "c",
          "text": "RSA"
        },
        {
          "id": "d",
          "text": "楕円曲線暗号"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "暗号技術は、大きく2つの方式に分けられます。それぞれの特徴を理解することがポイントです。\n\n*   **共通鍵暗号方式**:\n    データを**暗号化する鍵**と、暗号化されたデータを元に戻す（**復号する**）**鍵が同じ**方式です。処理が高速ですが、事前に安全な方法で相手に鍵を渡しておく必要があります。\n*   **公開鍵暗号方式**:\n    **暗号化用の「公開鍵」**と**復号用の「秘密鍵」**という、ペアになった**別々の鍵**を使う方式です。公開鍵は誰にでも渡せますが、秘密鍵は自分だけが持っておきます。\n\n選択肢を見ていきましょう。\n\n*   **a: AES**\n    **共通鍵暗号方式**の代表的なアルゴリズムであり、現在の標準として広く利用されています。したがって、これが**正解**です。\n\n*   **b: ElGamal暗号, c: RSA, d: 楕円曲線暗号**\n    これらは全て、**公開鍵暗号方式**に分類されます。それぞれ異なる数学的な理論に基づいています。\n\nよって、共通鍵暗号方式である「a: AES」が正解となります。"
    },
    {
      "qNo": 25,
      "text": "セキュア OS を利用することによって期待できるセキュリティ上の効果はどれか。",
      "options": [
        {
          "id": "a",
          "text": "1 回の利用者認証で複数のシステムを利用できるので，強固なパスワードを一つだけ管理すればよくなり，脆弱なパスワードを設定しにくくなる。"
        },
        {
          "id": "b",
          "text": "Web サイトへの通信路上に配置して通信を解析し，攻撃をブロックすることによって，Web アプリケーションソフトウェアの脆弱性を突く攻撃から Web サイトを保護できる。"
        },
        {
          "id": "c",
          "text": "強制アクセス制御の設定によって，ファイルの更新が禁止されていれば，システムに侵入されてもファイルの改ざんを防止できる。"
        },
        {
          "id": "d",
          "text": "システムへのログイン時には，パスワードのほかに専用トークンを用いた認証が行われるので，パスワードが漏えいしても，システムへの侵入を防止できる。"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "正解は **c** です。\n\n**セキュアOS**とは、OSのセキュリティ機能をより強固にしたものです。その中心的な機能が「**強制アクセス制御（MAC: Mandatory Access Control）**」です。\n\n*   **c（正解）**: 強制アクセス制御は、システム管理者が定めた統一的なセキュリティポリシーに基づき、誰がどのファイルにアクセスできるかを**強制的に**制限する仕組みです。例えば「管理者（root）権限を持つユーザーであっても、特定の重要ファイルの更新は許可しない」といった厳格なルールを設定できます。このため、攻撃者がシステムに侵入して高い権限を奪ったとしても、設定されたルールによってファイルの改ざんを防ぐ効果が期待できます。\n\n*   **a（誤り）**: 1回の認証で複数のシステムを利用できるようにするのは「**シングルサインオン（SSO）**」の説明です。\n\n*   **b（誤り）**: Webサイトへの攻撃をブロックするのは「**WAF（Web Application Firewall）**」の説明です。\n\n*   **d（誤り）**: パスワードと専用トークンなど、複数の要素で認証するのは「**多要素認証（MFA）**」の説明です。"
    }
  ]
}