{
  "questions": [
    {
      "qNo": 1,
      "theme": "Algorithm: Finding the Maximum Value",
      "description": "The function `maximum` takes three distinct integers (x, y, z) as arguments and returns the maximum value among them. We need to fill in the condition for the initial `if` statement.\n\npseudocode\n○整数型:maximum(整数型:x,整数型:y,整数型:z)\nif ( [  ] )\n  return x\nelseif (y > z)\n  return y\nelse\n  return z\nendif\n",
      "context": {
        "title": "最大値探索アルゴリズム",
        "background": "The function `maximum` takes three distinct integers (x, y, z) as arguments and returns the maximum value among them. We need to fill in the condition for the initial `if` statement.\n\n{{diagram:fig1}}",
        "diagrams": [
          {
            "id": "fig1",
            "label": "擬似コード: maximum関数",
            "type": "markdown",
            "content": "○整数型:maximum(整数型:x,整数型:y,整数型:z)\nif ( [  ] )\n  return x\nelseif (y > z)\n  return y\nelse\n  return z\nendif"
          },
          {
            "id": "fig2",
            "label": "maximum関数の処理フロー",
            "type": "mermaid",
            "content": "graph TD\n    A[maximum(x, y, z)] --> B{x > y AND x > z?};\n    B -- Yes --> C[Return x];\n    B -- No (x is not max) --> D{y > z?};\n    D -- Yes --> E[Return y];\n    D -- No (y <= z) --> F[Return z];"
          }
        ]
      },
      "questions": [
        {
          "subQNo": "問1",
          "text": "Fill the blank condition.",
          "references": [
            "fig1"
          ],
          "answer": "イ",
          "explanation": "The function aims to return the maximum of x, y, and z.\n\n### 処理の流れ\n{{diagram:fig2}}\n\n1.  The first block `if ( [ ] ) return x` should execute only if `x` is the maximum value. For `x` to be the maximum, it must be greater than both `y` AND `z`.\n2.  The required condition is `x > y and x > z`.\n3.  If this condition is false, `x` is not the maximum. The process proceeds to check `elseif (y > z)`.\n4.  If `x` is not the maximum, and `y > z`, then `y` must be the maximum, and `y` is returned.\n5.  Otherwise (`else`), `x` is not the maximum, and `y <= z`. Therefore, `z` must be the maximum, and `z` is returned.\n\nThis confirms the initial condition must be `x > y and x > z` (Option イ).",
          "point": 16
        }
      ]
    },
    {
      "qNo": 2,
      "theme": "Algorithm: Binary to Decimal Conversion",
      "description": "The function `convDecimal` converts a string consisting of '0's and '1's (representing an unsigned binary number) into its integer value. It uses an external function `int(char)`, which returns 0 if the character is '0' and 1 if it is '1'. The conversion uses the standard weighted sum approach.\n\nExample: \"10010\" -> 18.\n\npseudocode\n○整数型:convDecimal(文字列型:binary)\n整数型:i, length, result ← 0\nlength ← binaryの文字数\nfor(iを1から length まで 1 ずつ増やす)\n  result ← [  ]\nendfor\nreturn result\n",
      "context": {
        "title": "Binary to Decimal Conversion Algorithm",
        "background": "The function `convDecimal` converts a string consisting of '0's and '1's (representing an unsigned binary number) into its integer value. It uses an external function `int(char)`, which returns 0 if the character is '0' and 1 if it is '1'. The conversion uses the standard weighted sum approach.\n\nExample: \"10010\" -> 18.\n\npseudocode\n○整数型:convDecimal(文字列型:binary)\n整数型:i, length, result ← 0\nlength ← binaryの文字数\nfor(iを1から length まで 1 ずつ増やす)\n  result ← [  ]\nendfor\nreturn result\n",
        "diagrams": []
      },
      "questions": [
        {
          "subQNo": "問2",
          "text": "Fill the blank expression.",
          "references": [],
          "answer": "エ",
          "explanation": "The algorithm converts a binary string by iterating through its characters from left to right (Most Significant Bit first). This uses Horner's method for base conversion: $R_{new} = R_{old} \\times 2 + b_i.\\n\\n### 処理の流れ\\nmermaid\\ngraph TD\\n    A[Start convDecimal] --> B[result = 0, L = length];\\n    B --> C{For i = 1 (MSB) to L (LSB)};\\n    C --> D[bit_val = int(binary[i])];\\n    D --> E[result = result * 2 + bit_val];\\n    E --> C;\\n    C --> F[Return result];\\n\\n\\nIf the input is \"10010\" (L=5), the loop processes `binary[1]` ('1'), `binary[2]` ('0'), ..., `binary[5]` ('0').\\n\\n1.  i=1: result = $0 \\times 2 + 1 = 1$\\n2.  i=2: result = $1 \\times 2 + 0 = 2$\\n3.  i=3: result = $2 \\times 2 + 0 = 4$\\n4.  i=4: result = $4 \\times 2 + 1 = 9$\\n5.  i=5: result = $9 \\times 2 + 0 = 18$\\n\\nThe operation inside the loop must be `result \\times 2 + int(binary の i文字目の文字)`.\\n\\nThis corresponds to Option エ.",
          "point": 16
        }
      ]
    },
    {
      "qNo": 3,
      "theme": "Algorithm: Graph Representation Conversion (Edge List to Adjacency Matrix)",
      "description": "",
      "context": {
        "title": "Graph Representation Conversion (Edge List to Adjacency Matrix)",
        "background": "The function `edgesToMatrix` converts a list of edges (`edgeList`) and the number of vertices (`nodeNum`) into an adjacency matrix (`adjMatrix`) for an undirected graph. The matrix is initialized to zeros. Since the graph is undirected, an edge between vertex $u$ and vertex $v$ requires setting both $adjMatrix[u][v]$ and $adjMatrix[v][u]$ to 1. Vertex indexing starts at 1.\n\npseudocode\n○整数型の二次元配列: edgesToMatrix(整数型配列の配列: edgeList,\n整数型: nodeNum)\n整数型の二次元配列: adjMatrix ← {nodeNum行nodeNum列の 0}\n整数型:i, u, v\nfor(iを1から edgeListの要素数 まで 1 ずつ増やす)\n  u ← edgeList[i][1]\n  v ← edgeList[i][2]\n  [  ]\nendfor\nreturn adjMatrix\n",
        "diagrams": [
          {
            "id": "fig1",
            "label": "処理の流れ",
            "type": "mermaid",
            "content": "graph TD\n    A[Start edgesToMatrix] --> B[Initialize adjMatrix to 0];\n    B --> C{For each edge i}; \n    C --> D[u = edgeList[i][1], v = edgeList[i][2]];\n    D --> E[Set adjMatrix[u, v] = 1];\n    E --> F[Set adjMatrix[v, u] = 1];\n    F --> C;\n    C --> G[Return adjMatrix];"
          }
        ]
      },
      "questions": [
        {
          "subQNo": "問3",
          "text": "Fill the blank statement.",
          "references": [],
          "answer": "エ",
          "explanation": "The loop iterates through every edge, extracting the two endpoints, $u$ and $v$. Since the graph is undirected, the presence of an edge $(u, v)$ means there is a connection both ways. The adjacency matrix must reflect this symmetry.\n\n### 処理の流れ\n{{diagram:fig1}}\n\nWe must set the values for both directions: `adjMatrix[u, v] ← 1` and `adjMatrix[v, u] ← 1`.\n\nThis corresponds to Option エ.",
          "point": 16
        }
      ]
    },
    {
      "qNo": 4,
      "theme": "Algorithm: Merging Sorted Arrays",
      "description": "The function `merge` combines two ascendingly sorted integer arrays, `data1` and `data2`, into a single sorted array, `work`. Array indices start at 1. The program uses three main loops: the first performs the main merge operation, the second copies remaining elements from `data1`, and the third copies remaining elements from `data2`.\n\nWe call `merge({2, 3}, {1, 4})`.\n\npseudocode\n// ... setup and first two while loops ...\n\nwhile (j ≤ n2)\nwork[k] ← data2[j] /*** α ***/\nj←j+1\nk←k+1\nendwhile\n\nreturn work\n\nWe need to determine how many times the line marked `/*** α ***/` is executed.",
      "context": {
        "title": "Merging Sorted Arrays Algorithm Trace",
        "background": "The function `merge` combines two ascendingly sorted integer arrays, `data1` and `data2`, into a single sorted array, `work`. Array indices start at 1. The program uses three main loops: the first performs the main merge operation, the second copies remaining elements from `data1`, and the third copies remaining elements from `data2`.\n\nWe call `merge({2, 3}, {1, 4})`.\n\npseudocode\n// ... setup and first two while loops ...\n\nwhile (j ≤ n2)\nwork[k] ← data2[j] /*** α ***/\nj←j+1\nk←k+1\nendwhile\n\nreturn work\n\nWe need to determine how many times the line marked `/*** α ***/` is executed.",
        "diagrams": []
      },
      "questions": [
        {
          "subQNo": "問4",
          "text": "How many times is the line `/*** α ***/` executed when calling `merge({2, 3}, {1, 4})`?",
          "references": [],
          "answer": "イ",
          "explanation": "We trace the execution with $data1=\\{2, 3\\}$ ($n1=2$) and $data2=\\{1, 4\\}$ ($n2=2$). Initial pointers: $i=1, j=1, k=1$.\n\n### Trace of the first `while` loop (Merging)\n\n| Step | i | j | data1[i] | data2[j] | Condition (d1[i] <= d2[j]) | Action (work[k] ← ...) | Pointers after | work | \n|---|---|---|---|---|---|---|---|---|\n| Initial | 1 | 1 | 2 | 1 | False | work[1] ← d2[1] (1), j++ | i=1, j=2, k=2 | {1, ...} | \n| 1 | 1 | 2 | 2 | 4 | True | work[2] ← d1[1] (2), i++ | i=2, j=2, k=3 | {1, 2, ...} | \n| 2 | 2 | 2 | 3 | 4 | True | work[3] ← d1[2] (3), i++ | i=3, j=2, k=4 | {1, 2, 3, ...} | \n\nThe main loop terminates because $i=3$ ($i \\not\\le n1$).\n\n### Trace of the second `while` loop (Copy remaining d1)\n\nCondition: `while (i ≤ n1)` (while $3 \\le 2$). This is False. The loop executes 0 times.\n\n### Trace of the third `while` loop (Copy remaining d2)\n\nCondition: `while (j ≤ n2)` (while $j \\le 2$).\n\n| Step | j | k | Condition (j ≤ 2) | Action (*** α ***) | Pointers after | \n|---|---|---|---|---|---|\n| 1 | 2 | 4 | True | work[4] ← d2[2] (4), j++, k++ | j=3, k=5 | \n| 2 | 3 | 5 | False | Loop terminates | | \n\nThe line `/*** α ***/` is executed 1 time.\n\nThis corresponds to Option イ.",
          "point": 16
        }
      ]
    },
    {
      "qNo": 5,
      "theme": "Data Mining: Item Relatedness Calculation",
      "description": "The program `putRelatedItem` calculates item relatedness $L_{xy}$ based on purchase data (`orders`). $L_{xy}$ is defined as:\n\n$$L_{xy} = \\frac{M_{xy} \\times \\text{Total Orders}}{K_x \\times K_y}$$\n\n$M_{xy}$: Number of orders containing both $x$ and $y$ (stored in `arrayM`).\n$K_x$: Number of orders containing $x$ (stored in `itemCount`).\n$K_y$: Number of orders containing $y$ (stored in `arrayK`).\nTotal Orders: Number of orders in the `orders` array.\n\nWe need to determine the correct variables for blanks `a`, `b`, and `c`.\n\n### Program Snippets\n\n**Snippet 1: Counting Mxy and Ky**\npseudocode\n// ... inside for (order in orders) loop ...\n\n// Kx (itemCount) is updated if X is present.\n\nfor(iを1からotherItemsの要素数まで1ずつ増やす) // i indexes candidate item Y = otherItems[i]\n  if (orderのいずれかの要素の値がotherItems[i]の値と等しい) // Y is present\n    if (orderのいずれかの要素の値がitemの値と等しい) // X is present\n      [ a ] の値を1増やす\n    endif\n    [ b ] の値を1増やす\n  endif\nendfor\n\n\n**Snippet 2: Calculating Lxy**\npseudocode\nfor(iを1からotherItemsの要素数まで1ずつ増やす)\n  valueL ← (arrayM[i] × [ c ]) ÷ (itemCount × arrayK[i])\n// ... \n",
      "context": {
        "title": "アイテム関連度 $L_{xy}$ の計算",
        "background": "The program `putRelatedItem` calculates item relatedness $L_{xy}$ based on purchase data (`orders`). $L_{xy}$ is defined as:\n\n$$L_{xy} = \\frac{M_{xy} \\times \\text{Total Orders}}{K_x \\times K_y}$$\n\n$M_{xy}$: Number of orders containing both $x$ and $y$ (stored in `arrayM`).\n$K_x$: Number of orders containing $x$ (stored in `itemCount`).\n$K_y$: Number of orders containing $y$ (stored in `arrayK`).\nTotal Orders: Number of orders in the `orders` array.\n\nWe need to determine the correct variables for blanks `a`, `b`, and `c`.\n\n### Program Snippets\n\n**Snippet 1: Counting Mxy and Ky**\npseudocode\n// ... inside for (order in orders) loop ...\n\n// Kx (itemCount) is updated if X is present.\n\nfor(iを1からotherItemsの要素数まで1ずつ増やす) // i indexes candidate item Y = otherItems[i]\n  if (orderのいずれかの要素の値がotherItems[i]の値と等しい) // Y is present\n    if (orderのいずれかの要素の値がitemの値と等しい) // X is present\n      [ a ] の値を1増やす\n    endif\n    [ b ] の値を1増やす\n  endif\nendfor\n\n\n**Snippet 2: Calculating Lxy**\npseudocode\nfor(iを1からotherItemsの要素数まで1ずつ増やす)\n  valueL ← (arrayM[i] × [ c ]) ÷ (itemCount × arrayK[i])\n// ... \n",
        "diagrams": []
      },
      "questions": [
        {
          "subQNo": "問5",
          "text": "Determine the correct combination of answers for a, b, and c.",
          "references": [],
          "answer": "オ",
          "explanation": "### 1. Determining [ a ] and [ b ] (Counts)\n\nWe analyze Snippet 1. The outer `for (order in orders)` iterates through all purchase records.\n\n*   `[ a ]` is incremented when both $X$ (`item`) and $Y$ (`otherItems[i]`) are present in the current `order`. Therefore, `[ a ]` tracks $M_{xy}$. $M_{xy}$ is stored in `arrayM[i]`. So, **a = arrayM[i]**.\n*   `[ b ]` is incremented whenever $Y$ (`otherItems[i]`) is present in the current `order`, regardless of $X$'s presence. Therefore, `[ b ]` tracks $K_y$. $K_y$ is stored in `arrayK[i]`. So, **b = arrayK[i]**.\n\n### 2. Determining [ c ] (Total Orders)\n\nWe analyze Snippet 2 using the formula $L_{xy} = (M_{xy} \\times \\text{Total Orders}) / (K_x \\times K_y)$.\n\nIn the pseudo-code:\n`valueL ← (arrayM[i] × [ c ]) ÷ (itemCount × arrayK[i])`\n\nBy comparing this to the formula, `[ c ]` must represent the Total Number of Orders. This value is given by the length of the global array `orders`.\n\nSo, **c = ordersの要素数**.\n\nMatching the results:\n*   a: arrayM[i]\n*   b: arrayK[i]\n*   c: ordersの要素数\n\nThis matches Option オ.",
          "point": 16
        }
      ]
    },
    {
      "qNo": 6,
      "theme": "Information Security: Telework Architecture and Risk Mitigation",
      "description": "Company A uses a telework system where employees connect to internal PCs via Remote Desktop (RDP) from their private PCs (BYOD). Access to A's cloud services (SaaS) is currently restricted only to traffic originating from the A internal network.\n\nTo resolve network congestion caused by RDP tunneling cloud traffic through the internal network, A plans to allow direct connections from private PCs over the Internet to the cloud services, bypassing the internal network.\n\nThis change increases the risk of unauthorized access to A社のSaaS because the network access restriction is removed. The question asks for the most appropriate countermeasure to mitigate this specific risk.\n\n### A社のシステム環境 (抜粋)\nmermaid\ngraph TD\n    P[私有 PC (Private PC)]\n    R[社内 PC (Internal PC)]\n    I[インターネット (Internet)]\n    N[A社 社内ネットワーク]\n    S[A社利用クラウドサービス (SaaS)]\n    \n    subgraph Current Configuration\n        P -- RDP --> I\n        I --> R\n        R --> N\n        N -- Allowed --> S\n        I -- Blocked/Restricted --> S\n    end\n    \n    subgraph Planned Configuration\n        P -- Direct Connection --> I\n        I -- New Direct Access --> S\n    end\n",
      "context": {
        "title": "テレワーク環境におけるセキュリティリスクと対策",
        "background": "Company A uses a telework system where employees connect to internal PCs via Remote Desktop (RDP) from their private PCs (BYOD). Access to A's cloud services (SaaS) is currently restricted only to traffic originating from the A internal network.\n\nTo resolve network congestion caused by RDP tunneling cloud traffic through the internal network, A plans to allow direct connections from private PCs over the Internet to the cloud services, bypassing the internal network.\n\nThis change increases the risk of unauthorized access to A社のSaaS because the network access restriction is removed. The question asks for the most appropriate countermeasure to mitigate this specific risk.\n\n## 図1 A社のシステム環境 (抜粋)\n{{diagram:fig1}}",
        "diagrams": [
          {
            "id": "fig1",
            "label": "A社のシステム環境 (抜粋)",
            "type": "mermaid",
            "content": "graph TD\n    P[私有 PC (Private PC)]\n    R[社内 PC (Internal PC)]\n    I[インターネット (Internet)]\n    N[A社 社内ネットワーク]\n    S[A社利用クラウドサービス (SaaS)]\n    \n    subgraph Current Configuration\n        P -- RDP --> I\n        I --> R\n        R --> N\n        N -- Allowed --> S\n        I -- Blocked/Restricted --> S\n    end\n    \n    subgraph Planned Configuration\n        P -- Direct Connection --> I\n        I -- New Direct Access --> S\n    end"
          }
        ]
      },
      "questions": [
        {
          "subQNo": "設問",
          "text": "Which of the following is the most appropriate countermeasure to mitigate the risk of unauthorized access to A社のSaaS due to the change in network configuration?",
          "references": [
            "fig1"
          ],
          "answer": "ウ",
          "explanation": "The critical security change is removing the requirement that connections must originate from the secure internal network (N). Previously, the internal network boundary acted as a strong barrier against unauthorized external access.\n\nBy allowing direct connections from the public Internet (P -> I -> S), the authentication mechanism becomes the primary defense. Standard ID/Password authentication is often insufficient when exposed directly to the Internet.\n\n### Risk Mitigation Analysis\n\nmermaid\nsequenceDiagram\n    participant U as Unauthorized User (Private PC)\n    participant S as A社利用クラウドサービス (SaaS)\n    \n    alt Current State (Secure)\n        U->>S: Access Attempt (Fails)\n        Note right of S: Blocked by IP Restriction\n    end\n    \n    alt New Configuration (Risk)\n        U->>S: Access Attempt (ID/PW Only)\n        S-->>U: Vulnerable to credential compromise\n    end\n    \n    alt Proposed Solution (Mitigation)\n        U->>S: Access Attempt (ID/PW + 2FA)\n        S-->>U: 2FA required for external connection\n    end\n\n\nTo compensate for the removal of the network boundary protection, the identity authentication mechanism must be strengthened. Introducing Multi-Factor Authentication (MFA), such as Two-Factor Authentication (2要素認証), is the standard and most effective way to drastically reduce the risk of unauthorized access resulting from compromised passwords.\n\nOption ウ directly addresses this security deficiency.\n\n*   ア (Monitoring internal traffic) is irrelevant to external connections.\n*   イ (Limiting speed) addresses performance/congestion, not security risk.\n*   エ (Limiting scope) is a partial mitigation but fails to strengthen the authentication for the services that *are* enabled for direct access.\n*   オ (Disabling prevention features) increases data risk, moving in the wrong direction.\n\nTherefore, Option ウ is the most appropriate measure.",
          "point": 16
        }
      ]
    }
  ]
}