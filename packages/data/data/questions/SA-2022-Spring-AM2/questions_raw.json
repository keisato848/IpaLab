{
  "questions": [
    {
      "qNo": 1,
      "text": "アジャイル開発の初期段階において, プロジェクトの目的, スコープなどに対する共通認識を得るために, あらかじめ設定されている設問と課題について関係者が集まって確認し合い, その成果を共有する手法はどれか。",
      "options": [
        {
          "id": "a",
          "text": "アジャイルモデリング"
        },
        {
          "id": "b",
          "text": "インセプションデッキ"
        },
        {
          "id": "c",
          "text": "プランニングポーカー"
        },
        {
          "id": "d",
          "text": "ユーザストーリマッピング"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "**インセプションデッキ**は、アジャイル開発のプロジェクト開始時に用いられる手法です。プロジェクトの目的、目指すゴール、スコープ（開発範囲）といった重要な項目について、あらかじめ用意された10個の質問（例：「我々は何故ここにいるのか？」「やらないことリスト」など）にチーム全員で答えていきます。これにより、関係者間の認識のズレを防ぎ、プロジェクト全体の共通認識を形成することができます。\n\n問題文の「初期段階」「目的, スコープなどに対する共通認識」「設問と課題」という特徴に合致するため、**bが正解**です。\n\nその他の選択肢は以下の通りです。\n\n*   **a: アジャイルモデリング**は、開発を進めながら必要最小限の設計図（モデル）を作成していく考え方やプラクティスの総称です。\n*   **c: プランニングポーカー**は、開発する機能の工数や規模を、チームメンバーがトランプのようなカードを使って見積もる手法です。\n*   **d: ユーザーストーリマッピング**は、ユーザーの行動の流れに沿って必要な機能（ユーザーストーリー）を整理し、開発の優先順位やリリース計画を立てるための手法です。"
    },
    {
      "qNo": 2,
      "text": "ソフトウェアパターンのうち, GoF のデザインパターンの説明はどれか。",
      "options": [
        {
          "id": "a",
          "text": "Java のパターンとして, 引数オブジェクト, オブジェクトの可変性などで構成される。"
        },
        {
          "id": "b",
          "text": "オブジェクト指向開発のためのパターンであって, 生成, 構造, 振る舞いの三つのカテゴリに分類される。"
        },
        {
          "id": "c",
          "text": "構造, 分散システム, 対話型システム及び適合型システムの四つのカテゴリに分類される。"
        },
        {
          "id": "d",
          "text": "抽象度が異なる要素を分割して階層化するための Layers, コンポーネント分割のための Broker などで構成される。"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "GoF（Gang of Four、\"4人組\"の意）のデザインパターンは、オブジェクト指向設計で繰り返し現れる問題とその解決策をまとめた、23種類の設計パターンのことです。\n\n正解の選択肢 **b** が正しい理由は、GoFのデザインパターンが、その目的によって以下の3つのカテゴリに分類されているためです。\n\n*   **生成 (Creational)**: オブジェクトのインスタンス化（生成）を柔軟かつ効率的に行うためのパターン。 (例: Singleton, Factory Method)\n*   **構造 (Structural)**: クラスやオブジェクトを組み合わせて、より大きな構造を構築するためのパターン。 (例: Adapter, Decorator)\n*   **振る舞い (Behavioral)**: オブジェクト間の責務の割り当てや、アルゴリズムをどう実現するかに関するパターン。 (例: Observer, Strategy)\n\n---\n\n他の選択肢が誤りである理由は以下の通りです。\n\n*   **a**: GoFのデザインパターンは、Javaに限定されたものではなく、様々なオブジェクト指向言語で適用できる普遍的な設計思想です。\n*   **c, d**: これらは「**POSA (Pattern-Oriented Software Architecture)**」で紹介されている、より大規模なソフトウェアアーキテクチャに関するパターン（アーキテクチャパターン）の説明です。LayersやBrokerはPOSAの代表的なパターンです。"
    },
    {
      "qNo": 3,
      "text": "Pattern-Oriented Software Architecture (POSA) のアーキテクチャパターンのうち, ソフトウェアをメタレベルとベースレベルの二つのレベルに分割し, ソフトウェアの構造と振る舞いとを動的に変更できる仕組みを提供しているものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "Broker"
        },
        {
          "id": "b",
          "text": "Microkernel"
        },
        {
          "id": "c",
          "text": "Model-View-Controller"
        },
        {
          "id": "d",
          "text": "Reflection"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "正解は **d: Reflection** です。\n\nReflection（リフレクション）は、プログラムが実行中に自分自身の構造（クラス、メソッドなど）を調べたり、それを変更したりする仕組みを提供するアーキテクチャパターンです。\n\nこのパターンでは、ソフトウェアを以下の2つのレベルに分割します。\n*   **ベースレベル**: アプリケーションの本来の処理（ビジネスロジックなど）を実行する部分。\n*   **メタレベル**: ベースレベルの構造や振る舞いに関する情報（メタデータ）を持ち、それを操作する部分。\n\nメタレベルが、まるで鏡（Reflection）で自分を映すようにベースレベルの情報を扱い、動的にその構造や振る舞いを変更できる点が最大の特徴です。\n\n### 他の選択肢\n\n*   **a: Broker** は、分散システムにおいて、コンポーネント間の通信を仲介するパターンです。\n*   **b: Microkernel** は、OSなどで、中心となる最小限の機能（カーネル）と、拡張機能（サーバ）を分離するパターンです。\n*   **c: Model-View-Controller (MVC)** は、UIを持つアプリケーションを「データ(Model)」「表示(View)」「制御(Controller)」の3つの役割に分割するパターンです。"
    },
    {
      "qNo": 4,
      "text": "組込みシステムで DBMS を用いるときには, 通信のオーバヘッド, 通信負荷の発生を防ぐこと, 必要なメモリ容量をリソース制限内に抑えることなどを目的として, インプロセスデータベースを用いることがある。このインプロセスデータベースの説明として, 適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "クライアントサーバ形式のクライアントとなるアプリケーションプログラムとソケットを介して通信し, SQL を用いて処理を記述する。"
        },
        {
          "id": "b",
          "text": "データベースエンジンはライブラリ形式で提供され, アプリケーションプログラムとリンクされて同一メモリ空間で動作する。"
        },
        {
          "id": "c",
          "text": "データベースの全体をメモリ上に配置して, データベース処理を高速化する。"
        },
        {
          "id": "d",
          "text": "一つのテーブルを一つのファイルで管理し, アプリケーションプログラムからはファイル入出力の API で操作する。"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "インプロセスデータベースとは、その名前の通り「アプリケーションの**プロセス内に組み込まれて**」動作するデータベースのことです。この点を理解することが正解への鍵となります。\n\n*   **b (正解):** この選択肢はインプロセスデータベースの特徴を最も正確に説明しています。データベースの機能（エンジン）が**ライブラリ**（プログラムの部品集）として提供され、アプリケーションに直接リンク（一体化）されます。その結果、アプリケーションとデータベースは**同じメモリ空間で動作**するため、両者間の通信が不要になり、高速かつ省メモリな処理が可能です。これはリソースが限られる組込みシステムに適しています。\n\n*   **a (誤り):** ソケットを介して通信するのは、アプリケーションとデータベースが別々のプロセスとして動作する**クライアントサーバ型データベース**（例: MySQL, PostgreSQL）の説明です。\n\n*   **c (誤り):** データベース全体をメモリ上に配置して高速化するのは、**インメモリデータベース**の説明です。インプロセスデータベースがデータをメモリ上に持つこともありますが、これは必須の要件ではありません。\n\n*   **d (誤り):** これは単純なファイルシステムを利用したデータ管理方法の説明です。SQLを用いて複雑なデータ操作を行うDBMS（データベース管理システム）の特徴とは異なります。"
    },
    {
      "qNo": 5,
      "text": "デザインパターンの中のストラテジパターンを用いて, 帳票出力のクラスを図のとおりに設計した。適切な説明はどれか。\n\n```mermaid\nclassDiagram\n    class コンテキスト\n    class 帳票出力ストラテジ {\n        <<interface>>\n        +帳票出力()\n    }\n    class PDF帳票出力ストラテジ {\n        +帳票出力()\n    }\n    class HTML帳票出力ストラテジ {\n        +帳票出力()\n    }\n    コンテキスト o-- 帳票出力ストラテジ\n    帳票出力ストラテジ <|-- PDF帳票出力ストラテジ\n    帳票出力ストラテジ <|-- HTML帳票出力ストラテジ\n```",
      "options": [
        {
          "id": "a",
          "text": "クライアントは, 使用したいフォーマットに対応する, 帳票出力ストラテジクラスのサブクラスを意識せずに利用できる。"
        },
        {
          "id": "b",
          "text": "新規フォーマット用のアルゴリズムの追加が容易である。"
        },
        {
          "id": "c",
          "text": "帳票出力ストラテジクラスの中で, どのフォーマットで帳票を出力するかの振り分けを行っている。"
        },
        {
          "id": "d",
          "text": "帳票出力のアルゴリズムは, コンテキストクラスの中に記述する。"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "この問題で使われている**ストラテジパターン**は、アルゴリズム（処理の手順や方法）をクラスとしてカプセル化し、それらを**部品のように交換可能にする**デザインパターンです。\n\n### 正解の選択肢 (b)\n- ストラテジパターンでは、帳票の出力形式（PDFやHTML）といった「戦略（ストラテジ）」が、それぞれ独立したクラス（`PDF帳票出力ストラテジ`、`HTML帳票出力ストラテジ`）として実装されています。\n- この設計の最大のメリットは、**拡張性の高さ**です。例えば、新たに「CSV形式」の帳票出力機能を追加したい場合、`帳票出力ストラテジ`インターフェースを実装した`CSV帳票出力ストラテジ`クラスを新しく作成するだけで対応できます。\n- 既存の`コンテキスト`クラスなどを修正する必要がないため、**新規フォーマット用のアルゴリズムの追加が容易**になります。したがって、この選択肢は正しいです。\n\n### その他の選択肢\n- **a**: 利用者（クライアント）は、PDFで出力したいのか、HTMLで出力したいのかを**意識して**、対応するストラテジクラスを選択し、`コンテキスト`にセットする必要があります。\n- **c**: どのフォーマットで出力するかの振り分け（選択）は、`コンテキスト`クラスを利用する側が行います。`帳票出力ストラテジ`は、あくまで処理の共通仕様を定めたインターフェースです。\n- **d**: 帳票出力の具体的なアルゴリズムは、`PDF帳票出力ストラテジ`や`HTML帳票出力ストラテジ`といった具象クラスの中に記述します。`コンテキスト`クラスは、それらのアルゴリズムを呼び出して利用する役割を持ちます。"
    },
    {
      "qNo": 6,
      "text": "モジュール間のデータの受渡し方法のうち, 最も低いモジュール結合度となるものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "単一のデータ項目を大域的データで受け渡す。"
        },
        {
          "id": "b",
          "text": "単一のデータ項目を引数で受け渡す。"
        },
        {
          "id": "c",
          "text": "データ構造を大域的データで受け渡す。"
        },
        {
          "id": "d",
          "text": "データ構造を引数で受け渡す。"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "この問題のポイントは、モジュール（プログラムの部品）同士の関連性の強さを表す「**モジュール結合度**」です。結合度は**低いほど**、モジュールが独立していて再利用しやすく、良い設計とされます。\n\n- **b (正解):** 単一のデータ項目を**引数**で受け渡す方法は「**データ結合**」と呼ばれ、最も結合度が低くなります。これは、モジュールが必要とするデータだけをピンポイントで受け取るため、他の部分への影響が最小限に抑えられ、独立性が最も高くなるからです。\n\n- **d:** データ構造（複数のデータをまとめたもの）を引数で渡すのは「**スタンプ結合**」です。データ構造の中に使わないデータまで含まれている可能性があり、不要な依存関係が生まれるため、データ結合よりは結合度が高くなります。\n\n- **a, c:** **大域的データ**（グローバル変数など、どこからでもアクセスできる共有データ）で受け渡す方法は「**共通結合**」と呼ばれます。多くのモジュールが同じデータを参照・変更できるため、あるモジュールでの変更が予期せず他のモジュールに影響を与える可能性があり、結合度が非常に高くなります。\n\nしたがって、最も結合度が低いのはbとなります。"
    },
    {
      "qNo": 7,
      "text": "既存システムを基に, 新システムのモデル化を行う場合の DFD 作成の手順として, 適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "現物理モデル → 現論理モデル → 新物理モデル → 新論理モデル"
        },
        {
          "id": "b",
          "text": "現物理モデル → 現論理モデル → 新論理モデル → 新物理モデル"
        },
        {
          "id": "c",
          "text": "現論理モデル → 現物理モデル → 新物理モデル → 新論理モデル"
        },
        {
          "id": "d",
          "text": "現論理モデル → 現物理モデル → 新論理モデル → 新物理モデル"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "DFD（データフロー図）を用いたシステム開発では、**「具体 → 抽象 → 抽象 → 具体」**の順でモデル化を進めるのが基本です。ここでいう「具体」が**物理モデル**、「抽象」が**論理モデル**にあたります。\n\n-   **物理モデル**: 「誰が、どのように」といった具体的な担当者、部署、帳票、システムなど、物理的な要素を含んだモデルです。\n-   **論理モデル**: 物理的な要素を取り除き、「何を」すべきかという本質的なデータの流れや処理だけを表したモデルです。\n\nこの考え方に従うと、開発手順は以下のようになります。\n\n1.  **現物理モデルの作成**: まず、現在の業務が「どのように」行われているかを具体的に把握します。\n2.  **現論理モデルの作成**: 次に、現状の物理的な制約を取り除き、業務の「本質（何をすべきか）」を抽出します。\n3.  **新論理モデルの作成**: 現状の本質を基に、新しいシステムで実現したい「理想の機能（何をすべきか）」を設計します。\n4.  **新物理モデルの作成**: 最後に、その理想の機能を「どのように」実現するか、具体的な技術や方法を設計します。\n\nこの流れに合致する選択肢**b**が正解となります。\n\n他の選択肢は、論理（何を）と物理（どうやって）の順序が誤っているため不適切です。例えば、新システムの物理モデルを先に決めると、技術的な制約に縛られ、本来実現すべき機能を見失う可能性があります。"
    },
    {
      "qNo": 8,
      "text": "ある購買システムの開発において, 開発者が行った探索的テストの例として, 適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "過去に購買システムを開発した経験に基づいて, 入力項目間の関連チェックの不備を検出しそうなデータパターンを推測し, テストケースを事前に作成してテストした。"
        },
        {
          "id": "b",
          "text": "数量の範囲に応じて適用する商品価格が正しいかどうかを確認するために, 各範囲の数量の中央の値を用いたテストケースを作成してテストした。"
        },
        {
          "id": "c",
          "text": "組織変更の前後で組織名が正しく印刷されるかどうかを確認するために, 新組織の有効開始日とその前日とを発注日とするテストケースを事前に作成してテストした。"
        },
        {
          "id": "d",
          "text": "入力値の組合せが無効なときは伝票を作成しないことを確認するために, 幾つかの代表的な入力値の組合せをテストし, その結果に基づいて次のテストケースを作成してテストを繰り返した。"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "この問題は、ソフトウェアテストの手法の一つである「探索的テスト」について問うています。\n\n**探索的テスト**とは、事前に詳細なテストケース（テストの手順書）を準備するのではなく、テスト対象のソフトウェアを操作しながら学び、その場で次のテスト内容を考えて実行していく手法です。テストの設計と実行を同時に行うようなイメージです。\n\n-   **d（正解）**: 「幾つかのテストをし、**その結果に基づいて次のテストケースを作成してテストを繰り返した**」という記述が、探索的テストの最大の特徴に合致します。テストを実行しながら得た気づきや学びを元に、次のテストを動的に計画・実行しています。\n\n-   **a, b, c（誤り）**: これらは全て「**テストケースを事前に作成してテストした**」と記述されており、あらかじめ計画されたテストを実行しているため、探索的テストではありません。\n    -   `a`は経験に基づく「エラー推測テスト」\n    -   `b`と`c`は仕様に基づく「同値分割法」や「境界値分析」といった、別のテスト技法に該当します。\n\nしたがって、テスト結果から次のテストを考えて実行を繰り返す`d`が、探索的テストの例として最も適切です。"
    },
    {
      "qNo": 9,
      "text": "ソフトウェアのテスト工程において, バグ管理図を用いて, テストの進捗状況とソフトウェアの品質を判断したい。このときの考え方のうち, 最も適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "テスト工程の前半で予想以上にバグが摘出され, スケジュールが遅れたので, スケジュールの見直しを行い, 5日遅れでテストが終了すると判断した。"
        },
        {
          "id": "b",
          "text": "テスト項目がスケジュールどおりに消化され, かつ, バグ摘出の累積件数が増加しなければ, ソフトウェアの品質は高いと判断できる。"
        },
        {
          "id": "c",
          "text": "テスト項目消化の累積件数, バグ摘出の累積件数及び未解決バグの件数の全てが変化しなくなった場合は, 解決困難なバグに直面しているかどうかを確認する必要がある。"
        },
        {
          "id": "d",
          "text": "バグ摘出の累積件数の推移とテスト項目の未消化件数の推移から, テスト終了の時期をほぼ正確に予測できる。"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "この問題は、ソフトウェアテストの進捗状況を可視化する「バグ管理図」の正しい解釈を問うています。\n\n正解は選択肢**c**です。\n\nバグ管理図は、主に以下の3つの指標の推移をグラフにしたものです。\n*   **テスト項目消化の累積件数**（テストがどれだけ進んだか）\n*   **バグ摘出の累積件数**（バグがどれだけ見つかったか）\n*   **未解決バグの件数**（修正されていないバグの数）\n\nこれらの指標が**すべて変化しない（停滞している）**場合、テスト活動そのものが止まっていることを示唆します。その原因として、他のテストの進行を妨げるような「解決困難なバグ（ブロッカーバグ）」に直面している可能性が考えられます。したがって、その状況を確認する必要があるとする選択肢cの考え方が最も適切です。\n\nその他の選択肢は以下の理由で誤りです。\n*   **a**: テスト前半でバグが多く見つかるのは、品質問題を早期に発見できているとも言え、一概に遅延と判断するのは早計です。\n*   **b**: テストは進んでいるのにバグが見つからないのは、品質が高いからではなく、テストの内容が不十分でバグを見逃している可能性も考えられます。\n*   **d**: バグ管理図はあくまで傾向を把握するためのツールであり、予期せぬ問題の発生もあるため、終了時期を「ほぼ正確に」予測するのは困難です。"
    },
    {
      "qNo": 10,
      "text": "故障の予防を目的とした解析手法である FMEA の説明はどれか。",
      "options": [
        {
          "id": "a",
          "text": "個々のシステム構成要素に起こり得る潜在的な故障モードを特定し, それらの影響度を評価する。"
        },
        {
          "id": "b",
          "text": "故障を, 発生した工程や箇所などで分類して分析し, 改善すべき工程や箇所を特定する。"
        },
        {
          "id": "c",
          "text": "発生した故障について, 故障の原因に関係するデータ, 事象などを収集し, “なぜ”を繰り返して原因を掘り下げ, 根本的な原因を追究する。"
        },
        {
          "id": "d",
          "text": "発生した故障について, その引き金となる原因を列挙し, それらの関係を木構造で表現する。"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "FMEA（Failure Mode and Effects Analysis：故障モード影響解析）は、システムや製品の設計段階で、故障を**予防**することを目的とした分析手法です。\n\n### 正解の選択肢 (a)\n- **FMEA**は、システムを構成する部品や機能一つひとつに着目します。\n- そして、「もし、この部品がこのように壊れたら（**故障モード**）、システム全体にどんな影響があるか（**影響**）」を**事前に**洗い出し、その深刻度や発生頻度を評価（**解析**）します。\n- このように、起こり得る故障を予測して対策を講じることで、故障の発生を未然に防ぎます。\n- したがって、選択肢aはFMEAの正しい説明です。\n\n### 他の選択肢\n- **b:** 発生した故障を分類・分析し、重要な問題点を特定する手法は**パレート分析**です。\n- **c:** 「なぜ」を5回ほど繰り返して根本原因を探る手法は**なぜなぜ分析**です。\n- **d:** 発生した故障（事象）を頂点とし、その原因を木構造（ツリー）で表現する手法は**FTA (Fault Tree Analysis：故障の木解析)** です。\n\nこれらの手法は、主に故障が発生した**後**の原因究明に使われる点が、予防を目的とするFMEAとの違いです。"
    },
    {
      "qNo": 11,
      "text": "JIS X 0160:2021 (ソフトウェアライフサイクルプロセス) によれば, 廃棄プロセスのタスクのうち, アクティビティ“廃棄を確実にする”において実施すべきタスクはどれか。",
      "options": [
        {
          "id": "a",
          "text": "選定されたソフトウェアシステム要素を再利用, 再生利用, 再調整, 分解修理, 保管又は破壊する。"
        },
        {
          "id": "b",
          "text": "ソフトウェアシステムの廃棄戦略を定義する。"
        },
        {
          "id": "c",
          "text": "ソフトウェアシステム又は要素を不活性化して取り除くための準備をする。"
        },
        {
          "id": "d",
          "text": "廃棄後の, 人の健康, 安全性, セキュリティ及び環境への有害な状況が識別されて対処されていることを確認する。"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "この問題は、ソフトウェアのライフサイクル（企画から廃棄までの一連の流れ）を定めた規格「JIS X 0160:2021」における**廃棄プロセス**に関する知識を問うています。廃棄プロセスは、計画→実施→確認といった複数の活動（アクティビティ）に分かれています。\n\n正解は選択肢**d**です。「廃棄を確実にする」とは、廃棄作業が終わった後に、その結果を**検証・確認**する活動を指します。選択肢dの「有害な状況が…対処されていることを確認する」という記述は、まさにこの最終確認の作業に合致するため正解です。例えば、システム内の個人情報が完全に消去されたか、環境に悪影響がないかなどをチェックするイメージです。\n\nその他の選択肢は、廃棄プロセスの別の活動に該当します。\n*   **a**: ソフトウェアの破壊や再利用は、廃棄を「**実施**」する段階の具体的な作業です。\n*   **b**: 廃棄戦略の定義は、廃棄を始める前の「**計画**」を立てる段階の作業です。\n*   **c**: 廃棄のための準備は、廃棄を「**開始**」したり、「**実施**」したりする前の段階の作業です。\n\nこのように、各選択肢が廃棄プロセスのどの段階の作業なのかを区別することが重要です。"
    },
    {
      "qNo": 12,
      "text": "JIS X 0160:2021 (ソフトウェアライフサイクルプロセス) によれば, ライフサイクルモデルの目的及び成果を達成するために, ライフサイクルプロセスを修正するか, 又は新しいライフサイクルプロセスを定義することを何というか。",
      "options": [
        {
          "id": "a",
          "text": "シミュレーション"
        },
        {
          "id": "b",
          "text": "修整 (Tailoring)"
        },
        {
          "id": "c",
          "text": "統治 (Governance)"
        },
        {
          "id": "d",
          "text": "ベンチマーキング"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "ソフトウェア開発のプロジェクトは、その規模や内容、制約などが一つ一つ異なります。そのため、あらかじめ決められた標準的な開発手順（ライフサイクルプロセス）をそのまま使うのではなく、個々のプロジェクトに合わせて最適化する必要があります。\n\nこの、**標準的なプロセスを特定のプロジェクトの目的や状況に合わせて、修正したり、新しく定義したりすることを「修整（Tailoring：テーラリング）」**と呼びます。洋服をその人に合わせて仕立て直す（tailor）イメージで覚えると分かりやすいでしょう。\n\nしたがって、正解は **b** です。\n\nその他の選択肢は以下の理由で誤りです。\n*   **a: シミュレーション**: 現実の事象をモデル化して模擬的に実行することであり、プロセスの修正そのものを指す言葉ではありません。\n*   **c: 統治 (Governance)**: 組織全体を管理・統制するための仕組みやルールのことであり、より大きな枠組みを指します。\n*   **d: ベンチマーキング**: 他社の優れた事例と比較して自社の改善点を見つける手法であり、プロセスの修正活動そのものではありません。"
    },
    {
      "qNo": 13,
      "text": "IT 投資に対する評価指標の設定に際し, バランススコアカードの手法を用いて KPI を設定する場合に, 内部ビジネスプロセスの視点に立った KPI の例はどれか。",
      "options": [
        {
          "id": "a",
          "text": "IT リテラシ向上のための研修会の受講率を 100% とする。"
        },
        {
          "id": "b",
          "text": "売上高営業利益率を前年比 5% アップとする。"
        },
        {
          "id": "c",
          "text": "顧客クレーム件数を 1 か月当たり 20 件以内とする。"
        },
        {
          "id": "d",
          "text": "注文受付から製品出荷までの日数を 3 日短縮する。"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "バランススコアカード（BSC）は、企業の業績を「財務」「顧客」「内部ビジネスプロセス」「学習と成長」という4つの視点から総合的に評価する手法です。それぞれの視点で目標（KPI）を設定します。\n\nこの問題では、**「内部ビジネスプロセスの視点」**に該当するKPIが問われています。これは、優れた製品やサービスを生み出すための**社内業務の効率や品質**に関する指標です。\n\n- **d: 注文受付から製品出荷までの日数を 3 日短縮する。**\n  これは、注文から出荷までという一連の業務プロセスの効率化（リードタイム短縮）を目指すものであり、まさに「内部ビジネスプロセスの視点」のKPIです。したがって、これが**正解**です。\n\n他の選択肢は以下の通りです。\n- **a:** 研修会の受講率は、従業員のスキル向上に関する指標であり、「学習と成長の視点」にあたります。\n- **b:** 売上高営業利益率は、企業の収益性を示す指標であり、「財務の視点」にあたります。\n- **c:** 顧客クレーム件数は、顧客満足度を示す指標であり、「顧客の視点」にあたります。"
    },
    {
      "qNo": 14,
      "text": "組込みシステム開発において, 製品に搭載する LSI を新規に開発する。LSI 設計を自社で行い, LSI 製造を外部に委託する場合の委託先として, 適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "IP プロバイダ"
        },
        {
          "id": "b",
          "text": "デザインハウス"
        },
        {
          "id": "c",
          "text": "ファウンドリ"
        },
        {
          "id": "d",
          "text": "ファブレスメーカ"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "LSI（大規模集積回路）の開発では、設計と製造を別の会社が担当する「水平分業」が一般的です。この問題は、その役割分担を理解しているかを問うています。\n\n*   **c: ファウンドリ (正解)**\n    ファウンドリは、半導体チップの**製造を専門に請け負う企業**やその工場のことを指します。自社で設計したLSIのデータを渡して、製造だけを委託する先に最も適しています。\n\n*   **a: IP プロバイダ**\n    LSIに組み込む特定の機能（CPUなど）の**設計情報（IP: Intellectual Property）を提供する企業**です。「設計」に関わるため、製造の委託先としては誤りです。\n\n*   **b: デザインハウス**\n    LSIの**設計そのものを専門に請け負う企業**です。問題文では「LSI設計を自社で行う」とあるため、委託先にはなりません。\n\n*   **d: ファブレスメーカ**\n    自社で製造工場（ファブ）を持たず、**LSIの設計や販売に特化する企業**のことです。この問題における「自社」がファブレスメーカに該当し、委託「先」ではありません。"
    },
    {
      "qNo": 15,
      "text": "ラボ契約の特徴はどれか。",
      "options": [
        {
          "id": "a",
          "text": "依頼元がベンダ企業側の作業担当者を指名して直接指揮命令を行う契約であり, ベンダ企業はこれを前提に要員を割り当てる。"
        },
        {
          "id": "b",
          "text": "依頼元は, 契約に基づきスキルや人数などの基準を満たすように要員を確保することをベンダ企業に求めるかわりに一定以上の発注を約束する。"
        },
        {
          "id": "c",
          "text": "開発したシステムによって依頼元が将来獲得する売上や利益をベンダ企業にも分配することを条件に, 開発時のベンダ企業への発注金額を抑える。"
        },
        {
          "id": "d",
          "text": "ベンダ企業が契約で定めた最低発注工数を下回って作業を完了した場合には, 実稼働工数に基づいて請求することが求められる。"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "正解は **b** です。\n\n**ラボ契約**とは、システム開発などで、一定期間、特定のスキルを持つエンジニアチーム（リソース）を自社専用に確保しておく契約形態です。「研究室（ラボ）」のように、必要な時にすぐ開発を依頼できるチームを準備しておくイメージです。\n\n*   **b (正解):** この選択肢は、ラボ契約の核心を的確に説明しています。依頼元は、必要なスキルを持つ人材をベンダに確保してもらう代わりに、毎月一定量の作業を発注することを約束します。これにより、依頼元は開発の柔軟性を確保し、ベンダは安定した収益を得ることができます。\n\n*   **a (誤り):** 依頼元がベンダの担当者に直接指揮命令するのは「労働者派遣契約」の特徴です。請負契約の一種であるラボ契約でこれを行うと、法律で禁じられている「偽装請負」と見なされる可能性があります。\n\n*   **c (誤り):** 開発したシステムの将来の利益を分け合う契約形態は「レベニューシェア契約」と呼ばれます。\n\n*   **d (誤り):** ラボ契約は、実際の作業量ではなく「確保したリソース（時間や人数）」に対して支払いが発生します。そのため、実作業が契約の最低工数を下回った場合でも、契約で定めた金額を支払うのが一般的です。"
    },
    {
      "qNo": 16,
      "text": "e シールの説明はどれか。",
      "options": [
        {
          "id": "a",
          "text": "インターネット上のゲーム内に限定されたキャラクターのイメージデータの作成者を証明する仕組みの一つである。"
        },
        {
          "id": "b",
          "text": "個人の意思表示や, 意思表示をしている個人の本人確認が必要な電子文書データについて, その電子文書データの作成者の証明と改ざん防止のために, 個人が行う電子署名である。"
        },
        {
          "id": "c",
          "text": "電子文書データの作成者の証明と改ざん防止のために, 重要文書を扱う国や地方自治体などの公共機関だけに使用が許可されている電子署名である。"
        },
        {
          "id": "d",
          "text": "法人が作成した電子文書データについて, その電子文書データの作成者が間違いなくその法人であり, かつその電子文書データは作成後に改ざんされていないことを証明するものである。"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "「eシール」とは、**組織（法人など）が発行する電子文書の信頼性を保証する仕組み**です。人間でいう「印鑑」に例えると、個人が行う「電子署名」が個人の「実印」にあたるのに対し、eシールは法人の「社印（角印）」のようなものとイメージすると分かりやすいでしょう。\n\n*   **d. (正解)**\n    この選択肢は、eシールの目的である「**法人が作成した**」ことの証明（発行元保証）と、「**改ざんされていない**」ことの証明（完全性保証）を正しく説明しています。請求書や領収書といった電子文書にeシールを付与することで、その書類が本物であることを証明できます。\n\n*   **a.**\n    ゲームキャラクターのデータなど、特定の用途に限定されるものではありません。\n\n*   **b.**\n    「**個人が行う**」とあるため、これは個人の身元を証明する「電子署名」の説明です。eシールは法人などの組織が主体となります。\n\n*   **c.**\n    「**公共機関だけ**」に限定されるものではなく、民間企業も利用できます。"
    },
    {
      "qNo": 17,
      "text": "マルチベクトル型 DDoS 攻撃に該当するものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "攻撃対象の Web サーバ 1 台に対して, 多数の PC から一斉にリクエストを送ってサーバのリソースを枯渇させる攻撃と, 大量の DNS 通信によってネットワークの帯域を消費する攻撃を同時に行う。"
        },
        {
          "id": "b",
          "text": "攻撃対象の Web サイトのログインパスワードを解読するために, ブルートフォースによるログイン試行を, 多数のスマートフォン, IoT 機器などから成るボットネットを踏み台にして一斉に行う。"
        },
        {
          "id": "c",
          "text": "攻撃対象のサーバに大量のレスポンスが同時に送り付けられるようにするために, 多数のオープンリゾルバに対して, 送信元 IP アドレスを攻撃対象のサーバの IP アドレスに偽装した名前解決のリクエストを一斉に送信する。"
        },
        {
          "id": "d",
          "text": "攻撃対象の組織内の多数の端末をマルウェアに感染させ, 当該マルウェアを遠隔操作することによってデータの改ざんやファイルの消去を一斉に行う。"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "正解は **a** です。\n\n**マルチベクトル型DDoS攻撃**とは、その名の通り「マルチ（複数）のベクトル（種類・経路）」で、**性質の異なる複数の攻撃を同時に仕掛ける**DDoS攻撃を指します。これにより、防御側は複数の攻撃に一度に対処する必要があり、対策が非常に困難になります。\n\n*   **a: 正解です。**\n    「Webサーバのリソースを枯渇させる攻撃」と「ネットワーク帯域を消費する攻撃」という、**2種類の異なる攻撃を同時に**行っています。これは、複数の攻撃手法を組み合わせるマルチベクトル型DDoS攻撃の典型例です。\n\n*   **b: 誤りです。**\n    ブルートフォース攻撃（総当たり攻撃）という単一の手法による攻撃であり、マルチベクトル型ではありません。\n\n*   **c: 誤りです。**\n    これはDNSリフレクション攻撃という、増幅型のDDoS攻撃の一種です。これも単一の手法であり、マルチベクトル型ではありません。\n\n*   **d: 誤りです。**\n    これはマルウェアによるデータの改ざんや消去を目的とした攻撃です。サーバやネットワークの機能を停止させるDDoS攻撃とは目的が異なります。"
    },
    {
      "qNo": 18,
      "text": "暗号方式に関する記述のうち, 適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "AES は公開鍵暗号方式, RSA は共通鍵暗号方式の一種である。"
        },
        {
          "id": "b",
          "text": "共通鍵暗号方式では, 暗号化及び復号に同一の鍵を使用する。"
        },
        {
          "id": "c",
          "text": "公開鍵暗号方式を通信内容の秘匿に使用する場合は, 暗号化に使用する鍵を秘密にして, 復号に使用する鍵を公開する。"
        },
        {
          "id": "d",
          "text": "デジタル署名に公開鍵暗号方式が使用されることはなく, 共通鍵暗号方式が使用される。"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "この問題は、暗号方式の基本的な種類と特徴について問うています。「共通鍵暗号方式」と「公開鍵暗号方式」の2つの違いを正しく理解することが重要です。\n\n*   **正解の選択肢（b）**\n    **共通鍵暗号方式**は、データの暗号化（読めなくする処理）と復号（元のデータに戻す処理）に、**全く同じ鍵（共通鍵）**を使用します。送信者と受信者が事前に同じ鍵を共有しておく必要があります。処理が高速であるというメリットがあります。したがって、この記述は正しいです。\n\n*   **その他の選択肢**\n    *   **a**: **AES**は**共通鍵暗号方式**、**RSA**は**公開鍵暗号方式**の代表的なアルゴリズムです。説明が逆になっているため誤りです。\n    *   **c**: **公開鍵暗号方式**で通信内容を秘密にする場合、誰でも入手できる「**公開鍵**」で暗号化し、受信者だけが持つ「**秘密鍵**」で復号します。鍵の役割の説明が逆になっているため誤りです。\n    *   **d**: **デジタル署名**は、文書の作成者が本人であることを証明し、改ざんがないことを保証する技術です。これには**公開鍵暗号方式**の仕組みが利用されます。そのため、この記述は誤りです。"
    },
    {
      "qNo": 19,
      "text": "CRYPTREC の役割として, 適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "外国為替及び外国貿易法で規制されている暗号装置の輸出許可申請を審査, 承認する。"
        },
        {
          "id": "b",
          "text": "政府調達において IT 関連製品のセキュリティ機能の適切性を評価, 認証する。"
        },
        {
          "id": "c",
          "text": "電子政府での利用を推奨する暗号技術の安全性をお評価, 監視する。"
        },
        {
          "id": "d",
          "text": "民間企業のサーバに対するセキュリティ攻撃を監視, 検知する。"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "CRYPTREC（クリプトレック）は、日本の電子政府で利用される暗号技術の安全性を評価・監視し、推奨する暗号のリストを作成・公表するプロジェクトです。総務省と経済産業省が共同で運営しています。\n\n-   **c: (正解)**\n    CRYPTRECの主な役割は、専門家が暗号アルゴリズムの安全性を評価し、安全と判断したものを「電子政府推奨暗号リスト」として公開することです。これにより、政府機関などが安心して利用できる暗号技術の基準を示しています。したがって、この選択肢が最も的確にCRYPTRECの役割を説明しています。\n\n-   **a: (誤り)**\n    暗号装置などの輸出許可を審査・承認するのは、**経済産業省**の役割です。\n\n-   **b: (誤り)**\n    政府が調達するIT製品のセキュリティ機能を評価・認証するのは、**JISEC**（ITセキュリティ評価及び認証制度）の役割です。これは、国際標準であるコモンクライテリアに基づいて行われます。\n\n-   **d: (誤り)**\n    セキュリティ攻撃の監視や検知、インシデント対応支援などを行うのは、**JPCERT/CC**などのCSIRT（シーサート）や、企業の**SOC**（セキュリティオペレーションセンター）の役割です。"
    },
    {
      "qNo": 20,
      "text": "インターネットとの接続において, ファイアウォールの NAPT 機能によるセキュリティ上の効果はどれか。",
      "options": [
        {
          "id": "a",
          "text": "DMZ 上にある公開 Web サーバの脆弱性を悪用する攻撃を防御できる。"
        },
        {
          "id": "b",
          "text": "インターネットから内部ネットワークへの侵入を検知し, 検知後の通信を遮断できる。"
        },
        {
          "id": "c",
          "text": "インターネット上の特定の Web サービスを利用する HTTP 通信を検知し, 遮断できる。"
        },
        {
          "id": "d",
          "text": "内部ネットワークからインターネットにアクセスする利用者 PC について, インターネットからの不正アクセスを困難にすることができる。"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "この問題のポイントは、**NAPT（Network Address Port Translation）**の仕組みを理解しているかです。NAPTは、複数のプライベートIPアドレスを一つのグローバルIPアドレスに変換して、インターネットと通信する技術です。\n\n- **d. 正解です。**\n    NAPTを利用すると、内部ネットワークにあるPCのプライベートIPアドレスは、ファイアウォール（ルータなど）のグローバルIPアドレスに変換されます。そのため、インターネット側からは個々のPCの存在が直接見えなくなり、どのPCを攻撃すればよいか分かりません。このように、IPアドレスを隠蔽（いんぺい）することで、外部からの不正アクセスを困難にする効果があります。\n\n- **a. 誤りです。**\n    Webサーバの脆弱性を悪用する攻撃（アプリケーション層への攻撃）を防ぐのは、WAF（Web Application Firewall）の役割です。NAPTはIPアドレスを変換するだけで、通信の中身までは監視しません。\n\n- **b. 誤りです。**\n    通信を監視して侵入を検知・遮断するのは、IDS（侵入検知システム）やIPS（侵入防止システム）の機能です。\n\n- **c. 誤りです。**\n    特定のWebサービスへのアクセスを遮断するのは、URLフィルタリングやプロキシサーバの機能です。"
    },
    {
      "qNo": 21,
      "text": "容量が a Mバイトでアクセス時間が x ナノ秒の命令キャッシュと, 容量が b Mバイトでアクセス時間が y ナノ秒の主記憶をもつシステムにおいて, CPU からみた, 主記憶と命令キャッシュとを合わせた平均アクセス時間を表す式はどれか。ここで, 読み込みたい命令コードが命令キャッシュに存在しない確率を r とし, キャッシュ管理に関するオーバヘッドは無視できるものとする。",
      "options": [
        {
          "id": "a",
          "text": "((1 - r)・a) / (a + b)・x + (r・b) / (a + b)・y"
        },
        {
          "id": "b",
          "text": "(1 - r)・x + r・y"
        },
        {
          "id": "c",
          "text": "(r・a) / (a + b)・x + ((1 - r)・b) / (a + b)・y"
        },
        {
          "id": "d",
          "text": "r・x + (1 - r)・y"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "CPUから見た平均アクセス時間は、「キャッシュにデータが見つかる場合」と「見つからない場合」のそれぞれのアクセス時間を、その発生確率に応じて足し合わせることで求められます。\n\n-   **キャッシュにデータが見つかる場合（キャッシュヒット）**\n    -   問題文より、キャッシュに\"ない\"確率が `r` なので、\"ある\"確率は `1 - r` となります。\n    -   この場合、高速な命令キャッシュから読み込むため、アクセス時間は `x` です。\n    -   このケースのアクセス時間は `(1 - r) × x` と計算できます。\n\n-   **キャッシュにデータが見つからない場合（キャッシュミス）**\n    -   その確率は `r` です。\n    -   この場合、低速な主記憶から読み込むため、アクセス時間は `y` です。\n    -   このケースのアクセス時間は `r × y` と計算できます。\n\nこれら2つのケースを合計したものが平均アクセス時間となるため、式は **`(1 - r)・x + r・y`** となります。\nしたがって、**b**が正解です。\n\n-   **a, c**：キャッシュ容量 `a` や主記憶容量 `b` は、ヒット率（またはミスヒット率 `r`）が既に与えられているため、平均アクセス時間の計算には不要な情報です。\n-   **d**：ヒット率 `(1 - r)` とミスヒット率 `r` を、アクセス時間 `x` と `y` に逆にかけてしまっているため誤りです。"
    },
    {
      "qNo": 22,
      "text": "データベースサーバのクラスタリング技術の特徴のうち, シェアードエブリシングはどれか。",
      "options": [
        {
          "id": "a",
          "text": "クラスタリング構成にして可用性を高めることによって, 故障発生時に担当していた範囲のデータを待機系のサーバに引き継ぐことができる。"
        },
        {
          "id": "b",
          "text": "サーバごとに管理する対象データが決まっているので, 1 台のサーバに故障が発生すると故障したサーバが管理する対象データを処理できなくなり, システム全体の可用性が低下する。"
        },
        {
          "id": "c",
          "text": "データを複数の磁気ディスクに分割配置し, 更にサーバと磁気ディスクが 1 対 1 に対応しているので, 複数サーバを用いた並列処理が可能になる。"
        },
        {
          "id": "d",
          "text": "負荷を分散し, 全てのサーバのリソースを有効活用できることに加えて, データを共有することによって 1 台のサーバに故障が発生したときでも処理を継続することができる。"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "この問題は、データベースのクラスタリング方式の一つである「シェアードエブリシング」の特徴を理解しているかを問うています。クラスタリングとは、複数のコンピュータ（サーバ）を連携させて、信頼性や処理能力を高める技術です。\n\n**正解は選択肢dです。**\n- **シェアードエブリシング (Shared Everything)**\n  その名の通り、複数のサーバがCPU以外の**全てのリソース（メモリやディスク）を完全に共有**する方式です。\n- **なぜdが正しいのか**\n  全てのサーバが同じデータ・メモリにアクセスできるため、どのサーバでも同じ処理が可能です。これにより、負荷を分散しやすく、リソースを無駄なく活用できます。また、1台のサーバが故障しても、他のサーバが共有データを使って処理をそのまま引き継げるため、可用性（システムが停止しない能力）が高まります。選択肢dは、この特徴を的確に説明しています。\n\n**その他の選択肢について:**\n- **a:** 故障時に処理を引き継ぐ（フェイルオーバー）のは、可用性を高めるクラスタリング全般に共通する特徴であり、シェアードエブリシング固有の説明ではありません。\n- **b, c:** 「サーバごとに管理する対象データが決まっている」「サーバと磁気ディスクが1対1」という記述は、各サーバが独立したディスクを持つ**シェアードナッシング**方式の特徴です。この方式では、サーバ間でリソースを共有しません。"
    },
    {
      "qNo": 23,
      "text": "幾つかのサブシステムから成るシステムの信頼性に関する記述のうち, 適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "あるサブシステムで発生したフォールトの影響が他のサブシステムに波及することを防ぐフォールトマスクは, システムの MTBF は変化させないが, MTTR の短縮につながる。"
        },
        {
          "id": "b",
          "text": "サブシステムにフォールトが検出されたとき, 再試行すると正しい結果が得られる場合もあるので, 再試行はシステムの MTBF の向上と MTTR の短縮につながる。"
        },
        {
          "id": "c",
          "text": "サブシステムの稼働中に行われるフォールトの検出は, システムを停止せず行われるので, システムの MTTR は変化させないが, MTBF の向上につながる。"
        },
        {
          "id": "d",
          "text": "フォールトが発生したあるサブシステムを切り離して, 待機系のサブシステムに自動で切り替えるフェールオーバは, システムの MTBF は変化させないが, MTTR の短縮につながる。"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "この問題は、システムの信頼性指標であるMTBFとMTTRが、どのような対策によって影響を受けるかを理解することがポイントです。\n\n- **MTBF (Mean Time Between Failures / 平均故障間隔)**\n  故障から次の故障までの平均時間。長いほど「故障しにくい」ことを示します。\n- **MTTR (Mean Time To Repair / 平均修復時間)**\n  故障が発生してから復旧するまでの平均時間。短いほど「復旧が速い」ことを示します。\n\n### 正解の選択肢 (d)\n**フェールオーバ**は、稼働中のサブシステムが故障した際に、瞬時に待機していたサブシステムに処理を自動で引き継ぐ仕組みです。\n- 利用者から見ると、システムが停止している時間が非常に短くなるため、**MTTR（平均修復時間）は大幅に短縮**されます。\n- 一方で、フェールオーバは故障した後の対策であり、サブシステム自体が故障する頻度（発生間隔）を変えるものではないため、**MTBF（平均故障間隔）は変化しません**。\nしたがって、この記述は正しいです。\n\n### その他の選択肢\n- **a**: フォールトマスクは、故障の影響を内部で隠蔽し、システム全体としては正常に動作し続ける技術です。これにより、システムダウンに至るまでの時間が長くなるため、**MTBFは向上します**。\n- **b**: 再試行は、一時的なエラーを乗り越え、システムダウンを防ぐ効果があります。これも結果的に故障の発生間隔を延ばすため、**MTBFは向上します**。MTTR（修理時間）には直接影響しません。\n- **c**: フォールト（故障の要因）を検出するだけでは、故障の発生頻度は変わりません。そのため、**MTBFは向上しません**。早期検出により、修理を早く開始できるため、MTTRの短縮につながる可能性はあります。"
    },
    {
      "qNo": 24,
      "text": "t1～t10 の時刻でスケジュールされたトランザクション T1～T4 がある。時刻 t10 で T1 が commit を発行する直前の, トランザクションの待ちグラフを作成した。a に当てはまるトランザクションはどれか。ここで, select (X) は共有ロックを掛けて資源 X を参照することを表し, update (X) は専有ロックを掛けて資源 X を更新することを表す。これらのロックは, commit された時にアンロックされるものとする。また, トランザクションの待ちグラフの矢印は, Ti→Tj としたとき, Tj がロックしている資源のアンロックを, Ti が待つことを表す。\n\n[トランザクションのスケジュール]\n| 時刻 | T1 | T2 | T3 | T4 |\n|---|---|---|---|---|\n| t1 | select (A) | - | - | - |\n| t2 | - | select (B) | - | - |\n| t3 | - | - | select (B) | - |\n| t4 | - | - | - | select (A) |\n| t5 | - | - | - | update (B) |\n| t6 | select (C) | - | - | - |\n| t7 | - | select (C) | - | - |\n| t8 | - | update (C) | - | - |\n| t9 | - | - | update (A) | - |\n| t10 | commit | - | - | - |\n\n[トランザクションの待ちグラフ]\n```mermaid\ngraph TD\n    d((d)) --> a((a))\n    a --> b((b))\n    b --> c((c))\n    c --> a\n```",
      "options": [
        {
          "id": "a",
          "text": "T1"
        },
        {
          "id": "b",
          "text": "T2"
        },
        {
          "id": "c",
          "text": "T3"
        },
        {
          "id": "d",
          "text": "T4"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "本問は、トランザクションのスケジュールから待ちグラフを読み解く問題です。まず、各トランザクションがどの資源のロックを待ち、どのトランザクションを待っているのかを整理しましょう。\n\n- **ロックの基本**\n    - **共有ロック(`select`)**: 複数のトランザクションが同時に読み取りできます。\n    - **専有ロック(`update`)**: 1つのトランザクションしか利用できず、他のロック（共有・専有）とは共存できません。\n\n- **待ち関係の整理**\n    1.  **T4**は資源Bを更新したい(`t5`)ですが、T2とT3が共有ロック中です。→ **T4はT2とT3を待ちます**。\n    2.  **T2**は資源Cを更新したい(`t8`)ですが、T1が共有ロック中です。→ **T2はT1を待ちます**。\n    3.  **T3**は資源Aを更新したい(`t9`)ですが、T1とT4が共有ロック中です。→ **T3はT1とT4を待ちます**。\n\n- **グラフの分析**\n    - 問題の待ちグラフ `d→a→b→c→a` は、`a`, `b`, `c` の3者でデッドロック（待ち状態のサイクル）が発生していることを示しています。\n    - **a = T2（正解）**: `a` に `T2` を当てはめてみましょう。\n        - `a → b` は `T2 → b` となります。上記の通り `T2` が待つのは `T1` なので、**`b = T1`** と特定できます。\n        - `c → a` や `d → a` は、他のトランザクションが `T2` を待つ状態を示します。上記の通り `T4` が `T2` を待つため、`c` や `d` は `T4` に関連します。\n        - このように、`a=T2` と仮定すると、グラフの各要素を実際の待ち関係と論理的に対応付けられます。\n\n- **他の選択肢の検討**\n    - `a = T1` とすると、`T1` はどのトランザクションも待っていないため、`a → b` の矢印が成立せず誤りです。\n    - `a = T3` や `a = T4` の場合、待つ相手が複数いるため、単純なサイクル構造にうまく当てはまりません。"
    },
    {
      "qNo": 25,
      "text": "図は, 既存の電話機と PBX を使用した企業内の内線網を, IP ネットワークに統合する場合の接続構成を示している。図中の a～c に該当する装置の適切な組合せはどれか。\n\n```mermaid\ngraph LR\n    tel[電話機] --- a[a]\n    a --- b[b]\n    b --- c[c]\n    c --- ip((IP ネットワーク))\n```\n\n| | a | b | c |\n|---|---|---|---|\n| ア | PBX | VoIP ゲートウェイ | ルータ |\n| イ | PBX | ルータ | VoIP ゲートウェイ |\n| ウ | VoIP ゲートウェイ | PBX | ルータ |\n| エ | VoIP ゲートウェイ | ルータ | PBX |",
      "options": [
        {
          "id": "a",
          "text": "ア"
        },
        {
          "id": "b",
          "text": "イ"
        },
        {
          "id": "c",
          "text": "ウ"
        },
        {
          "id": "d",
          "text": "エ"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "この問題は、既存の電話網をIPネットワークに統合する際の機器の接続順序を問うています。正解は **ア** です。\n\n各装置の役割と接続順序を順に見ていきましょう。\n\n1.  **a: PBX (構内交換機)**\n    *   まず、既存の電話機は、社内の内線電話の交換・制御を行う **PBX** に接続されます。問題文に「既存の電話機とPBXを使用」とあるため、電話機の次に来るのはPBXです。\n\n2.  **b: VoIPゲートウェイ**\n    *   次に、PBXが扱う電話用の信号（アナログ信号など）を、IPネットワークで送受信できる形式（IPパケット）に変換する必要があります。この役割を担うのが **VoIPゲートウェイ** です。PBXとIPネットワークの橋渡しをします。\n\n3.  **c: ルータ**\n    *   最後に、VoIPゲートウェイで変換されたIPパケットを、社内ネットワークから外部のIPネットワークへ中継するために **ルータ** が必要です。\n\nしたがって、「電話機 → **a:PBX** → **b:VoIPゲートウェイ** → **c:ルータ** → IPネットワーク」という接続順が正しくなります。他の選択肢は、これらの機器の役割や接続順序が誤っているため、不正解となります。"
    }
  ]
}