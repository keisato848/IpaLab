{
  "questions": [
    {
      "qNo": 1,
      "theme": "データ構造とアルゴリズム（グラフ理論）",
      "description": "L社では、特定の業務処理における経路探索の効率化を図るため、グラフ理論に基づくアルゴリズムの適用可能性を評価している。特に、有向グラフにおけるオイラー路を見つけるための探索アルゴリズムについて検討を進めており、その実装の一部として図4の擬似コードが提示された。以下の設問に答えよ。",
      "context": {
        "title": "有向グラフにおけるオイラー路探索アルゴリズムの実装と検証",
        "background": "L社では、特定の業務処理における経路探索の効率化を図るため、グラフ理論に基づくアルゴリズムの適用可能性を評価している。特に、有向グラフにおけるオイラー路を見つけるための探索アルゴリズム（Hierholzerのアルゴリズムに基づいた再帰的な回路分解）について検討を進めており、その実装の一部として{{diagram:fig4}}の擬似コードが提示された。\n\nこのアルゴリズムでは、グラフの構造と探索の状態を管理するために{{diagram:table2}}に示す配列を使用する。以下の設問に答えよ。\n\nこの問題は、有向グラフにおける特定の経路探索アルゴリズム（関数 directedE）に関するものである。設問では、{{diagram:fig1}}に示すグラフ構造に基づき、このアルゴリズムの動作回数を問うている。具体的な背景説明や、アルゴリズムの定義は原文から提供されていないため、設問2の解析に必要な情報のみを構造化する。\n\nこの設問は、強連結な有向グラフにおけるオイラー路の存在条件と、特定のアルゴリズム（`directedE` 関数）の動作に関する知識を問うものです。前提として、強連結なグラフとは任意の2点間を互いに行き来できる経路が存在するグラフであり、オイラー閉路（一筆書きで出発点に戻る経路）が存在するためには、すべての頂点において入次数と出次数が等しいことが必要です。関数 `directedE` の具体的な定義（擬似コードなど）は提供されていませんが、解説文から回路分解の手法を用いることが示唆されています。\n\nL社では、特定のネットワークにおける効率的な経路探索アルゴリズムを開発している。このアルゴリズムは、強連結グラフに対して深さ優先探索（DFS）をベースにした手順を用いて経路を確定する。\n\n## 図4 経路探索プログラム\n\n{{diagram:fig4}}\n\nこのプログラムは、探索中のノードを管理するために配列 `searched` を使用していたが、メモリ使用量を削減するために、この配列を `path` 配列に統合することが検討されている。\n以下の設問に答えよ。（設問1～設問3は省略）",
        "diagrams": [
          {
            "id": "table2",
            "label": "表2 探索アルゴリズムで使用する配列の定義",
            "type": "markdown",
            "content": "| 配列 | 定義 |\n|---|---|\n| current[n] | 点nを始点とする未探索の辺の中で最小の番号 (辺がない場合は0) |\n| edgenext[m] | 接続辺mの次の接続辺の番号 |\n| start[m] | 辺mの始点の番号 |"
          },
          {
            "id": "fig4",
            "label": "図4 オイラー路探索の擬似コード (一部省略)",
            "type": "markdown",
            "content": "\nprocedure SearchEulerPath(x):\n  if ( current[x] が [ ア ] でない) then\n    temp <- current[x]\n    current[x] <- [ イ ]\n    SearchEulerPath(end[temp]) // end[temp] は辺tempの終点\n  else\n    top <- [ ウ ]\n    temp <- searched[top]\n  end if\n  \n  path[path_len] <- temp\n  path_len <- path_len + 1\n  x <- [ エ ]\n  searched[top] <- temp\n  // ... (その他の処理)\nend procedure\n"
          },
          {
            "id": "fig1",
            "label": "図1 グラフの構成",
            "type": "image",
            "content": "グラフの構造（具体的な頂点と辺の構成）は、入力データに含まれていません。"
          },
          {
            "id": "fig4",
            "label": "図4 経路探索プログラム（一部）",
            "type": "image",
            "content": "図4の内容は提供されていませんが、配列 searched を path に置き換える最適化が行われるプログラムである。"
          }
        ]
      },
      "questions": [
        {
          "subQNo": "設問1",
          "text": "図4中の [ ア ] ~ [ エ ] に入れる適切な字句を答えよ。",
          "references": [
            "fig4",
            "table2"
          ],
          "subQuestions": [
            {
              "label": "ア",
              "text": "[ ア ] に入れる字句を答えよ。",
              "answer": "0",
              "explanation": "`if ( current[x] が [ ア ] でない)` は、現在の点 `x` を始点とする未探索の辺があるかどうかを判断しています。配列 `current[n]` は、点 `n` を始点とする未探索の辺の中で最小の番号を格納し、辺がない場合は0を格納すると定義されています（表2）。したがって、未探索の辺が存在しない状態を示す値は0です。"
            },
            {
              "label": "イ",
              "text": "[ イ ] に入れる字句を答えよ。",
              "answer": "edgenext[temp]",
              "explanation": "辺 `temp` を探索済みの経路に登録した後、次に点 `x` からたどるべき未探索の辺を `current[x]` に格納する必要があります。これは、辺 `temp` の「次の接続辺」です。表2の定義より、接続辺 `m` の次の接続辺の番号は `edgenext[m]` に格納されています。"
            },
            {
              "label": "ウ",
              "text": "[ ウ ] に入れる字句を答えよ。",
              "answer": "top - 1",
              "explanation": "`else` ブロックは、点 `x` から先に進む未探索の辺がない場合（行き止まり）、探索済みの経路を遡る（バックトラックする）処理です。配列 `searched` は探索済みの辺を順に格納しており、`top` は次に格納する位置（すなわち現在の探索深さ+1）を示します。遡る際は、まず `top` を1つ減らして、直前の辺を取り出す必要があります。"
            },
            {
              "label": "エ",
              "text": "[ エ ] に入れる字句を答えよ。",
              "answer": "start[temp]",
              "explanation": "遡った辺 `temp` を確定済みの経路 `path` に格納した後、探索を再開する新たな出発点 `x` を設定します。新たな出発点は、遡った辺 `temp` の「始点」でなければなりません（手順(3)を参照）。辺 `m` の始点の番号は `start[m]` に格納されています（表2）。"
            }
          ],
          "point": 25
        },
        {
          "subQNo": "設問2",
          "text": "図1のグラフで関数 directedE を動作させたとき, while 文中の if 文は、何回実行されるか、数値で答えよ。",
          "references": [
            "fig1"
          ],
          "answer": "8",
          "explanation": "### 設問2の解説\n`while` 文中の `if` 文は、新しい未探索の辺 `temp` が見つかったときに実行されます。この処理は、見つかった辺を `searched` 配列に登録し、次の点に進む操作です。\n\nグラフの全ての辺の個数 $M$ は8です。このアルゴリズムは、グラフの全ての辺を探索済みの経路に登録する（つまり $searched$ に格納する）まで、探索を続けます。探索済みの辺は、最終的に確定済みの経路 $path$ に移動されますが、`if` 文の実行回数は、新しい辺が探索経路に追加された回数と等しいです。\n\n一筆書きの経路探索では、全ての辺を1回ずつ通るので、`if` 文は全ての辺に対して1回ずつ実行されます。\n\n$$ M = 8 $$ \n\n**答え:** 8",
          "subQuestions": [],
          "point": 25
        },
        {
          "subQNo": "設問3",
          "text": "一筆書きができない強連結な有向グラフで関数 directedE を動作させたとき,探索はどのようになるかを、解答群の中から選び、記号で答えよ。",
          "references": [],
          "answer": "ア",
          "explanation": "強連結な有向グラフとは、任意の2点間を互いに行き来できる経路が存在するグラフです。本問における「一筆書きができるグラフ」は、すべての辺を1回だけ通り、出発点に戻る閉じた経路（オイラー閉路）を持つグラフを指します。オイラー閉路が存在するための必要十分条件は、すべての頂点において入次数と出次数が等しいことです。\n\nもしグラフが強連結であるが、一筆書きができない（オイラー閉路が存在しない）場合、これは特定の頂点において入次数と出次数が等しくないことを意味します。しかし、強連結性があるため、すべての辺は必ず何らかの閉路の一部となり、出発点からすべての辺をたどり切ることが可能です（オイラー路は存在する可能性があります）。\n\nこの `directedE` 関数は、探索済みの経路を遡りながら、未探索の辺を持つ点から新たな閉路を見つけて連結していく、回路分解の手法を採用しています。強連結なグラフでは、必ず全ての辺が探索され、最終的に $M$ 個の辺がすべて $path$ 配列に格納されます。したがって、探索は完了します。\n\nしかし、グラフ全体が一筆書きの経路の定義（出発点に戻る閉路）を満たさない場合、アルゴリズムが発見した $path$ はすべての辺を通っていますが、それは「一筆書きの経路」（オイラー閉路）の定義を満たさない可能性があります。\n\n【解答群】\n\n**ア** 探索が完了するが、配列 path に格納された経路は一筆書きの経路にならない。\n**イ** 探索が完了せずに終了して、配列 path に格納された経路は一筆書きの経路にならない。\n**ウ** 探索が無限ループに陥り、探索が終了しない。\n\n強連結性により全ての辺は探索されるため、探索は完了し、結果として $M$ 個の辺が $path$ に格納されます。しかし、グラフがオイラー閉路の条件を満たさないため、得られた経路は「一筆書きの経路」とは言えません。\n\n答え: ア",
          "subQuestions": [],
          "point": 25
        },
        {
          "subQNo": "設問4",
          "text": "図4のプログラムは、配列 searched を配列 path に置き換えることで、使用する領域を減らすことができる。このとき、無駄な繰返しが発生しないように、下線①の繰返し条件を、変数 topとlast を用いて変更せよ。",
          "references": [
            "fig4"
          ],
          "answer": "top > 1",
          "explanation": "### 設問4の解説\n配列 `searched` を廃止し、`path` 配列が探索中のスタック（$1$ から $top-1$）と確定済みの経路（$last$ から $M$）の両方を担うようにすると、メモリ使用量を削減できます。\n\n従来の構造では `while (last が 1 以上)` という条件で、確定済みの経路が $M$ 個全て埋まるまでループを回していました。しかし、もし探索が完了し、全ての辺を遡って（バックトラックして）`top` が1に戻ってしまった場合、`current[x]` は0となり `else` ブロックに入ります。このとき、`top ← top - 1` により `top` が0になり、次の `temp ← searched[top]`（または `path[top]`）でインデックスエラーが発生するか、あるいは `top` が1以上にとどまり続けた場合に、無限に同じ処理を繰り返す「無駄な繰返し」が発生する可能性があります。\n\n探索が終了し、バックトラック処理も完了した状態は、確定すべき辺がない（$last=0$）か、あるいはこれ以上遡る辺がない（$top=1$）状態です。\n\n全ての辺が確定する、つまり $last$ が0になるまでループを続行しつつ、探索経路のスタックが空（$top=1$）になったら、それ以上遡り処理を続けないようにする必要があります。遡り処理は `else` ブロックで行われるため、`else` ブロックに `if (top > 1)` のチェックを追加するのが最も自然ですが、ここでは `while` 条件の変更が求められています。\n\nグラフが強連結であるため、最終的には $last$ は0になります。無駄な繰返し（`top` が1で `else` に入り続けること）を避けるためには、**スタックが空でない** 状態をループ条件に含める必要があります。\n\n探索を続行すべき条件は、以下のいずれかです。\n1. 確定すべき辺が残っている ($last \\ge 1$)\n2. 探索中の経路スタックに辺が残っている ($top > 1$)\n\nもし $top=1$ で $last \\ge 1$ の状態になった場合、これは現在の始点1から探索を開始できない（`current[1]=0`）が、まだ確定すべき辺が残っていることを示しますが、強連結グラフの性質上、この状態は通常、最終的な終了直前（$last=1, top=2$ の状態から $last=0, top=1$ に移行する瞬間）を除いて発生しません。しかし、安全性を担保するためには、スタックが空ではないことを条件に含めるべきです。\n\n**答え:** `top > 1`",
          "subQuestions": [],
          "point": 25
        }
      ]
    }
  ]
}