{
  "qNo": 3,
  "theme": "プログラミング (一筆書き)",
  "description": "グラフは、有限個の点の集合と、その中の2点を結ぶ辺の集合から成る数理モデルである。グラフの点と点の間をつなぐ辺の列のことを経路という。本問では、任意の2点間で、辺をたどることで互いに行き来することができる経路が存在する(以下,強連結という)有向グラフを扱う。強連結な有向グラフの例を図1に示す。辺は始点と終点の組で定義する。各辺には1から始まる番号が付けられている。\n\n## 図1 強連結な有向グラフの例\n```mermaid\ngraph TD\n    a -->|1| b\n    b -->|2| c\n    c -->|3| d\n    d -->|4| a\n    b -->|5| e\n    e -->|6| d\n    d -->|7| f\n    f -->|8| b\n```\n\n凡例 辺=(辺の始点,辺の終点)\n\n[一筆書き]\n本問では、グラフの全ての辺を1回だけ通り、出発点から出て出発点に戻る閉じた経路をもつグラフを、一筆書きができるグラフとする。\n\n[一筆書きの経路の求め方]\n一筆書きの経路を求めるためには、出発点から辺の向きに従って辺を順番にたどり、出発点に戻る経路を見つける探索を行う。たどった経路(以下,探索済の経路という)について、グラフ全体で通過していない辺(以下,未探索の辺という)がない場合は、この経路が一筆書きの経路となる。未探索の辺が残っている場合は、探索済の経路を、未探索の辺が接続する点まで遡り,その点を出発点として、同じ点に戻る経路を見つけて、遡る前までの経路に連結することを繰り返す。\n各点を始点とする辺を接続辺という。グラフの各点に対して接続辺の集合が決まり、辺の番号が一番小さい接続辺を最初の接続辺という。同じ始点をもつ接続辺の集合で,辺の番号を小さいものから順番に並べたときに、辺の番号が次に大きい接続辺を次の接続辺ということにする。\n図1のグラフの各点の接続辺の集合を表1に示す。図1において,点bの最初の接続辺は辺2である。辺2の次の接続辺は辺5となる。辺5の次の接続辺はない。\n\n## 表1 図1のグラフの各点の接続辺の集合\n| 点 | 接続辺の集合 |\n| :--- | :--- |\n| 点a | 辺1 |\n| 点b | 辺2, 辺5 |\n| 点c | 辺3 |\n| 点d | 辺4, 辺7 |\n| 点e | 辺6 |\n| 点f | 辺8 |\n\n一筆書きの経路の探索において、一つの点に複数の接続辺がある場合には、最初の接続辺から順にたどることにする。\n図1のグラフで点aを出発点とした一筆書きの経路の求め方を図2に示す。\n経路を構成する辺とその順番が、これ以上変わらない場合,確定済の経路という。\n\n[図2: 図1のグラフで点aを出発点とした一筆書きの経路の求め方 (探索ステップ [1]～[4])]\n\n図2を参考にした一筆書きの経路を求める手順を次に示す。\n\n[一筆書きの経路を求める手順]\n(1) 一筆書きの経路の出発点を決める。\n(2) 出発点から、未探索の辺が存在する限り、その辺をたどり、たどった経路を探索済の経路に追加する。\n(3) 探索済の経路を未探索の辺が接続する点又は一筆書きの経路の出発点まで遡る。遡った経路は、探索済の経路から確定済の経路にする。未探索の辺が接続する点がある場合は、それを新たな出発点として、(2)に戻って新たな経路を見つける。\n(4) 全ての辺が確定済の経路になった時点で探索が完了して、その確定済の経路が一筆書きの経路になる。\n\n[一筆書きの経路を求めるプログラム]\n一筆書きの経路を求める関数 directedEのプログラムを作成した。\n実装に当たって、各点を点n (nは1~N) と記す。例えば、図1のグラフでは、点aは点1,点bは点2と記す。\nグラフの探索のために、あらかじめ、グラフの点に対する最初の接続辺の配列edgefirst 及び接続辺に対する次の接続辺の配列 edgenext を用意しておく。edgenextにおいて、次の接続辺がない場合は、要素に0を格納する。\n図1のグラフの場合の配列 edgefirst, edgenextを図3に示す。\n\n## 図3 図1のグラフの場合の配列 edgefirst, edgenext\n| | 点1 | 2 | 3 | 4 | 5 | 6 |\n| :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n| edgefirst | 1 | 2 | 3 | 4 | 6 | 8 |\n\n| | 辺1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |\n| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n| edgenext | 0 | 5 | 0 | 7 | 0 | 0 | 0 | 0 |\n\n注記 edgefirst にはグラフの点に対する最初の接続辺の番号を格納している。edgenext には接続辺の次の接続辺の番号を格納している。\n\nedgefirst によって点2の最初の接続辺が辺2であることが分かり、点2から最初にたどる接続辺は辺2となる。edgenext によって、辺2の次の接続辺が辺5であることが分かるので、点2から次にたどる接続辺は辺5となる。辺5の次の接続辺はないので、点2からたどる接続辺はこれ以上ないことが分かる。\n\nプログラム中で使用する定数と配列を表2に、作成した関数 directedE のプログラムを図4に示す。\n全ての配列の添字は1から始まる。\n\n## 表2 使用する定数と配列\n| 名称 | 種類 | 内容 |\n| :--- | :--- | :--- |\n| N | 定数 | グラフの点の個数 |\n| M | 定数 | グラフの辺の個数 |\n| start[m] | 配列 | start[m] には、辺 m の始点の番号が格納されている。 |\n| end[m] | 配列 | end[m] には、辺 m の終点の番号が格納されている。 |\n| edgefirst[n] | 配列 | edgefirst[n] には、点 n の最初の接続辺の番号が格納されている。 |\n| edgenext[m] | 配列 | edgenext[m] には、辺 m の次の接続辺の番号が格納されている。次の接続辺がない場合は 0 が格納されている。 |\n| current[n] | 配列 | current[n] には、点 n を始点とする未探索の辺の中で最小の番号を格納する。点 n を始点とする未探索の辺がない場合は 0 を格納する。 |\n| searched[m] | 配列 | 一筆書きの経路を構成する探索済の辺の番号を順番に格納する。(探索済の経路) |\n| path[m] | 配列 | 一筆書きの経路を構成する確定済の辺の番号を順番に格納する。(確定済の経路) |\n\n## 図4 関数 directedE のプログラム\n```pseudocode\nfunction directedE()\nfor( i を 1 から N まで 1 ずつ増やす ) // 各点での未探索の辺の番号を初期化\n    current[i] ← edgefirst[i]\nendfor\ntop ← 1      // 探索済の経路の辺の格納位置を初期化\nlast ← M     // 確定済の経路の辺の格納位置を初期化\nx ← 1        // 出発点は点1\nwhile ( last が 1 以上 ) // ①\n    if ( current[x] が [ ア ] でない)\n        temp ← current[x] // 点 x からたどる接続辺は temp\n        searched[top] ← temp // 接続辺 temp を探索済の経路に登録\n        current[x] ← [ イ ] // 点 x から次にたどる未探索の辺を格納\n        x ← end[temp] // 接続辺 temp の終点を点 x にする\n        top ← top + 1\n    else\n        top ← [ ウ ] // 探索済の辺を遡る\n        temp ← searched[top] // 遡った辺は temp\n        path[last] ← temp // 辺 temp を確定済にする\n        x ← [ エ ]\n        last ← last - 1\n    endif\nendwhile\nendfunction\n```",
  "questions": [
    {
      "subQNo": "設問1",
      "text": "図4中の [ ア ] ~ [ エ ] に入れる適切な字句を答えよ。",
      "explanation": "### 設問1の解説\nこの問題は、有向グラフにおけるオイラー路（一筆書きの経路）を見つけるための探索アルゴリズム（Hierholzerのアルゴリズムに基づいた再帰的な回路分解）の擬似コードを完成させるものです。\n\n#### [ ア ] について\n`if ( current[x] が [ ア ] でない)` は、現在の点 `x` を始点とする未探索の辺があるかどうかを判断しています。配列 `current[n]` は、点 `n` を始点とする未探索の辺の中で最小の番号を格納し、辺がない場合は0を格納すると定義されています（表2）。したがって、未探索の辺が存在しない状態を示す値は0です。\n\n**答え:** `0`\n\n#### [ イ ] について\n辺 `temp` を探索済みの経路に登録した後、次に点 `x` からたどるべき未探索の辺を `current[x]` に格納する必要があります。これは、辺 `temp` の「次の接続辺」です。表2の定義より、接続辺 `m` の次の接続辺の番号は `edgenext[m]` に格納されています。\n\n**答え:** `edgenext[temp]`\n\n#### [ ウ ] について\n`else` ブロックは、点 `x` から先に進む未探索の辺がない場合（行き止まり）、探索済みの経路を遡る（バックトラックする）処理です。配列 `searched` は探索済みの辺を順に格納しており、`top` は次に格納する位置（すなわち現在の探索深さ+1）を示します。遡る際は、まず `top` を1つ減らして、直前の辺を取り出す必要があります。\n\n**答え:** `top - 1`\n\n#### [ エ ] について\n遡った辺 `temp` を確定済みの経路 `path` に格納した後、探索を再開する新たな出発点 `x` を設定します。新たな出発点は、遡った辺 `temp` の「始点」でなければなりません（手順(3)を参照）。辺 `m` の始点の番号は `start[m]` に格納されています（表2）。\n\n**答え:** `start[temp]`",
      "subQuestions": [
        {
          "label": "ア",
          "text": "0",
          "point": 15
        },
        {
          "label": "イ",
          "text": "edgenext[temp]",
          "point": 15
        },
        {
          "label": "ウ",
          "text": "top - 1",
          "point": 14
        },
        {
          "label": "エ",
          "text": "start[temp]",
          "point": 14
        }
      ]
    },
    {
      "subQNo": "設問2",
      "text": "図1のグラフで関数 directedE を動作させたとき, while 文中の if 文は、何回実行されるか、数値で答えよ。",
      "explanation": "### 設問2の解説\n`while` 文中の `if` 文は、新しい未探索の辺 `temp` が見つかったときに実行されます。この処理は、見つかった辺を `searched` 配列に登録し、次の点に進む操作です。\n\nグラフの全ての辺の個数 $M$ は8です。このアルゴリズムは、グラフの全ての辺を探索済みの経路に登録する（つまり $searched$ に格納する）まで、探索を続けます。探索済みの辺は、最終的に確定済みの経路 $path$ に移動されますが、`if` 文の実行回数は、新しい辺が探索経路に追加された回数と等しいです。\n\n一筆書きの経路探索では、全ての辺を1回ずつ通るので、`if` 文は全ての辺に対して1回ずつ実行されます。\n\n$$ M = 8 $$ \n\n**答え:** 8",
      "subQuestions": [],
      "point": 14
    },
    {
      "subQNo": "設問3",
      "text": "一筆書きができない強連結な有向グラフで関数 directedE を動作させたとき,探索はどのようになるかを、解答群の中から選び、記号で答えよ。",
      "explanation": "### 設問3の解説\n強連結な有向グラフとは、任意の2点間を互いに行き来できる経路が存在するグラフです。本問における「一筆書きができるグラフ」は、すべての辺を1回だけ通り、出発点に戻る閉じた経路（オイラー閉路）を持つグラフを指します。オイラー閉路が存在するための必要十分条件は、すべての頂点において入次数と出次数が等しいことです。\n\nもしグラフが強連結であるが、一筆書きができない（オイラー閉路が存在しない）場合、これは特定の頂点において入次数と出次数が等しくないことを意味します。しかし、強連結性があるため、すべての辺は必ず何らかの閉路の一部となり、出発点からすべての辺をたどり切ることが可能です（オイラー路は存在する可能性があります）。\n\nこの `directedE` 関数は、探索済みの経路を遡りながら、未探索の辺を持つ点から新たな閉路を見つけて連結していく、回路分解の手法を採用しています。強連結なグラフでは、必ず全ての辺が探索され、最終的に $M$ 個の辺がすべて $path$ 配列に格納されます。したがって、探索は完了します。\n\nしかし、グラフ全体が一筆書きの経路の定義（出発点に戻る閉路）を満たさない場合、アルゴリズムが発見した $path$ はすべての辺を通っていますが、それは「一筆書きの経路」（オイラー閉路）の定義を満たさない可能性があります。\n\n**ア** 探索が完了するが、配列 path に格納された経路は一筆書きの経路にならない。\n**イ** 探索が完了せずに終了して、配列 path に格納された経路は一筆書きの経路にならない。\n**ウ** 探索が無限ループに陥り、探索が終了しない。\n\n強連結性により全ての辺は探索されるため、探索は完了し、結果として $M$ 個の辺が $path$ に格納されます。しかし、グラフがオイラー閉路の条件を満たさないため、得られた経路は「一筆書きの経路」とは言えません。\n\n**答え:** ア",
      "subQuestions": [],
      "point": 14
    },
    {
      "subQNo": "設問4",
      "text": "図4のプログラムは、配列 searched を配列 path に置き換えることで、使用する領域を減らすことができる。このとき、無駄な繰返しが発生しないように、下線①の繰返し条件を、変数 topとlast を用いて変更せよ。",
      "explanation": "### 設問4の解説\n配列 `searched` を廃止し、`path` 配列が探索中のスタック（$1$ から $top-1$）と確定済みの経路（$last$ から $M$）の両方を担うようにすると、メモリ使用量を削減できます。\n\n従来の構造では `while (last が 1 以上)` という条件で、確定済みの経路が $M$ 個全て埋まるまでループを回していました。しかし、もし探索が完了し、全ての辺を遡って（バックトラックして）`top` が1に戻ってしまった場合、`current[x]` は0となり `else` ブロックに入ります。このとき、`top ← top - 1` により `top` が0になり、次の `temp ← searched[top]`（または `path[top]`）でインデックスエラーが発生するか、あるいは `top` が1以上にとどまり続けた場合に、無限に同じ処理を繰り返す「無駄な繰返し」が発生する可能性があります。\n\n探索が終了し、バックトラック処理も完了した状態は、確定すべき辺がない（$last=0$）か、あるいはこれ以上遡る辺がない（$top=1$）状態です。\n\n全ての辺が確定する、つまり $last$ が0になるまでループを続行しつつ、探索経路のスタックが空（$top=1$）になったら、それ以上遡り処理を続けないようにする必要があります。遡り処理は `else` ブロックで行われるため、`else` ブロックに `if (top > 1)` のチェックを追加するのが最も自然ですが、ここでは `while` 条件の変更が求められています。\n\nグラフが強連結であるため、最終的には $last$ は0になります。無駄な繰返し（`top` が1で `else` に入り続けること）を避けるためには、**スタックが空でない** 状態をループ条件に含める必要があります。\n\n探索を続行すべき条件は、以下のいずれかです。\n1. 確定すべき辺が残っている ($last \\ge 1$)\n2. 探索中の経路スタックに辺が残っている ($top > 1$)\n\nもし $top=1$ で $last \\ge 1$ の状態になった場合、これは現在の始点1から探索を開始できない（`current[1]=0`）が、まだ確定すべき辺が残っていることを示しますが、強連結グラフの性質上、この状態は通常、最終的な終了直前（$last=1, top=2$ の状態から $last=0, top=1$ に移行する瞬間）を除いて発生しません。しかし、安全性を担保するためには、スタックが空ではないことを条件に含めるべきです。\n\n**答え:** `top > 1`",
      "subQuestions": [],
      "point": 14
    }
  ]
}