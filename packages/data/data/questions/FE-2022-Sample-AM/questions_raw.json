[
  {
    "qNo": 1,
    "text": "負数を2の補数で表すとき, 8ビットの2進正数nに対し-n を求める式はどれか。ここで,+は加算を表し, OR はビットごとの論理和, XOR はビットごとの排他的論理和を表す。",
    "options": [
      {
        "id": "a",
        "text": "(n OR 10000000) + 00000001"
      },
      {
        "id": "b",
        "text": "(n OR 11111110) + 11111111"
      },
      {
        "id": "c",
        "text": "(n XOR 10000000) + 11111111"
      },
      {
        "id": "d",
        "text": "(n XOR 11111111) + 00000001"
      }
    ],
    "correctOption": "d",
    "explanation": "負数「-n」を2の補数で求める手順は、次の2ステップです。\n\n1. **すべてのビットを反転させる**（これを1の補数といいます）。\n2. **1を加える**。\n\n選択肢 d はこの手順を正確に表現しています。\n\nまず、ステップ1のビット反転は、元の数 $n$ と、すべてのビットが1である $11111111$ を**排他的論理和 (XOR)** で計算することで実現されます。XORは、値が1のビットと計算すると、元のビットを反転させる役割を果たします。\n\n次に、反転した結果（1の補数）に $00000001$（1）を**加算**して、2の補数（$-n$）が完成します。したがって、**d: (n XOR 11111111) + 00000001** が正解です。\n\n他の選択肢では、ビット反転に必要な XOR $11111111$ の操作が含まれていないか、加算する値が誤っているため、正しい2の補数表現にはなりません。例えば、論理和（OR）ではビット反転はできません。"
  },
  {
    "qNo": 2,
    "text": "次の流れ図は, 10 進整数 j (0 < j < 100) を 8 桁の 2 進数に変換する処理を表している。2 進数は下位桁から順に, 配列の要素 NISHIN (1) から NISHIN (8) に格納される。流れ図の a 及び b に入れる処理はどれか。ここで, j div 2 は j を 2 で割った商の整数部分を, j mod 2 は j を 2 で割った余りを表す。\n\n```mermaid\nflowchart TD\n    A[開始] --> B[jを入力]\n    B --> C{変換 k:1, 1, 8 (注)}\n    C --> D[a]\n    D --> E[b]\n    E --> C\n    C -- 完了 --> F[終了]\n    \n    subgraph 注記\n        N[(注)ループ端の繰返し指定は, 変数名:初期値,増分,終値を示す。]\n    end\n```\n\n| | a | b |\n|:---:|:---|:---|\n| ア | j ← j div 2 | NISHIN (k) ← j mod 2 |\n| イ | j ← j mod 2 | NISHIN (k) ← j div 2 |\n| ウ | NISHIN (k) ← j div 2 | j ← j mod 2 |\n| エ | NISHIN (k) ← j mod 2 | j ← j div 2 |",
    "options": [
      {
        "id": "a",
        "text": "j ← j div 2 / NISHIN (k) ← j mod 2"
      },
      {
        "id": "b",
        "text": "j ← j mod 2 / NISHIN (k) ← j div 2"
      },
      {
        "id": "c",
        "text": "NISHIN (k) ← j div 2 / j ← j mod 2"
      },
      {
        "id": "d",
        "text": "NISHIN (k) ← j mod 2 / j ← j div 2"
      }
    ],
    "correctOption": "d",
    "explanation": "この問題は、10進数を2進数に変換する際の基本的なアルゴリズム（手順）を問うものです。\n\n**2進数変換の基本:**\n10進数を2進数に変換するには、その数を「2で割り続け、その都度出る**余り**を下位桁から順に採用し、**商**を次の計算に使う」という手順を繰り返します。\n\n1.  **処理 a（余りの利用）：** 現在の桁の2進数の値は、元の数 j を 2 で割った余り (`j mod 2`) です。これが下位桁から順に配列 NISHIN(k) に格納されます。\n    *   aに入れる処理： `NISHIN (k) ← j mod 2`\n2.  **処理 b（商の利用）：** 次の桁の計算のために、j を新しい数に更新する必要があります。新しい j は、元の j を 2 で割った商の整数部分 (`j div 2`) です。\n    *   bに入れる処理： `j ← j div 2`\n\nしたがって、aに `NISHIN (k) ← j mod 2`、bに `j ← j div 2` を組み合わせた**エ**が正解です。\n\n他の選択肢は、余りと商の役割が逆になっていたり、代入先が誤っていたりするため、正しい2進数に変換できません。"
  },
  {
    "qNo": 3,
    "text": "P, Q, R はいずれも命題である。命題 P の真理値は真であり, 命題 (not P) or Q 及び命題 (not Q) or R のいずれの真理値も真であることが分かっている。Q, R の真理値はどれか。ここで, X or Y は X と Y の論理和, not X は X の否定を表す。\n\n| | Q | R |\n|:---:|:---:|:---|\n| ア | 偽 | 偽 |\n| イ | 偽 | 真 |\n| ウ | 真 | 偽 |\n| エ | 真 | 真 |",
    "options": [
      {
        "id": "a",
        "text": "Q: 偽, R: 偽"
      },
      {
        "id": "b",
        "text": "Q: 偽, R: 真"
      },
      {
        "id": "c",
        "text": "Q: 真, R: 偽"
      },
      {
        "id": "d",
        "text": "Q: 真, R: 真"
      }
    ],
    "correctOption": "d",
    "explanation": "まず、与えられた条件から真理値を順に決定します。\n\n1.  **Pと not P の決定**\n    命題 P の真理値は**真**と与えられているため、P の否定（not P）の真理値は**偽**になります。\n\n2.  **Q の決定**\n    命題 **(not P) or Q**（not PとQの論理和）は真です。論理和（or）は、どちらか一方が真であれば全体が真になります。not Pは偽ですから、この式全体を真にするためには、**Qが必ず真**でなければなりません。\n\n3.  **R の決定**\n    Qが真と確定したため、Qの否定（not Q）は**偽**になります。\n    次に、命題 **(not Q) or R** が真であるという条件を適用します。not Qが偽ですから、この論理和全体を真にするためには、**Rが必ず真**でなければなりません。\n\nしたがって、QとRはいずれも真であり、正解は選択肢エ（Q: 真, R: 真）です。\n\n他の選択肢（ア、イ、ウ）は、QまたはRが偽であるため、与えられた前提条件（(not P) or Q など）を満たさず、誤りとなります。"
  },
  {
    "qNo": 4,
    "text": "入力記号, 出力記号の集合が {0, 1} であり, 状態遷移図で示されるオートマトンがある。0011001110 を入力記号とした場合の出力記号はどれか。ここで, 入力記号は左から順に読み込まれるものとする。また, S₁は初期状態を表し, 遷移の矢印のラベルは, 入力/出力を表している。\n\n```mermaid\nstateDiagram-v2\n    direction LR\n    [*] --> S1\n    S1 --> S1: 0/0\n    S1 --> S2: 1/0\n    S2 --> S1: 0/0\n    S2 --> S3: 1/1\n    S3 --> S3: 1/1\n    S3 --> S2: 0/0\n```",
    "options": [
      {
        "id": "a",
        "text": "0001000110"
      },
      {
        "id": "b",
        "text": "0001001110"
      },
      {
        "id": "c",
        "text": "0010001000"
      },
      {
        "id": "d",
        "text": "0011111110"
      }
    ],
    "correctOption": "a",
    "explanation": "この問題は、示された状態遷移図（有限オートマトン）に従って、入力記号列が読み込まれたときの出力記号列を追跡するものです。遷移の矢印のラベルは「入力/出力」を表します。\n\n初期状態 S₁ から、入力 `0011001110` を順番に読み込みます。\n\n1. **0, 0, 1** の入力時： S₁ → S₁ (0/0) → S₁ (0/0) → S₂ (1/0)。出力は **000**。\n2. **1** の入力時： S₂ → S₃ (1/1)。出力は **1**。\n3. **0, 0** の入力時： S₃ → S₂ (0/0) → S₁ (0/0)。出力は **00**。\n4. **1** の入力時： S₁ → S₂ (1/0)。出力は **0**。\n5. **1, 1** の入力時： S₂ → S₃ (1/1) → S₃ (1/1)。出力は **11**。\n6. **0** の入力時： S₃ → S₂ (0/0)。出力は **0**。\n\n全ての出力を結合すると、**0001000110** となります。したがって、正解は選択肢 a です。\n\n他の選択肢は、状態遷移の追跡を誤っているか、特定の入力（特にS₂→S₃への遷移）における出力記号の読み取りを誤っているため、誤りです。"
  },
  {
    "qNo": 5,
    "text": "2分探索木になっている2分木はどれか。\n\n```mermaid\ngraph TD\n    subgraph ア\n        A(16) --> B(15)\n        A --> C(18)\n        B --> D(10)\n        B --> E(14)\n    end\n    subgraph イ\n        F(17) --> G(14)\n        F --> H(19)\n        G --> I(10)\n        G --> J(16)\n        H --> K(18)\n    end\n    subgraph ウ\n        L(18) --> M(16)\n        L --> N(19)\n        M --> O(15)\n        M --> P(14)\n        N --> Q(20)\n    end\n    subgraph エ\n        R(20) --> S(18)\n        R --> T(19)\n        S --> U(10)\n        S --> V(14)\n        T --> W(15)\n        T --> X(16)\n    end\n```",
    "options": [
      {
        "id": "a",
        "text": "図ア"
      },
      {
        "id": "b",
        "text": "図イ"
      },
      {
        "id": "c",
        "text": "図ウ"
      },
      {
        "id": "d",
        "text": "図エ"
      }
    ],
    "correctOption": "b",
    "explanation": "2分探索木（Binary Search Tree: BST）とは、データを効率よく検索するための木構造です。その定義は「任意のノードにおいて、**左側の子孫は親ノードの値よりも小さく**、**右側の子孫は親ノードの値よりも大きい**」というルールをすべてのノードで満たすことです。\n\n正解の**図イ**は、このルールをすべて満たしています。\n*   ルートノード(17)：左側の子孫(14, 10, 16)は17より小さく、右側の子孫(19, 18)は17より大きいです。\n*   ノード(14)：左の子(10)は小さく、右の子(16)は大きいです。\n\n他の選択肢は、このルールに違反しています。\n*   **図ア**：ノード(15)の右の子が14です。右の子は親(15)より大きくなくてはならないため誤りです。\n*   **図ウ**：ノード(16)の右の子が14です。右の子は親(16)より大きくなくてはならないため誤りです。\n*   **図エ**：ノード(18)の右の子が14です。親(18)より小さいため誤りです。\n\nしたがって、すべての条件を満たす図イが2分探索木です。"
  },
  {
    "qNo": 6,
    "text": "配列 A が図2の状態のとき、図1の流れ図を実行すると, 配列 B が図3の状態になった。図1の a に入れる操作はどれか。ここで, 配列 A, B の要素をそれぞれ A (i, j), B (i, j) とする。\n\n**図1 流れ図**\n```mermaid\nflowchart TD\n    A[開始] --> B{ループ1 i:0, 1, 7 (注)}\n    B --> C{ループ2 j:0, 1, 7 (注)}\n    C --> D[a]\n    D --> C\n    C -- 完了 --> E{ループ1}\n    E --> F[終了]\n    \n    subgraph 注記\n        N[(注)ループ端の繰返し指定は, 変数名:初期値,増分,終値を示す。]\n    end\n```\n\n**図2 配列Aの状態**\n| j | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |\n|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|\n| i=0 | * | * | * | * | * | * | * | * |\n| i=1 | * | * | * | * | * | * | * | |\n| i=2 | * | * | * | | | | | |\n| i=3 | * | * | * | * | | | | |\n| i=4 | * | * | | | | | | |\n| i=5 | * | | | | | | | |\n| i=6 | * | | | | | | | |\n| i=7 | * | | | | | | | |\n\n**図3 実行後の配列B の状態**\n| j | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |\n|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|\n| i=0 | * | * | * | * | * | * | * | * |\n| i=1 | * | * | * | * | * | * | * | |\n| i=2 | | | | | | * | * | * |\n| i=3 | | | | | * | * | * | * |\n| i=4 | | | | | | * | * |\n| i=5 | | | | | | | | * |\n| i=6 | | | | | | | | * |\n| i=7 | | | | | | | | * |\n",
    "options": [
      {
        "id": "a",
        "text": "B(7-i, 7-j) ← A(i, j)"
      },
      {
        "id": "b",
        "text": "B(7-j, i) ← A(i, j)"
      },
      {
        "id": "c",
        "text": "B(i, 7-j) ← A(i, j)"
      },
      {
        "id": "d",
        "text": "B(j, 7-i) ← A(i, j)"
      }
    ],
    "correctOption": "d",
    "explanation": "この問題は、配列 A の要素が配列 B のどの位置に移動するか（座標変換）を問うものです。流れ図は、配列 A の全要素を A(i, j) として順に処理しています。\n\n図2（配列A）の形状と図3（配列B）の形状を比較すると、配列Aの内容が**時計回りに90度回転**して配列Bに格納されていることがわかります。\n\n1.  **Aの行 i** は B の**列 Y** に対応し、上下が反転しています (0が7、7が0)。したがって、Y = 7 - i。\n2.  **Aの列 j** は B の**行 X** に対応し、そのままの値を使っています。したがって、X = j。\n\nこの座標変換は、B の (X, Y) = (j, 7-i) に A の (i, j) の値を代入する操作となります。\n\n**正解の d: B(j, 7-i) ← A(i, j)** は、この90度時計回り回転の座標変換を表しており、図2から図3への変換と一致します。\n\n*   a: B(7-i, 7-j) は180度回転。\n*   c: B(i, 7-j) は左右反転（鏡像）。\n*   b: B(7-j, i) は反時計回り90度回転（かつ反転）。\n\nこれらは、図が示す変換とは異なるため誤りです。"
  },
  {
    "qNo": 7,
    "text": "10 進法で5桁の数 a1 a2 a3 a4 a5を, ハッシュ法を用いて配列に格納したい。ハッシュ関数を mod(a1+a2+a3+a4+a5, 13)とし,求めたハッシュ値に対応する位置の配列要素に格納する場合, 54321 は配列のどの位置に入るか。ここで, mod(x, 13)は、xを13で割った余りとする。",
    "options": [
      {
        "id": "a",
        "text": "1"
      },
      {
        "id": "b",
        "text": "2"
      },
      {
        "id": "c",
        "text": "7"
      },
      {
        "id": "d",
        "text": "11"
      }
    ],
    "correctOption": "b",
    "explanation": "この問題は、データ格納位置を効率的に決める**ハッシュ法**の基本的な計算を求めるものです。\n\n1.  **各桁の和の計算:**\n    まず、対象の数 54321 の各桁の数字を足し合わせます。\n    $5 + 4 + 3 + 2 + 1 = 15$\n\n2.  **ハッシュ値の算出:**\n    次に、ハッシュ関数 `mod(x, 13)`（13で割った余り）を適用します。\n    $15$ を $13$ で割ったときの余りを求めます。\n    $15 \\div 13 = 1$ あまり **2**\n\nハッシュ値は **2** となるため、54321 は配列の2番目の位置に格納されます。したがって、**b** が正解です。\n\n他の選択肢（a, c, d）は、余りではなく商（1）を使ったり、計算途中で誤った数字を使用したりした場合の誤りとなります。ハッシュ法では「**余り**」が格納位置を示す重要な値となります。"
  },
  {
    "qNo": 8,
    "text": "自然数 n に対して, 次のとおり再帰的に定義される関数 f(n) を考える。f(5) の値はどれか。\nf(n): if n≤1 then return 1 else return n+f(n-1)",
    "options": [
      {
        "id": "a",
        "text": "6"
      },
      {
        "id": "b",
        "text": "9"
      },
      {
        "id": "c",
        "text": "15"
      },
      {
        "id": "d",
        "text": "25"
      }
    ],
    "correctOption": "c",
    "explanation": "この問題は、関数f(n)の定義に従って値を順序立てて計算する、**再帰**（リカーシブ）の理解を問うものです。\n\n1. **f(n)の定義を確認します。**\n   - もし $n \\le 1$ なら、値は $1$ です（終了条件）。\n   - そうでなければ、値は $n + f(n-1)$ です。\n\n2. **f(5)を計算します。**\n   - $f(5) = 5 + f(4)$\n   - $f(4) = 4 + f(3)$\n   - $f(3) = 3 + f(2)$\n   - $f(2) = 2 + f(1)$\n   - $f(1) = 1$ （ここで再帰が終了します）\n\n3. **計算結果を代入して戻します。**\n   - $f(2) = 2 + 1 = 3$\n   - $f(3) = 3 + 3 = 6$\n   - $f(4) = 4 + 6 = 10$\n   - $f(5) = 5 + 10 = 15$\n\nしたがって、正解は **c: 15** です。この関数は、実際には $n$ 以下の全ての自然数を足し合わせる計算（総和）を行っています。\n\n他の選択肢は、計算ミスや終了条件の誤解によるものです。例えば、「a: 6」は $f(3)$ の値、「d: 25」は $5 \\times 5$ など、誤った計算結果です。"
  },
  {
    "qNo": 9,
    "text": "プログラムのコーディング規約に規定する事項のうち, 適切なものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "局所変数は, 用途が異なる場合でもデータ型が同じならば, できるだけ同一の変数を使うようにする。"
      },
      {
        "id": "b",
        "text": "処理性能を向上させるために, ループの制御変数には浮動小数点型変数を使用する。"
      },
      {
        "id": "c",
        "text": "同様の計算を何度も繰り返すときは, 関数の再帰呼出しを用いる。"
      },
      {
        "id": "d",
        "text": "領域割付け関数を使用するときは, 割付けができなかったときの処理を記述する。"
      }
    ],
    "correctOption": "d",
    "explanation": "プログラミングにおける**コーディング規約**とは、プログラムの品質や保守性を高めるために守るべきルールのことです。\n\n正解は **d** です。\n\n*   **d: 領域割付け関数を使用するときは, 割付けができなかったときの処理を記述する。**\n    メモリを確保する関数（mallocなど）は、要求されたサイズのメモリが不足している場合、処理に失敗することがあります。このような「異常な事態」に備え、プログラムが停止しないようにエラー処理（エラーメッセージの表示や安全な終了処理など）を記述しておくことは、堅牢なプログラムを作成する上で極めて重要です。\n\n*   **a: 局所変数は, 用途が異なる場合でも...**\n    変数の使い回しは、プログラムの可読性を著しく低下させ、バグの原因となるため不適切です。変数は用途ごとに定義すべきです。\n\n*   **b: 処理性能を向上させるために, ループの制御変数には浮動小数点型変数を使用する。**\n    浮動小数点型（小数を含む型）は整数型よりも処理が重くなるため、性能を重視するループ制御変数には通常、整数型を使用します。\n\n*   **c: 同様の計算を何度も繰り返すときは, 関数の再帰呼出しを用いる。**\n    再帰呼び出し（関数が自分自身を呼び出すこと）は、処理が複雑になりすぎたり、メモリを過剰に消費してスタックオーバーフロー（メモリ不足）を引き起こしたりするリスクがあるため、単純な繰り返し処理にはループ構造（for文など）を用いるのが適切です。"
  },
  {
    "qNo": 10,
    "text": "外部割込みの原因となるものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "ゼロによる除算命令の実行"
      },
      {
        "id": "b",
        "text": "存在しない命令コードの実行"
      },
      {
        "id": "c",
        "text": "タイマーによる時間経過の通知"
      },
      {
        "id": "d",
        "text": "ページフォールトの発生"
      }
    ],
    "correctOption": "c",
    "explanation": "これはCPU（中央処理装置）の処理を一時停止させて、別の重要な処理を実行させる「**割込み**」に関する問題です。割込みには、CPUの外部要因で発生する「外部割込み」と、プログラムの実行中に発生する「内部割込み（トラップ）」があります。\n\n*   **正解は c のタイマーによる時間経過の通知です。**\n    *   タイマーはCPUとは独立した装置（外部装置）であり、そこから「時間になったよ」という通知がCPUに送られるため、これは**外部割込み**に分類されます。\n\n*   **その他の選択肢は内部割込み（トラップ）です。**\n    *   a（ゼロ除算）、b（存在しない命令）、d（ページフォールト）は、すべて現在実行中の**プログラム自身の問題やエラー**によって発生します。これらはCPUが命令を実行する中で内部的に検出されるため、**内部割込み**（またはソフトウェア割込み）と呼ばれます。"
  },
  {
    "qNo": 11,
    "text": "メモリのエラー検出及び訂正に ECC を利用している。データバス幅 2ⁿ ビットに対して冗長ビットが n+2 ビット必要なとき, 128 ビットのデータバス幅に必要な冗長ビットは何ビットか。",
    "options": [
      {
        "id": "a",
        "text": "7"
      },
      {
        "id": "b",
        "text": "8"
      },
      {
        "id": "c",
        "text": "9"
      },
      {
        "id": "d",
        "text": "10"
      }
    ],
    "correctOption": "c",
    "explanation": "これは、メモリのエラー検出・訂正技術（ECC）に必要な冗長ビット数を求める問題です。\n\nまず、データバス幅の条件である $2^n$ ビットに、実際のデータバス幅 128 ビットを当てはめて $n$ を求めます。\n$128 = 2^n$\n$2^7 = 128$ ですから、**$n = 7$** となります。\n\n次に、冗長ビット数の条件である $n+2$ ビットに、$n=7$ を代入して計算します。\n必要な冗長ビット数 $= 7 + 2 = 9$ ビット。\n\nしたがって、**cの「9」**が正解です。この9ビットの冗長ビットは、データ（128ビット）に付加され、エラーを検出し訂正するために利用されます。他の選択肢（7, 8, 10）は、この条件式を満たしません。特にaの7は $n$ の値そのものであり、冗長ビット数ではありません。"
  },
  {
    "qNo": 12,
    "text": "A～Dを, 主記憶の実効アクセス時間が短い順に並べたものはどれか。\n\n| | キャッシュメモリ | 主記憶 |\n|:---:|:---:|:---:|:---:|:---:|\n| | 有無 | アクセス時間 (ナノ秒) | ヒット率 (%) | アクセス時間 (ナノ秒) |\n| A | なし | — | — | 15 |\n| B | なし | — | — | 30 |\n| C | あり | 20 | 60 | 70 |\n| D | あり | 10 | 90 | 80 |",
    "options": [
      {
        "id": "a",
        "text": "A, B, C, D"
      },
      {
        "id": "b",
        "text": "A, D, B, C"
      },
      {
        "id": "c",
        "text": "C, D, A, B"
      },
      {
        "id": "d",
        "text": "D, C, A, B"
      }
    ],
    "correctOption": "b",
    "explanation": "この問題は、CPUが記憶装置にアクセスする際にかかる平均時間、すなわち**実効アクセス時間（EAT）**を計算し比較するものです。\n\n1.  **キャッシュなし（A, B）**: EATは主記憶アクセス時間そのものです。\n    *   **A**: 15ナノ秒\n    *   **B**: 30ナノ秒\n\n2.  **キャッシュあり（C, D）**: EATは以下の式で計算します。\n    $EAT = (キャッシュ時間 \\times ヒット率) + (キャッシュ時間 + 主記憶時間) \\times (1 - ヒット率)$\n\n    *   **D**: $10 \\times 0.9 + (10 + 80) \\times 0.1 = 9 + 9 = **18**$ナノ秒。\n    *   **C**: $20 \\times 0.6 + (20 + 70) \\times 0.4 = 12 + 36 = **48**$ナノ秒。\n\n計算結果を比較すると、短い順は A (15) < D (18) < B (30) < C (48) となります。特にDは、主記憶が遅くてもキャッシュの**ヒット率（90%）**が高いため、キャッシュなしのBより高速です。したがって、短い順に並べた**A, D, B, C**を示す選択肢 **b** が正解です。"
  },
  {
    "qNo": 13,
    "text": "仮想化マシン環境を物理マシン 20 台で運用しているシステムがある。次の運用条件のとき, 物理マシンが最低何台停止すると縮退運転になるか。\n〔運用条件〕\n(1) 物理マシンが停止すると, そこで稼働していた仮想マシンは他の全ての物理マシンで均等に稼働させ, 使用していた資源も同様に配分する。\n(2) 物理マシンが 20 台のときに使用する資源は, 全ての物理マシンにおいて 70%である。\n(3) 1 台の物理マシンで使用している資源が 90%を超えた場合, システム全体が縮退運転となる。\n(4) (1)～(3)以外の条件は考慮しなくてよい。",
    "options": [
      {
        "id": "a",
        "text": "2"
      },
      {
        "id": "b",
        "text": "3"
      },
      {
        "id": "c",
        "text": "4"
      },
      {
        "id": "d",
        "text": "5"
      }
    ],
    "correctOption": "d",
    "explanation": "この問題は、仮想化環境におけるリソースの再配分（キャパシティプランニング）に関するものです。\n\n**ステップ1：システム全体の資源使用量を計算**\n初期状態（物理マシン20台）では、各マシンが70%の資源を使用しています。システム全体の総資源使用量は $20 \\times 70\\% = 1400\\%$ として扱います。この総使用量は、マシンが停止しても再配分されるだけで変化しません。\n\n**ステップ2：縮退運転となる境界の計算**\n残りの物理マシン1台あたりの使用率が90%を超えると縮退運転となります。\n停止台数を $N$ とすると、残りの台数は $20 - N$ です。\n新しい使用率がちょうど90%になる境界を求めます。\n$$1400\\% \\div (20 - N) = 90\\%$$\n$$20 - N = 1400 / 90 \\approx 15.55$$\n$$N = 20 - 15.55 \\approx 4.44$$\n\n**ステップ3：最低停止台数の決定**\n停止台数 $N$ は整数なので、4台停止では $1400 / 16 = 87.5\\%$ であり、まだ安全です。\nしかし、**5台**停止すると $1400 / 15 \\approx 93.33\\%$ となり、許容上限の90%を超えてしまうため、縮退運転に移行します。\n\nしたがって、最低停止台数は **d: 5** 台です。選択肢 a, b, c の台数では、残りの物理マシンの使用率が90%を下回るため誤りです。"
  },
  {
    "qNo": 14,
    "text": "図のように, 1 台のサーバ, 3 台のクライアント及び 2 台のプリンタが LAN で接続されている。このシステムはクライアントからの指示に基づいて, サーバにあるデータをプリンタに出力する。各装置の稼働率が表のとおりであるとき, このシステムの稼働率を表す計算式はどれか。ここで, クライアントは 3 台のうちどれか 1 台が稼働していればよく、プリンタは 2 台のうちどちらかが稼働していればよい。\n\n```mermaid\ngraph LR\n    S[サーバ] --- LAN((LAN))\n    LAN --- C1[クライアント]\n    LAN --- C2[クライアント]\n    LAN --- C3[クライアント]\n    LAN --- P1[プリンタ]\n    LAN --- P2[プリンタ]\n```\n\n| 装置 | 稼働率 |\n|:---:|:---:|\n| サーバ | a |\n| クライアント | b |\n| プリンタ | c |\n| LAN | 1 |\n",
    "options": [
      {
        "id": "a",
        "text": "ab³ c²"
      },
      {
        "id": "b",
        "text": "a(1-b³)(1-c²)"
      },
      {
        "id": "c",
        "text": "a(1-b)³(1-c)²"
      },
      {
        "id": "d",
        "text": "a(1-(1-b)³)(1-(1-c)²)"
      }
    ],
    "correctOption": "d",
    "explanation": "この問題は、システムの信頼性を計算する問題です。システム全体が機能するためには、構成要素である「サーバ」「クライアント群」「プリンタ群」の3つすべてが稼働している必要があります（**直列接続**）。したがって、全体の稼働率はそれぞれの稼働率の積になります。\n\nクライアントとプリンタは、複数台のうち1台が動けばよいという条件なので、**並列接続（冗長化）**の関係です。並列接続の稼働率は、【1 − (すべての装置が故障する確率)】で求めます。\n\n1.  **クライアント群の稼働率**：\n    クライアント1台の故障率は $(1-b)$ です。3台すべてが故障する確率は $(1-b)^3$ です。\n    したがって、稼働率は $1 - (1-b)^3$ となります。\n\n2.  **プリンタ群の稼働率**：\n    プリンタ1台の故障率は $(1-c)$ です。2台すべてが故障する確率は $(1-c)^2$ です。\n    したがって、稼働率は $1 - (1-c)^2$ となります。\n\n3.  **システム全体の稼働率**：\n    サーバ (a) とクライアント群、プリンタ群の稼働率を掛け合わせます。\n    $a \\times (1 - (1-b)^3) \\times (1 - (1-c)^2)$\n\nしたがって、選択肢 **d** が正解です。\n選択肢aはすべてが直列接続（クライアント3台、プリンタ2台すべて稼働必須）の場合の計算式であり、bやcは並列接続の計算方法を誤っています。"
  },
  {
    "qNo": 15,
    "text": "図の送信タスクから受信タスクに T 秒間連続してデータを送信する。1 秒当たりの送信量を S, 1 秒当たりの受信量を R としたとき, バッファがオーバフローしないバッファサイズ L を表す関係式として適切なものはどれか。ここで, 受信タスクよりも送信タスクの方が転送速度は速く、次の転送開始までの時間間隔は十分にあるものとする。\n\n```mermaid\nflowchart LR\n    T[送信タスク] --> S_Rate{S}\n    S_Rate --> B(バッファ\nサイズ:L)\n    B --> R_Rate{R}\n    R_Rate --> R[受信タスク]\n```",
    "options": [
      {
        "id": "a",
        "text": "L < (R - S) × T"
      },
      {
        "id": "b",
        "text": "L < (S - R) × T"
      },
      {
        "id": "c",
        "text": "L ≧ (R - S) × T"
      },
      {
        "id": "d",
        "text": "L ≧ (S - R) × T"
      }
    ],
    "correctOption": "d",
    "explanation": "送信タスクからバッファにデータが送られる速さ（S）が、バッファから受信タスクへデータを取り出す速さ（R）よりも速い（$S > R$）ため、T秒間の送信中にバッファにデータが溜まっていきます。\n\n*   **T秒間に送信される総量:** $S \\times T$\n*   **T秒間に受信される総量:** $R \\times T$\n*   **T秒間にバッファに溜まる最大の量:** 送信総量から受信総量を引いた差、すなわち $(S \\times T) - (R \\times T) = (S - R) \\times T$ です。\n\nバッファが**オーバフロー（あふれ）しない**ためには、バッファサイズ L は、最大で溜まる量以上である必要があります。したがって、適切な関係式は $L \\ge (S - R) \\times T$ となります。\n\n**選択肢 d** がこの条件に合致します。a, b, c は不等号の向きや引き算の順序が誤っています。（バッファが増加するのは $S > R$ の場合であり、サイズは余裕をもって「以上（≧）」でなければならないため、b の「<」や c の「$R - S$」は不適切です。）"
  },
  {
    "qNo": 16,
    "text": "インタプリタの説明として, 適切なものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "原始プログラムを, 解釈しながら実行するプログラムである。"
      },
      {
        "id": "b",
        "text": "原始プログラムを, 推論しながら翻訳するプログラムである。"
      },
      {
        "id": "c",
        "text": "原始プログラムを, 目的プログラムに翻訳するプログラムである。"
      },
      {
        "id": "d",
        "text": "実行可能なプログラムを, 主記憶装置にロードするプログラムである。"
      }
    ],
    "correctOption": "a",
    "explanation": "インタプリタは、プログラミング言語の**原始プログラム**（人間が書いたソースコード）を、機械が理解できる形式に**一行ずつ解釈（翻訳）しながら、すぐに実行していく**方式のプログラムです。\n\nしたがって、選択肢 **a** の「原始プログラムを, 解釈しながら実行するプログラムである」が正しい説明です。\n\n*   **c** の「目的プログラムに翻訳するプログラム」は**コンパイラ**の説明です。コンパイラは、プログラム全体を事前に翻訳してから実行します。\n*   **b** は、そのような処理系一般の機能としては適切ではありません。\n*   **d** の「実行可能なプログラムを, 主記憶装置にロードするプログラム」は**ローダ**（ロードプログラム）の説明です。"
  },
  {
    "qNo": 17,
    "text": "三つの媒体 A～C に次の条件でファイル領域を割り当てた場合, 割り当てた領域の総量が大きい順に媒体を並べたものはどれか。\n[条件]\n(1) ファイル領域を割り当てる際の媒体選択アルゴリズムとして, 空き領域が最大の媒体を選択する方式を採用する。\n(2) 割当て要求されるファイル領域の大きさは, 順に 90, 30, 40, 40, 70, 30 (Mバイト)であり, 割り当てられたファイル領域は, 途中で解放されない。\n(3) 各媒体は容量が同一であり, 割当て要求に対して十分な大きさをもち, 初めは全て空きの状態である。\n(4) 空き領域の大きさが等しい場合には, A, B, C の順に選択する。",
    "options": [
      {
        "id": "a",
        "text": "A, B, C"
      },
      {
        "id": "b",
        "text": "A, C, B"
      },
      {
        "id": "c",
        "text": "B, A, C"
      },
      {
        "id": "d",
        "text": "C, B, A"
      }
    ],
    "correctOption": "d",
    "explanation": "この問題は、ファイルシステムにおける「空き領域が最大の媒体を選択する方式（Worst-Fit）」というアルゴリズムに従って、ファイル割り当てをシミュレーションする問題です。Worst-Fitは、負荷を分散させるために、最も空きが多い（＝最も使われていない）媒体を優先して選択します。\n\n**【シミュレーション手順】**\n\n1.  **90 Mバイト:** 全て空き（最大）なので、タイブレーク条件(4)（A, B, Cの順）に従い **A** に割り当てます。(A=90, B=0, C=0)\n2.  **30 Mバイト:** BとCの空きが最大で同値です。タイブレークで **B** に割り当てます。(A=90, B=30, C=0)\n3.  **40 Mバイト:** Cの空きが最大です（X）。**C** に割り当てます。(A=90, B=30, C=40)\n4.  **40 Mバイト:** Bの空き(X-30)が最大です。**B** に割り当てます。(A=90, B=70, C=40)\n5.  **70 Mバイト:** Cの空き(X-40)が最大です。**C** に割り当てます。(A=90, B=70, C=110)\n6.  **30 Mバイト:** Bの空き(X-70)が最大です。**B** に割り当てます。(A=90, B=100, C=110)\n\n**【最終割り当て総量】**\n\n*   A: 90 Mバイト\n*   B: 100 Mバイト (30 + 40 + 30)\n*   C: 110 Mバイト (40 + 70)\n\n総量が大きい順に並べると、C (110) > B (100) > A (90) となり、**C, B, A** が正解です。\n\nしたがって、d が正しい選択肢です。他の選択肢はシミュレーションの結果と一致しません。"
  },
  {
    "qNo": 18,
    "text": "ファイルシステムの絶対パス名を説明したものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "あるディレクトリから対象ファイルに至る幾つかのパス名のうち, 最短のパス名"
      },
      {
        "id": "b",
        "text": "カレントディレクトリから対象ファイルに至るパス名"
      },
      {
        "id": "c",
        "text": "ホームディレクトリから対象ファイルに至るパス名"
      },
      {
        "id": "d",
        "text": "ルートディレクトリから対象ファイルに至るパス名"
      }
    ],
    "correctOption": "d",
    "explanation": "ファイルシステムのパス名には、ファイルを特定するための2種類の方法があります。\n\n**絶対パス名**とは、ファイルシステムの**最上位の場所（ルートディレクトリ）**を起点として、目的のファイルまで全ての経路を省略せずに記述する方法です。どの場所（ディレクトリ）にいても必ず同じ場所を指し示します。したがって、「d: ルートディレクトリから対象ファイルに至るパス名」が正解です。\n\n他の選択肢は絶対パス名ではありません。\n- bの「カレントディレクトリ」（現在作業中のディレクトリ）を起点とするパス名は**相対パス名**といい、現在地によって指し示す場所が変わります。\n- a（最短のパス名）やc（ホームディレクトリからのパス名）は、絶対パス名または相対パス名の一部である可能性はありますが、絶対パス名の定義としては不適切です。"
  },
  {
    "qNo": 19,
    "text": "DRAM の特徴はどれか。",
    "options": [
      {
        "id": "a",
        "text": "書込み及び消去を一括又はブロック単位で行う。"
      },
      {
        "id": "b",
        "text": "データを保持するためのリフレッシュ操作又はアクセス操作が不要である。"
      },
      {
        "id": "c",
        "text": "電源が遮断された状態でも, 記憶した情報を保持することができる。"
      },
      {
        "id": "d",
        "text": "メモリセル構造が単純なので高集積化することができ, ビット単価を安くできる。"
      }
    ],
    "correctOption": "d",
    "explanation": "DRAM（Dynamic Random Access Memory）は、主にPCの**主記憶（メインメモリ）**として使われるメモリです。\n\n*   **正解 d:** DRAMのメモリセルは、トランジスタ1個とコンデンサ1個という非常に単純な構造です。そのため、**高集積化（1枚のチップに大量の情報を詰め込むこと）**が可能となり、結果としてSRAMなどの他のメモリに比べてビットあたりの価格（**ビット単価**）を安くできます。これがDRAMの最大の特徴です。\n\n*   **a, c:** これらは主に**フラッシュメモリ**（SSDなどに使われる不揮発性メモリ）の特徴です。DRAMは電源が切れるとデータが消える揮発性メモリです。\n*   **b:** DRAMはコンデンサに電荷（データ）を蓄えますが、時間とともに電荷が漏れてしまうため、定期的なデータの再書き込み（**リフレッシュ操作**）が必要です。リフレッシュが不要なのはSRAMの特徴です。"
  },
  {
    "qNo": 20,
    "text": "次のような注文データが入力されたとき, 注文日が入力日以前の営業日かどうかを検査するチェックはどれか。\n\n| 伝票番号 (文字) | 注文日 (文字) | 商品コード (文字) | 数量 (数値) | 顧客コード (文字) |\n|:---:|:---:|:---:|:---:|:---:|",
    "options": [
      {
        "id": "a",
        "text": "シーケンスチェック"
      },
      {
        "id": "b",
        "text": "重複チェック"
      },
      {
        "id": "c",
        "text": "フォーマットチェック"
      },
      {
        "id": "d",
        "text": "論理チェック"
      }
    ],
    "correctOption": "d",
    "explanation": "この問題は、入力されたデータの内容が**意味的に正しいか**を確認する検査に関するものです。\n\n**正解は d の論理チェックです。**\n\n*   **論理チェック（妥当性チェック）**とは、データ同士の関連性や、現実の業務ルールに照らして値が正しいかを検査するものです。ここでは「注文日」が「入力日以前の営業日」であるかという、日付の前後関係や業務上の制約（営業日であること）を確認しています。\n\n*   **a: シーケンスチェック**は、データが特定の順序（例えば伝票番号順）で並んでいるかを検査します。\n*   **b: 重複チェック**は、伝票番号などのキーとなる項目に同じ値が複数ないか（二重登録がないか）を検査します。\n*   **c: フォーマットチェック**は、データ形式（例：注文日が「YYYY/MM/DD」形式であるか、数量が数値であるか）が正しいかを検査します。\n\nしたがって、日付の前後関係や営業日の制約という「意味的な正しさ」を検査する論理チェックが適切です。"
  },
  {
    "qNo": 21,
    "text": "RDBMS におけるビューに関する記述のうち, 適切なものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "ビューとは, 名前を付けた導出表のことである。"
      },
      {
        "id": "b",
        "text": "ビューに対して, ビューを定義することはできない。"
      },
      {
        "id": "c",
        "text": "ビューの定義を行ってから, 必要があれば, その基底表を定義する。"
      },
      {
        "id": "d",
        "text": "ビューは一つの基底表に対して一つだけ定義できる。"
      }
    ],
    "correctOption": "a",
    "explanation": "これは、リレーショナルデータベース管理システム（RDBMS）における「ビュー」の概念を問う問題です。\n\n- **正解の選択肢 (a)**: **ビューとは、名前を付けた導出表のことである。** これは正しい記述です。ビュー（View）は、既存の表（基底表）から必要なデータを選び出し、あたかも一つの独立した表であるかのように見せる「仮想的な表」です。データを導出（SELECT文で抽出・加工）して、それに名前を付けたものとして機能します。\n\n- **選択肢 (b)**: ビューに対して、ビューを定義すること（入れ子のビュー）は**可能です**。\n- **選択肢 (c)**: ビューは基底表（元の表）が存在しなければ定義できません。ビューを定義する前に**必ず**基底表が必要です。\n- **選択肢 (d)**: 一つの基底表から、用途に応じて複数のビューを定義することができます。また、複数の基底表を組み合わせて（結合して）一つのビューを定義することも一般的です。\n\nしたがって、ビューの基本的な定義を述べている (a) が適切です。"
  },
  {
    "qNo": 22,
    "text": "UML を用いて表した図の概念データモデルの解釈として, 適切なものはどれか。\n\n```mermaid\nclassDiagram\n    direction LR\n    class 部署 { }\n    class 従業員 { }\n    部署 \"1..*\" -- \"0..*\" 従業員 : 所属する\n```",
    "options": [
      {
        "id": "a",
        "text": "従業員の総数と部署の総数は一致する。"
      },
      {
        "id": "b",
        "text": "従業員は, 同時に複数の部署に所属してもよい。"
      },
      {
        "id": "c",
        "text": "所属する従業員がいない部署の存在は許されない。"
      },
      {
        "id": "d",
        "text": "どの部署にも所属しない従業員が存在してもよい。"
      }
    ],
    "correctOption": "b",
    "explanation": "このUML図は、部署と従業員の関係を示しています。線上に書かれた数字と記号（多重度といいます）が、関係性のルールを表しています。\n\n- **従業員側の多重度（`0..*`）の解釈：** 1つの部署に対して、従業員は「0人以上（0〜無限大）」所属できます。つまり、誰も所属していない部署があっても問題ありません。\n- **部署側の多重度（`1..*`）の解釈：** 1人の従業員は、「1つ以上（1〜無限大）」の部署に所属できます。\n\nしたがって、**選択肢b**（従業員は、同時に複数の部署に所属してもよい）は、従業員側の多重度が「1..*」であることから正しい解釈です。\n\n**他の選択肢の誤り：**\n- **a:** 総数が一致するかどうかは、この図からは判断できません。\n- **c:** 部署側の多重度が「0..*」なので、従業員がいない部署の存在は許されます。\n- **d:** 従業員は必ず「1つ以上」の部署に所属しなければならない（多重度`1..*`）ため、どの部署にも所属しない従業員は許されません。"
  },
  {
    "qNo": 23,
    "text": "ビッグデータのデータ貯蔵場所であるデータレイクの特徴として, 適切なものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "あらゆるデータをそのままの形式や構造で格納しておく。"
      },
      {
        "id": "b",
        "text": "データ量を抑えるために, データの記述情報であるメタデータは格納しない。"
      },
      {
        "id": "c",
        "text": "データを格納する前にデータ利用方法を設計し, それに沿ってスキーマをあらかじめ定義しておく。"
      },
      {
        "id": "d",
        "text": "テキストファイルやバイナリデータなど, 格納するデータの形式に応じてリポジトリを使い分ける。"
      }
    ],
    "correctOption": "a",
    "explanation": "データレイク（Data Lake）は、ビッグデータを保管するための貯蔵庫であり、その主な特徴は、**データの種類や構造に関係なく、収集した生（Raw）のままの形式で格納する**点にあります。\n\nしたがって、**選択肢 a**が正解です。データ利用の用途がまだ決まっていなくても、全てのデータを保存しておき、分析が必要になった際に初めてデータの構造（スキーマ）を定義します。\n\n**選択肢 c**は、データを格納する前に利用目的を決めて厳密なスキーマを定義する「データウェアハウス（DWH）」の特徴であり、データレイクの特徴ではありません。データレイクの柔軟性は、事前に定義を必要としない点にあります。**b**は、メタデータはデータ分析に不可欠な情報であるため誤りです。**d**も、データレイクは様々な形式のデータを一元的に格納します。"
  },
  {
    "qNo": 24,
    "text": "関係モデルにおいて表 X から表 Y を得る関係演算はどれか。\n\n**X**\n| 商品番号 | 商品名 | 価格 | 数量 |\n|:---:|:---:|:---:|:---:|\n| A01 | カメラ | 13,000 | 20 |\n| A02 | テレビ | 58,000 | 15 |\n| B01 | 冷蔵庫 | 65,000 | 8 |\n| B05 | 洗濯機 | 48,000 | 10 |\n| B06 | 乾燥機 | 35,000 | 5 |\n\n**Y**\n| 商品番号 | 数量 |\n|:---:|:---:|\n| A01 | 20 |\n| A02 | 15 |\n| B01 | 8 |\n| B05 | 10 |\n| B06 | 5 |",
    "options": [
      {
        "id": "a",
        "text": "結合 (join)"
      },
      {
        "id": "b",
        "text": "射影 (projection)"
      },
      {
        "id": "c",
        "text": "選択 (selection)"
      },
      {
        "id": "d",
        "text": "併合 (merge)"
      }
    ],
    "correctOption": "b",
    "explanation": "表 X から表 Y への操作は、元の表（X）の列（商品名、価格）を**取り除き**、必要な列（商品番号、数量）だけを抽出しています。このような操作を関係データベースの用語で**射影（Projection）**と呼びます。射影は、特定の属性（列）を指定して新しい表を作成する演算です。\n\n*   **b: 射影 (projection)** が正しいです。これは、表から必要な列（属性）を垂直方向に抽出する操作だからです。\n*   a: 結合 (join) は、複数の表を共通の列を基に一つに結合する操作です。\n*   c: 選択 (selection) は、条件を満たす行（タプル）を水平方向に抽出する操作です（例：価格が50,000円以上の商品だけを選ぶ）。\n*   d: 併合 (merge) はデータベースの標準的な関係演算ではありません。"
  },
  {
    "qNo": 25,
    "text": "IoT で用いられる無線通信技術であり, 近距離の IT 機器同士が通信する無線 PAN (Personal Area Network) と呼ばれるネットワークに利用されるものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "BLE (Bluetooth Low Energy)"
      },
      {
        "id": "b",
        "text": "LTE (Long Term Evolution)"
      },
      {
        "id": "c",
        "text": "PLC (Power Line Communication)"
      },
      {
        "id": "d",
        "text": "PPP (Point-to-Point Protocol)"
      }
    ],
    "correctOption": "a",
    "explanation": "この問題は、IoT（モノのインターネット）で使われる近距離無線通信技術に関する知識を問うています。\n\n正解は **a: BLE (Bluetooth Low Energy)** です。\n\n*   **BLE** は、スマートフォンやウェアラブルデバイスなどのごく近い距離（数m〜数十m）の機器を接続する「無線PAN (Personal Area Network)」で広く使われます。特に名前の通り消費電力が非常に少ないため、IoTデバイスに適しています。\n\n*   **b: LTE** は携帯電話などで使われる広範囲をカバーする移動体通信技術です（WAN）。\n*   **c: PLC** は電力線を使ってデータを送る通信技術であり、無線通信ではありません。\n*   **d: PPP** は主にルーターやプロバイダ接続時に使われるネットワーク層のプロトコルであり、無線通信技術そのものではありません。\n\nしたがって、近距離・低消費電力でIoTの無線PANに利用されるのはBLEです。"
  },
  {
    "qNo": 26,
    "text": "1.5 M ビット/秒の伝送路を用いて 12 M バイトのデータを転送するのに必要な伝送時間は何秒か。ここで, 伝送路の伝送効率を 50%とする。",
    "options": [
      {
        "id": "a",
        "text": "16"
      },
      {
        "id": "b",
        "text": "32"
      },
      {
        "id": "c",
        "text": "64"
      },
      {
        "id": "d",
        "text": "128"
      }
    ],
    "correctOption": "d",
    "explanation": "この問題は、データ転送に必要な時間を計算する問題です。まず、データ量と伝送速度の単位を合わせ、伝送効率を考慮した実効速度を算出します。\n\n1.  **データ量の単位変換**:\n    データ量 12 Mバイト (MB) をビット (b) に変換します（1バイト=8ビット）。\n    $12 \\text{ MB} \\times 8 = 96 \\text{ Mビット} (\\text{Mb})$\n\n2.  **実効伝送速度の計算**:\n    伝送路の速度 1.5 Mbps に効率 50% (0.5) を適用し、実際に使える速度を求めます。\n    $1.5 \\text{ Mbps} \\times 0.5 = 0.75 \\text{ Mbps}$\n\n3.  **伝送時間の計算**:\n    伝送時間 = データ量 ÷ 実効伝送速度\n    $96 \\text{ Mb} \\div 0.75 \\text{ Mbps} = 128 \\text{ 秒}$\n\nしたがって、正解は **d: 128** 秒です。\n\n**補足**:\n*   もし単位変換（×8）を忘れると 16 秒 (a) になります。\n*   もし効率の適用（÷0.5）を忘れると 64 秒 (c) になります。\n正確な時間を求めるためには、単位と効率を正しく考慮する必要があります。"
  },
  {
    "qNo": 27,
    "text": "TCP/IP を利用している環境で, 電子メールに画像データなどを添付するための規格はどれか。",
    "options": [
      {
        "id": "a",
        "text": "JPEG"
      },
      {
        "id": "b",
        "text": "MIME"
      },
      {
        "id": "c",
        "text": "MPEG"
      },
      {
        "id": "d",
        "text": "SMTP"
      }
    ],
    "correctOption": "b",
    "explanation": "TCP/IP環境で電子メールに画像や音声などのテキスト以外のデータ（マルチメディアデータ）を添付するための規格は**MIME (Multipurpose Internet Mail Extensions)** です。\n\n*   **正解 (b: MIME)**: MIMEは、標準的な電子メールが扱うテキスト形式（ASCIIコード）では送れない非テキストデータ（画像、動画、日本語など）を、メールで送れる形式に変換・符号化するための規格です。これにより、添付ファイルが可能になります。\n*   **不正解の解説**:\n    *   (a: JPEG) は静止画の圧縮形式です。\n    *   (c: MPEG) は動画・音声の圧縮形式です。\n    *   (d: SMTP) は電子メールを送信するためのプロトコル（通信規約）であり、添付ファイル自体を扱う規格ではありません。"
  },
  {
    "qNo": 28,
    "text": "トランスポート層のプロトコルであり, 信頼性よりもリアルタイム性が重視される場合に用いられるものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "HTTP"
      },
      {
        "id": "b",
        "text": "IP"
      },
      {
        "id": "c",
        "text": "TCP"
      },
      {
        "id": "d",
        "text": "UDP"
      }
    ],
    "correctOption": "d",
    "explanation": "ネットワークの階層モデル（TCP/IPモデル）において、**トランスポート層**はアプリケーション間の通信を担います。\n\n正解は **d: UDP (User Datagram Protocol)** です。\nUDPは、データを送る際に通信相手からの応答（ACK）を待たず、誤り訂正や再送制御を行いません。これにより通信の信頼性は下がりますが、制御のオーバーヘッド（手間）が少ないため、**リアルタイム性**（即時性）が重視される音声通話や動画ストリーミングなどに適しています。\n\n一方、**c: TCP (Transmission Control Protocol)** は同じトランスポート層ですが、信頼性を重視し、データが確実に届くように再送制御などを行います。そのため、リアルタイム性よりも確実なデータ転送が必要なWeb閲覧（HTTP）などで使われます。\n\n**a: HTTP** はアプリケーション層のプロトコル、**b: IP** はネットワーク層のプロトコルであり、トランスポート層のプロトコルではありません。"
  },
  {
    "qNo": 29,
    "text": "PC と Web サーバが HTTP で通信している。PC から Web サーバ宛てのパケットでは, 送信元ポート番号は PC 側で割り当てた 50001, 宛先ポート番号は 80 であった。Web サーバから PC への戻りのパケットでのポート番号の組合せはどれか。\n\n| | 送信元 (Web サーバ) のポート番号 | 宛先 (PC) のポート番号 |\n|:---:|:---:|:---:|\n| ア | 80 | 50001 |\n| イ | 50001 | 80 |\n| ウ | 80と50001 以外からサーバ側で割り当てた番号 | 80 |\n| エ | 80と50001 以外からサーバ側で割り当てた番号 | 50001 |",
    "options": [
      {
        "id": "a",
        "text": "送信元 (Web サーバ) のポート番号: 80, 宛先 (PC) のポート番号: 50001"
      },
      {
        "id": "b",
        "text": "送信元 (Web サーバ) のポート番号: 50001, 宛先 (PC) のポート番号: 80"
      },
      {
        "id": "c",
        "text": "送信元 (Web サーバ) のポート番号: 80と50001 以外からサーバ側で割り当てた番号, 宛先 (PC) のポート番号: 80"
      },
      {
        "id": "d",
        "text": "送信元 (Web サーバ) のポート番号: 80と50001 以外からサーバ側で割り当てた番号, 宛先 (PC) のポート番号: 50001"
      }
    ],
    "correctOption": "a",
    "explanation": "ネットワーク通信において、PCとWebサーバ間で応答を返す場合、**行きと帰りで送信元と宛先のポート番号が必ず入れ替わります**。これは、応答がどのサービス（ポート番号）から来て、どのプログラム（ポート番号）に戻るべきかを識別するために必要です。\n\n元の通信（PC → Webサーバ）は、送信元 50001、宛先 80 でした。\n\n1.  **WebサーバからPCへの戻りのパケット**では、送信元は「行きの宛先」（WebサーバのHTTPサービス窓口）である **80** となります。\n2.  宛先は「行きの送信元」（PC側で割り当てた一時的な窓口）である **50001** となります。\n\nしたがって、正しい組み合わせは **送信元 80、宛先 50001** であるアです。\n\nイは行きと同じ情報で誤りです。ウとエはサーバ側が新しいポートを割り当てるとしていますが、既存の接続に対する応答は、サービスを提供した元のポート（80）から返信されます。"
  },
  {
    "qNo": 30,
    "text": "緊急事態を装って組織内部の人間からパスワードや機密情報を入手する不正な行為は, どれに分類されるか。",
    "options": [
      {
        "id": "a",
        "text": "ソーシャルエンジニアリング"
      },
      {
        "id": "b",
        "text": "トロイの木馬"
      },
      {
        "id": "c",
        "text": "踏み台攻撃"
      },
      {
        "id": "d",
        "text": "ブルートフォース攻撃"
      }
    ],
    "correctOption": "a",
    "explanation": "*   この問題で説明されている「緊急事態を装ってパスワードや機密情報を聞き出す不正行為」は、**ソーシャルエンジニアリング**（a）に該当します。\n\n*   **ソーシャルエンジニアリング**とは、技術的な手段ではなく、人の心理的な隙や行動のミスを突いて情報を盗み出す手法全般を指します。電話やメールで「システム管理者だ」「緊急事態だ」と偽り、だましの手口（FUD：不安、不確実性、疑念）を使って情報を聞き出す行為が典型的です。\n\n*   他の選択肢は不正な行為ですが、今回の手口とは異なります。**トロイの木馬**（b）は悪意のあるプログラムの一種、**踏み台攻撃**（c）は他人のPCを経由して攻撃すること、**ブルートフォース攻撃**（d）はパスワードを総当たりで試す技術的な攻撃手法です。したがって、物理的・心理的なだまし討ちである（a）が正解です。"
  },
  {
    "qNo": 31,
    "text": "ボットネットにおける C&C サーバの役割として, 適切なものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "Web サイトのコンテンツをキャッシュし, 本来のサーバに代わってコンテンツを利用者に配信することによって, ネットワークやサーバの負荷を軽減する。"
      },
      {
        "id": "b",
        "text": "外部からインターネットを経由して社内ネットワークにアクセスする際に, CHAPなどのプロトコルを中継することによって, 利用者認証時のパスワードの盗聴を防止する。"
      },
      {
        "id": "c",
        "text": "外部からインターネットを経由して社内ネットワークにアクセスする際に, 時刻同期方式を採用したワンタイムパスワードを発行することによって, 利用者認証時のパスワードの盗聴を防止する。"
      },
      {
        "id": "d",
        "text": "侵入して乗っ取ったコンピュータに対して, 他のコンピュータへの攻撃などの不正な操作をするよう, 外部から命令を出したり応答を受け取ったりする。"
      }
    ],
    "correctOption": "d",
    "explanation": "ボットネットとは、攻撃者によってマルウェア（不正なプログラム）に感染させられ、遠隔操作される多数のコンピューター群（ボット）で構成されるネットワークです。\n\n*   **正解 d**：C&C（Command and Control：コマンド＆コントロール）サーバは、まさにこのボットネットの中心です。攻撃者はこのサーバを介して、乗っ取った多数のコンピューター（ボット）に**「他のコンピューターを攻撃しろ」などの不正な命令を出し**、その実行結果（応答）を受け取ります。\n*   選択肢 a は、コンテンツデリバリーネットワーク（CDN）やプロキシサーバの説明であり、C&Cサーバの役割ではありません。\n*   選択肢 b と c は、認証プロトコルやワンタイムパスワードに関する説明であり、セキュリティ対策の一部ですが、C&Cサーバの機能ではありません。\n\nしたがって、侵入したコンピューターを遠隔操作するための司令塔の役割を持つ **d** が正解です。"
  },
  {
    "qNo": 32,
    "text": "メッセージ認証符号の利用目的に該当するものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "メッセージが改ざんされていないことを確認する。"
      },
      {
        "id": "b",
        "text": "メッセージの暗号化方式を確認する。"
      },
      {
        "id": "c",
        "text": "メッセージの概要を確認する。"
      },
      {
        "id": "d",
        "text": "メッセージの秘匿性を確保する。"
      }
    ],
    "correctOption": "a",
    "explanation": "メッセージ認証符号（MAC：Message Authentication Code）は、**メッセージが途中で改ざんされていないこと（完全性）**と、**メッセージが確かに送られてきた相手から送られたこと（認証）**を確認するために利用される技術です。\n\nしたがって、正解は **a: メッセージが改ざんされていないことを確認する** です。MACはメッセージの内容と秘密鍵を用いて計算される短いコードで、受信側で同じ計算を行い、コードが一致すれば改ざんがないと判断できます。\n\n- **b** と **c** は、MACの目的とは異なります。MACはメッセージの内容そのものではなく、その「信頼性」を保証するものです。\n- **d** の「秘匿性（内容を隠すこと）」を確保するのは、暗号化（共通鍵暗号や公開鍵暗号）の役割であり、MACの役割ではありません。MACは主に完全性と認証を提供します。"
  },
  {
    "qNo": 33,
    "text": "UPS の導入によって期待できる情報セキュリティ対策としての効果はどれか。",
    "options": [
      {
        "id": "a",
        "text": "PC が電力線通信(PLC)からマルウェアに感染することを防ぐ。"
      },
      {
        "id": "b",
        "text": "サーバと端末間の通信における情報漏えいを防ぐ。"
      },
      {
        "id": "c",
        "text": "電源の瞬断に起因するデータの破損を防ぐ。"
      },
      {
        "id": "d",
        "text": "電子メールの内容が改ざんされることを防ぐ。"
      }
    ],
    "correctOption": "c",
    "explanation": "UPS（Uninterruptible Power Supply：無停電電源装置）は、停電や瞬時的な電圧低下など、**電力供給の異常が発生した際に、接続された機器（主にサーバやPC）に一定時間電力を供給し続ける**ための装置です。\n\n*   **正解の理由 (c):**\n    UPSは、急な停電や雷による瞬断（一瞬電力が途切れること）が発生しても、機器がシャットダウンするのを防ぎます。これにより、OSやアプリケーションが動作中に電源が落ちることによる**データの破損や消失を防ぐ**ことができます。これは重要な情報セキュリティ対策の一つです（可用性の維持）。\n*   **その他の選択肢が誤りである理由:**\n    *   (a) 電力線通信からのマルウェア対策や、(b) サーバと端末間の情報漏えい対策、(d) 電子メールの改ざん対策は、それぞれファイアウォール、暗号化技術、電子署名など、**ネットワークやデータの保護技術**によって実現されるものであり、UPSの機能ではありません。"
  },
  {
    "qNo": 34,
    "text": "ファジングに該当するものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "サーバに FIN パケットを送信し, サーバからの応答を観測して, 稼働しているサービスを見つけ出す。"
      },
      {
        "id": "b",
        "text": "サーバの OS やアプリケーションソフトウェアが生成したログやコマンド履歴などを解析して, ファイルサーバに保存されているファイルの改ざんを検知する。"
      },
      {
        "id": "c",
        "text": "ソフトウェアに, 問題を引き起こしそうな多様なデータを入力し, 挙動を監視して, 脆弱性を見つけ出す。"
      },
      {
        "id": "d",
        "text": "ネットワーク上を流れるパケットを収集し, そのプロトコルヘッダやペイロードを解析して, あらかじめ登録された攻撃パターンと一致するものを検出する。"
      }
    ],
    "correctOption": "c",
    "explanation": "ファジングとは、ソフトウェアの**脆弱性（セキュリティ上の弱点）**を見つけるためのテスト手法の一つです。\n\n*   **正解のC**が指す「ソフトウェアに、問題を引き起こしそうな多様なデータを入力し、挙動を監視して、脆弱性を見つけ出す」行為こそがファジングです。通常想定されないような、形式がおかしかったり大量であったりする「**ファズ**」と呼ばれるデータをランダムに大量に送りつけ、プログラムがクラッシュしたり誤動作しないかを検証します。\n\n*   **a**は、ポートスキャンなどによる**稼働状況の調査**に関する説明であり、ファジングではありません。\n*   **b**は、システムが記録した情報を分析する**フォレンジック**やログ監視に関する説明です。\n*   **d**は、通信内容を監視し、既知の攻撃パターンを検出する**IDS（不正侵入検知システム）**の動作説明です。"
  },
  {
    "qNo": 35,
    "text": "マルウェアの動的解析に該当するものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "検体のハッシュ値を計算し, オンラインデータベースに登録された既知のマルウェアのハッシュ値のリストと照合してマルウェアを特定する。"
      },
      {
        "id": "b",
        "text": "検体をサンドボックス上で実行し, その動作や外部との通信を観測する。"
      },
      {
        "id": "c",
        "text": "検体をネットワーク上の通信データから抽出し, さらに, 逆コンパイルして取得したコードから検体の機能を調べる。"
      },
      {
        "id": "d",
        "text": "ハードディスク内のファイルの拡張子とファイルヘッダの内容を基に, 拡張子が偽装された不正なプログラムファイルを検出する。"
      }
    ],
    "correctOption": "b",
    "explanation": "マルウェアの解析には大きく分けて「静的解析」と「動的解析」があります。\n\n**動的解析**とは、マルウェアの**検体（プログラム）を実際に実行**し、その動作（ファイル作成、レジストリ変更、ネットワーク通信など）を観察して機能を特定する手法です。\n\n- **正解のb**は、「サンドボックス」（隔離された仮想環境）上で検体を**実行し**、その動作を観測すると述べており、まさに動的解析に該当します。\n- **a、c、d**は、プログラムを**実行せずに**、ファイルの内容や形式、コード（逆コンパイルしたもの）自体を分析する手法であり、これらは主に**静的解析**に含まれます。特にaのハッシュ値照合は最も基本的な静的解析です。"
  },
  {
    "qNo": 36,
    "text": "SQLインジェクション攻撃による被害を防ぐ方法はどれか。",
    "options": [
      {
        "id": "a",
        "text": "入力された文字が, データベースへの問合せや操作において, 特別な意味をもつ文字として解釈されないようにする。"
      },
      {
        "id": "b",
        "text": "入力に HTML タグが含まれていたら, HTML タグとして解釈されない他の文字列に置き換える。"
      },
      {
        "id": "c",
        "text": "入力に上位ディレクトリを指定する文字列(../)が含まれているときは受け付けない。"
      },
      {
        "id": "d",
        "text": "入力の全体の長さが制限を超えているときは受け付けない。"
      }
    ],
    "correctOption": "a",
    "explanation": "SQLインジェクション攻撃は、データベースへ渡すSQL文（データベース操作の命令文）に、攻撃者が不正な文字列を紛れ込ませることで、意図しない操作を実行させる攻撃です。\n\n正解の**a**は、この攻撃を防ぐための基本的な対策です。入力されたデータに含まれる「'」（シングルクォート）や「--」（コメントアウト）などの特殊文字を、データベースが命令の一部として解釈しないように無効化（エスケープ処理やプレースホルダの利用）することで、攻撃者の意図する不正なSQL文の挿入を防げます。\n\n**b**はクロスサイトスクリプティング（XSS）対策、**c**はパストラバーサル（ディレクトリ移動）攻撃対策であり、SQLインジェクション対策ではありません。**d**はバッファオーバーフローやサービス停止（DoS）対策の一つとして有効ですが、SQLインジェクションの本質的な防御にはなりません。"
  },
  {
    "qNo": 37,
    "text": "電子メールをドメイン A の送信者がドメイン B の宛先に送信するとき, 送信者をドメイン A のメールサーバで認証するためのものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "APOP"
      },
      {
        "id": "b",
        "text": "POP3S"
      },
      {
        "id": "c",
        "text": "S/MIME"
      },
      {
        "id": "d",
        "text": "SMTP-AUTH"
      }
    ],
    "correctOption": "d",
    "explanation": "## 解説\n\nこの問題は、電子メールを送信する際に、**送信者が正当なユーザーであるか**をメールサーバーが確認する（認証する）仕組みについて問われています。\n\n正解は **d: SMTP-AUTH** です。\n\n*   **SMTP-AUTH（SMTP Authentication）**は、メール送信プロトコルである **SMTP** に認証機能（ユーザー名とパスワードの確認）を追加したものです。これにより、送信者がドメイン A の正規のユーザーであるかを、ドメイン A のメールサーバーが確認できます。迷惑メール（スパム）対策としても重要です。\n\n*   **a: APOP** と **b: POP3S** は、メールを**受信**する際に使われるプロトコル（**POP3**）に関連する認証・暗号化技術であり、送信時の認証には使用されません。\n*   **c: S/MIME** は、メールの**内容を暗号化したり、電子署名を付与したり**して、セキュリティを高めるための技術であり、送信者の認証とは目的が異なります。"
  },
  {
    "qNo": 38,
    "text": "オブジェクト指向プログラムにおいて, データとメソッドを一つにまとめ, オブジェクトの実装の詳細をユーザから見えなくすることを何と呼ぶか。",
    "options": [
      {
        "id": "a",
        "text": "インスタンス"
      },
      {
        "id": "b",
        "text": "カプセル化"
      },
      {
        "id": "c",
        "text": "クラスタ化"
      },
      {
        "id": "d",
        "text": "抽象化"
      }
    ],
    "correctOption": "b",
    "explanation": "オブジェクト指向におけるこの概念は**カプセル化**（b）と呼ばれます。\n\n**カプセル化**とは、データ（属性）と、そのデータを操作する手続き（メソッド）を一つの「カプセル」にまとめ、外部からデータの内部構造や詳細な実装が見えないように隠蔽（いんぺい）する仕組みです。これにより、オブジェクトの安全性が高まり、誤った操作を防ぐことができます。\n\n*   **b（カプセル化）**：データとメソッドを一つにまとめ、実装の詳細を隠すという定義に完全に合致しています。\n*   **a（インスタンス）**：クラスという設計図から実際に作り出された「実体」のことなので誤りです。\n*   **c（クラスタ化）**：複数のコンピュータなどを連結して一つのシステムとして扱う技術であり、オブジェクト指向の概念ではありません。\n*   **d（抽象化）**：共通の性質だけを取り出して、複雑な詳細を捨象することであり、詳細を隠蔽する目的は似ていますが、データとメソッドをまとめる行為そのものを指すわけではないため、カプセル化がより適切な用語です。"
  },
  {
    "qNo": 39,
    "text": "モジュール結合度が最も弱くなるものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "一つのモジュールで, できるだけ多くの機能を実現する。"
      },
      {
        "id": "b",
        "text": "二つのモジュール間で必要なデータ項目だけを引数として渡す。"
      },
      {
        "id": "c",
        "text": "他のモジュールとデータ項目を共有するためにグローバルな領域を使用する。"
      },
      {
        "id": "d",
        "text": "他のモジュールを呼び出すときに, 呼び出したモジュールの論理を制御するための引数を渡す。"
      }
    ],
    "correctOption": "b",
    "explanation": "ソフトウェアの設計において、モジュール間の依存度合いを示す指標を「**モジュール結合度**」と呼びます。結合度が**弱い（低い）**ほど、モジュールが独立しており、修正や再利用がしやすく、良い設計とされます。\n\n選択肢bは「二つのモジュール間で必要なデータ項目だけを引数として渡す」とあり、**データ結合**（必要な情報のみを引数でやり取りする最も弱い結合）に該当します。これは最も理想的で結合度が弱くなります。\n\n一方、選択肢aのように多くの機能を持たせると、モジュールが巨大になり結合度は高まります。cの**グローバルな領域**（全体で共有されるデータ）の使用は、どのモジュールからでも変更できてしまうため、制御が難しくなり非常に強い結合（共通結合）となります。dのように、呼び出し側の論理を制御する引数（**制御フラグ**）を渡すのは、**制御結合**と呼ばれ、データ結合よりも結合度が強くなります。"
  },
  {
    "qNo": 40,
    "text": "モジュールの内部構造を考慮することなく、仕様書どおりに機能するかどうかをテストする手法はどれか。",
    "options": [
      {
        "id": "a",
        "text": "トップダウンテスト"
      },
      {
        "id": "b",
        "text": "ブラックボックステスト"
      },
      {
        "id": "c",
        "text": "ボトムアップテスト"
      },
      {
        "id": "d",
        "text": "ホワイトボックステスト"
      }
    ],
    "correctOption": "b",
    "explanation": "この問題は、ソフトウェアテスト手法に関する基本的な知識を問うものです。\n\n正解は **b: ブラックボックステスト** です。\n\nブラックボックステストとは、モジュールの内部構造（プログラムコードなど）を一切見ずに、外部から入力したデータに対して、仕様書通りの正しい出力が得られるかどうかを確認するテスト手法です。モジュールを「中身の見えない箱（ブラックボックス）」として扱うことから名付けられています。\n\n一方、**d: ホワイトボックステスト** は、プログラムの内部構造やロジックに着目し、コードが正しく動作するかどうかを確認する手法なので、問題文の意図とは異なります。\n\n**a: トップダウンテスト** と **c: ボトムアップテスト** は、複数のモジュールを結合してテストする際の「結合テスト」の進め方に関する手法であり、機能の検証方法（内部構造を考慮するか否か）を問うものではありません。"
  },
  {
    "qNo": 41,
    "text": "アジャイル開発のスクラムにおけるスプリントのルールのうち, 適切なものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "スプリントの期間を決定したら, スプリントの 1 回目には要件定義工程を, 2 回目には設計工程を, 3 回目にはコード作成工程を, 4 回目にはテスト工程をそれぞれ割り当てる。"
      },
      {
        "id": "b",
        "text": "成果物の内容を確認するスプリントレビューを, スプリントの期間の中間時点で実施する。"
      },
      {
        "id": "c",
        "text": "プロジェクトで設定したスプリントの期間でリリース判断が可能なプロダクトインクリメントができるように, スプリントゴールを設定する。"
      },
      {
        "id": "d",
        "text": "毎回のスプリントプランニングにおいて, スプリントの期間をゴールの難易度に応じて, 1 週間から 1 か月までの範囲に設定する。"
      }
    ],
    "correctOption": "c",
    "explanation": "アジャイル開発のスクラムにおける「スプリント」は、短い期間（通常1〜4週間）で開発を行う区切りのことです。\n\n**正解（c）の解説：**\nスプリントでは、その期間内に利用可能な成果物（**プロダクトインクリメント**）を作成し、リリース可能か判断できる状態にすることが求められます。そのために、そのスプリントで達成すべき目標（**スプリントゴール**）を設定します。cは、このスクラムの目的とルールを正しく説明しています。\n\n**誤りの選択肢：**\n*   a: スクラムでは、ウォータフォール開発のように工程を分けて順に実施するのではなく、1回のスプリント内で設計、実装、テストまでを完結させます。\n*   b: スプリントの成果物を確認する**スプリントレビュー**は、スプリントの期間が終了した直後に実施されます。\n*   d: スプリントの期間（例：2週間）は、一度決定したら、原則としてプロジェクトを通じて変更しません。毎回のプランニングで期間を変えることはありません。"
  },
  {
    "qNo": 42,
    "text": "プロジェクトライフサイクルの一般的な特性はどれか。",
    "options": [
      {
        "id": "a",
        "text": "開発要員数は, プロジェクト開始時が最多であり, プロジェクトが進むにつれて減少し, 完了に近づくと再度増加する。"
      },
      {
        "id": "b",
        "text": "ステークホルダがコストを変えずにプロジェクトの成果物に対して及ぼすことができる影響の度合いは, プロジェクト完了直前が最も大きくなる。"
      },
      {
        "id": "c",
        "text": "プロジェクトが完了に近づくほど, 変更やエラーの修正がプロジェクトに影響する度合いは小さくなる。"
      },
      {
        "id": "d",
        "text": "リスクは, プロジェクトが完了に近づくにつれて減少する。"
      }
    ],
    "correctOption": "d",
    "explanation": "プロジェクトの一般的な特性に関する問題です。\n\n**正解は d** です。プロジェクトが完了に近づくにつれて、不確実性（未確定な要素）が減るため、プロジェクト全体のリスク（危険性や問題発生の可能性）は減少していく傾向にあります。\n\n他の選択肢は以下の理由で誤りです。\n* **a**：開発要員数は通常、プロジェクトの中盤（実行フェーズ）が最も多くなります。\n* **b**：ステークホルダ（利害関係者）が与える影響度は、プロジェクト開始時（設計段階など）が最も大きく、完了に近づくほど小さくなります。計画が固まった後で変更するのはコストがかかるためです。\n* **c**：プロジェクトが完了に近づくほど、小さな変更やエラーの修正であっても、手戻り（やり直し）の規模が大きくなり、プロジェクト全体に与える影響度は**大きく**なります。"
  },
  {
    "qNo": 43,
    "text": "ソフトウェア開発の見積方法の一つであるファンクションポイント法の説明として, 適切なものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "開発規模が分かっていることを前提として, 工数と工期を見積もる方法である。ビジネス分野に限らず, 全分野に適用可能である。"
      },
      {
        "id": "b",
        "text": "過去に経験した類似のソフトウェアについてのデータを基にして, ソフトウェアの相違点を調べ, 同じ部分については過去のデータを使い, 異なった部分は経験に基づいて, 規模と工数を見積もる方法である。"
      },
      {
        "id": "c",
        "text": "ソフトウェアの機能を入出力データ数やファイル数などによって定量的に計測し, 複雑さによる調整を行って, ソフトウェア規模を見積もる方法である。"
      },
      {
        "id": "d",
        "text": "単位作業項目に適用する作業量の基準値を決めておき, 作業項目を単位作業項目まで分解し, 基準値を適用して算出した作業量の積算で全体の作業量を見積もる方法である。"
      }
    ],
    "correctOption": "c",
    "explanation": "ファンクションポイント法（FP法）は、ソフトウェアの**機能**（ファンクション）に着目して、開発規模を見積もるための代表的な手法です。\n\n正解の選択肢 **c** は、まさにこのFP法の定義を説明しています。具体的には、ユーザーが利用する「入力画面の数」「出力帳票の数」「利用するファイルの数」などを数え、さらにその機能の複雑さに応じて調整を加えることで、開発規模を**定量的（数値で）**に算出します。\n\n*   **b** は、過去の類似プロジェクトと比較して見積もる**類推（るいすい）法**の説明です。\n*   **d** は、作業を細かく分解し、それぞれの作業にかかる時間を積み上げて全体の工数を算出する**工数積算法**（ボトムアップ見積もり）の説明です。\n\nしたがって、機能の入出力に着目し規模を計測するFP法を説明している **c** が適切です。"
  },
  {
    "qNo": 44,
    "text": "アローダイアグラムの日程計画をもつプロジェクトの, 開始から終了までの最少所要日数は何日か。",
    "options": [
      {
        "id": "a",
        "text": "9"
      },
      {
        "id": "b",
        "text": "10"
      },
      {
        "id": "c",
        "text": "11"
      },
      {
        "id": "d",
        "text": "12"
      }
    ],
    "correctOption": "d",
    "explanation": "これは、プロジェクトの日程計画で使われる**アローダイアグラム**（作業の流れと所要時間を表す図）に関する問題です。開始から終了までの最少所要日数、つまり**クリティカルパス**（最も時間がかかる経路）の長さを求めます。\n\n1. **すべての経路の所要時間を計算します。**\n    *   経路①：1 → 2 → 4 → 5 → 6（2 + 4 + 1 + 3 = 10日）\n    *   経路②：1 → 3 → 5 → 6（3 + 6 + 3 = 12日）\n2. **最長の経路（クリティカルパス）を見つけます。**\n    *   経路①は10日、経路②は12日です。\n    *   プロジェクトはすべての作業が終わるまで完了しないため、最も長い経路の12日が、開始から終了までの最少所要日数となります。\n\nしたがって、正解は**d: 12**です。\n\n他の選択肢は、一部の短い経路の所要時間や、誤った計算結果に基づいているため誤りです。例えば、10日（b）は経路①の長さです。"
  },
  {
    "qNo": 45,
    "text": "サービスマネジメントのプロセス改善におけるベンチマーキングはどれか。",
    "options": [
      {
        "id": "a",
        "text": "IT サービスのパフォーマンスを財務, 顧客, 内部プロセス, 学習と成長の観点から測定し, 戦略的な活動をサポートする。"
      },
      {
        "id": "b",
        "text": "業界内外の優れた業務方法(ベストプラクティス)と比較して, サービス品質及びパフォーマンスのレベルを評価する。"
      },
      {
        "id": "c",
        "text": "サービスのレベルで可用性, 信頼性, パフォーマンスを測定し, 顧客に報告する。"
      },
      {
        "id": "d",
        "text": "強み, 弱み, 機会, 脅威の観点から IT サービスマネジメントの現状を分析する。"
      }
    ],
    "correctOption": "b",
    "explanation": "**ベンチマーキング**とは、自社のサービスや業務プロセスを、業界で最も優れているとされる他社（または自社の他部門）の**ベストプラクティス**（最良のやり方）と比較し、その差を埋めるために改善目標を設定する手法です。\n\n選択肢bは、「業界内外の優れた業務方法と比較して、サービス品質及びパフォーマンスのレベルを評価する」と述べており、まさにベンチマーキングの定義と合致します。これにより、自社の弱点や改善の機会を明確にできます。\n\n- aは、企業の戦略実行を評価する**バランススコアカード（BSC）**の説明です。\n- cは、**サービスレベル管理（SLM）**における一般的なサービス品質の測定・報告の説明です。\n- dは、企業の現状分析手法である**SWOT分析**の説明です。\n\nしたがって、サービス改善のために他社の優れた事例と比較する手法であるbが正解です。"
  },
  {
    "qNo": 46,
    "text": "ディスク障害時に, フルバックアップを取得してあるテープからディスクにデータを復元した後, フルバックアップ取得時以降の更新後コピーをログから反映させてデータベースを回復する方法はどれか。",
    "options": [
      {
        "id": "a",
        "text": "チェックポイントリスタート"
      },
      {
        "id": "b",
        "text": "リブート"
      },
      {
        "id": "c",
        "text": "ロールバック"
      },
      {
        "id": "d",
        "text": "ロールフォワード"
      }
    ],
    "correctOption": "d",
    "explanation": "正解は **d: ロールフォワード** です。\n\nディスク障害が発生した際、古いフルバックアップデータ（基準点）を復元した後、それ以降の更新ログ（トランザクションログ）を適用して、データベースを最新の状態に回復させる手順を「ロールフォワード」と呼びます。これはデータを「未来へ進める（フォワード）」イメージです。\n\n*   **d（ロールフォワード）**：古いバックアップと更新ログを使って、障害発生直前の状態までデータを進めるため、これが正解です。\n*   **c（ロールバック）**：処理途中のトランザクションが異常終了した際に、そのトランザクションが行った変更を破棄し、データ処理前の状態に戻す操作（過去に戻る）であり、回復方法としては不適切です。\n*   **a（チェックポイントリスタート）**：データベースの整合性を維持するために、定期的に更新情報を記憶媒体に書き出す処理（チェックポイント）を活用した回復処理ですが、ここではログからデータを「進める」操作が問われています。\n*   **b（リブート）**：システムの再起動を意味し、データの回復方法ではありません。"
  },
  {
    "qNo": 47,
    "text": "経営者が社内のシステム監査人の外観上の独立性を担保するために講じる措置として, 最も適切なものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "システム監査人に IT に関する継続的学習を義務付ける。"
      },
      {
        "id": "b",
        "text": "システム監査人に必要な知識や経験を定めて公表する。"
      },
      {
        "id": "c",
        "text": "システム監査人の監査技法研修制度を設ける。"
      },
      {
        "id": "d",
        "text": "システム監査人の所属部署を内部監査部門とする。"
      }
    ],
    "correctOption": "d",
    "explanation": "この問題は、システム監査人が「外観上の独立性」を保つための組織的な措置について問われています。\n\n「外観上の独立性」とは、監査人が客観的に見て、監査対象の部門や人から影響を受けていないように見える状態のことです。経営者がこれを担保するための最も適切な措置は、**システム監査人（部門）を、監査対象となるIT部門などから組織的に切り離すこと**です。\n\n正解の **d**（システム監査人の所属部署を内部監査部門とする）は、IT部門など、監査対象から独立した部署（通常は社長直轄など）に監査人を配置することで、外観上の独立性を高めます。\n\nその他の選択肢は、システム監査人の能力向上（a, b, c）に関する措置であり、独立性、特に「外観上の独立性」を担保する組織的な措置としては不適切です。監査能力が高くても、IT部門に所属していれば、監査が甘くなるのではないかという疑念（外観上の独立性の欠如）が生じる可能性があります。"
  },
  {
    "qNo": 48,
    "text": "情報セキュリティ監査において, 可用性を確認するチェック項目はどれか。",
    "options": [
      {
        "id": "a",
        "text": "外部記憶媒体の無断持出しが禁止されていること"
      },
      {
        "id": "b",
        "text": "中断時間を定めた SLA の水準が保たれるように管理されていること"
      },
      {
        "id": "c",
        "text": "データ入力時のエラーチェックが適切に行われていること"
      },
      {
        "id": "d",
        "text": "データベースが暗号化されていること"
      }
    ],
    "correctOption": "b",
    "explanation": "情報セキュリティの三大要素である「機密性」「完全性」「可用性」のうち、**可用性（Availability）**は、「必要なときにシステムやデータが利用できる状態であること」を指します。\n\n選択肢bは、「中断時間（システムが停止している時間）」を定めたSLA（サービス品質保証）の水準が保たれるように管理されているかを確認しており、これは**システムが常に利用可能であること**（可用性）を直接チェックしています。したがって、bが正解です。\n\n- **a**（外部記憶媒体の無断持出し）と**d**（データベースの暗号化）は、情報が漏れないようにする**機密性**（Confidentiality）に関わる項目です。\n- **c**（データ入力時のエラーチェック）は、情報が正確で改ざんされていない状態を保つ**完全性**（Integrity）に関わる項目です。"
  },
  {
    "qNo": 49,
    "text": "テレワークで活用している VDI に関する記述として, 適切なものはどれか。",
    "options": [
      {
        "id": "a",
        "text": "PC 環境を仮想化してサーバ上に置くことで, 社外から端末の種類を選ばず自分のデスクトップ PC 環境として利用できるシステム"
      },
      {
        "id": "b",
        "text": "インターネット上に仮想の専用線を設定し, 特定の人だけが利用できる専用ネットワーク"
      },
      {
        "id": "c",
        "text": "紙で保管されている資料を, ネットワークを介して遠隔地からでも参照可能な電子書類に変換・保存することができるツール"
      },
      {
        "id": "d",
        "text": "対面での会議開催が困難な場合に, ネットワークを介して対面と同じようなコミュニケーションができるツール"
      }
    ],
    "correctOption": "a",
    "explanation": "VDI（Virtual Desktop Infrastructure：仮想デスクトップ基盤）は、**PCのデスクトップ環境をデータセンターなどのサーバ上に集約し、ネットワーク経由で利用する技術**です。\n\n正解の選択肢 **a** が示す通り、VDIを利用すれば、利用者は社外からでも、手元の端末（PC、タブレットなど）の種類を選ばずに、常に**自分専用のPC環境**（デスクトップ、アプリケーション、データなど）にアクセスし利用できます。これはテレワークのセキュリティと利便性を高める主要な手段です。\n\nその他の選択肢はVDIとは異なる技術を説明しています。\n- **b** はVPN（Virtual Private Network：仮想私設網）の説明です。\n- **c** は文書管理システムやスキャニングツールの説明です。\n- **d** はWeb会議システムやビデオチャットツールの説明です。"
  },
  {
    "qNo": 50,
    "text": "投資案件において, 5 年間の投資効果を ROI (Return On Investment)で評価した場合, 四つの案件 a～d のうち, 最も ROI が高いものはどれか。ここで、割引率は考慮しなくてもよいものとする。\n\n**案件 a**\n| 年目 | 1 | 2 | 3 | 4 | 5 |\n|:---:|:---:|:---:|:---:|:---:|:---:|\n| 利益 | 15 | 30 | 45 | 30 | 15 |\n| 投資額 | 100 | | | | |\n\n**案件 b**\n| 年目 | 1 | 2 | 3 | 4 | 5 |\n|:---:|:---:|:---:|:---:|:---:|:---:|\n| 利益 | 105 | 75 | 45 | 15 | 0 |\n| 投資額 | 200 | | | | |\n\n**案件 c**\n| 年目 | 1 | 2 | 3 | 4 | 5 |\n|:---:|:---:|:---:|:---:|:---:|:---:|\n| 利益 | 60 | 75 | 90 | 75 | 60 |\n| 投資額 | 300 | | | | |\n\n**案件 d**\n| 年目 | 1 | 2 | 3 | 4 | 5 |\n|:---:|:---:|:---:|:---:|:---:|:---:|\n| 利益 | 105 | 105 | 105 | 105 | 105 |\n| 投資額 | 400 | | | | |",
    "options": [
      {
        "id": "a",
        "text": "a"
      },
      {
        "id": "b",
        "text": "b"
      },
      {
        "id": "c",
        "text": "c"
      },
      {
        "id": "d",
        "text": "d"
      }
    ],
    "correctOption": "a",
    "explanation": "投資案件の評価指標である **ROI (Return On Investment：投資利益率)** は、「総利益 ÷ 投資額」で計算されます。割引率（時間の経過による価値の変化）は考慮不要なので、単純に5年間の利益合計を使います。\n\n1. **総利益の計算 (5年間)**\n   - 案件 a: $15+30+45+30+15 = 135$\n   - 案件 b: $105+75+45+15+0 = 240$\n   - 案件 c: $60+75+90+75+60 = 360$\n   - 案件 d: $105 \\times 5 = 525$\n\n2. **ROIの計算 (総利益 ÷ 投資額)**\n   - **a**: $135 \\div 100 = 1.35$\n   - b: $240 \\div 200 = 1.20$\n   - c: $360 \\div 300 = 1.20$\n   - d: $525 \\div 400 = 1.3125$\n\nこの結果、**案件 a (1.35)** が最も高いROIとなります。他の案件も利益は出ていますが、投資額に対するリターン率では案件 aが最も効率が良いと評価されます。したがって、正解は a です。"
  },
  {
    "qNo": 51,
    "text": "国や地方公共団体が, 環境への配慮を積極的に行っていると評価されている製品・サービスを選んでいる。この取組を何というか。",
    "options": [
      {
        "id": "a",
        "text": "CSR"
      },
      {
        "id": "b",
        "text": "エコマーク認定"
      },
      {
        "id": "c",
        "text": "環境アセスメント"
      },
      {
        "id": "d",
        "text": "グリーン購入"
      }
    ],
    "correctOption": "d",
    "explanation": "この問題は、国や地方公共団体（自治体）などが環境に配慮された製品やサービスを優先的に購入する取り組みに関するものです。\n\n**正解は d: グリーン購入** です。\nグリーン購入とは、製品やサービスを選ぶ際に、価格や品質だけでなく、環境への負荷（フカ）がより少ないものを選ぶことです。国や地方公共団体は、この取り組みを積極的に行うことが法律で定められています。\n\n他の選択肢は以下の理由で誤りです。\n\n*   **a: CSR**（企業の社会的責任）は、企業活動を通じて社会貢献や環境配慮を行う全般的な活動です。購入活動に特化した用語ではありません。\n*   **b: エコマーク認定**は、環境に優しい製品に付与される認証マーク（印）のことで、購入の「取り組み」自体を指す言葉ではありません。\n*   **c: 環境アセスメント**は、大規模な開発事業などが環境に与える影響を事前に調査・予測・評価することです。購入とは直接関係ありません。"
  },
  {
    "qNo": 52,
    "text": "コアコンピタンスの説明はどれか。",
    "options": [
      {
        "id": "a",
        "text": "競合他社にはまねのできない自社ならではの卓越した能力"
      },
      {
        "id": "b",
        "text": "経営を行う上で法令や各種規制, 社会的規範などを遵守する企業活動"
      },
      {
        "id": "c",
        "text": "市場・技術・商品(サービス)の観点から設定した, 事業の展開領域"
      },
      {
        "id": "d",
        "text": "組織活動の目的を達成するために行う, 業務とシステムの全体最適化手法"
      }
    ],
    "correctOption": "a",
    "explanation": "コアコンピタンス（Core Competence）とは、**他社にはまねのできない、企業独自の核となる強みや能力**のことです。\n\n*   **正解（a）**: 「競合他社にはまねのできない自社ならではの卓越した能力」は、まさにコアコンピタンスの定義そのものです。企業が市場で優位性を保ち続けるための源泉となる重要な概念です。\n*   **誤りの選択肢**:\n    *   bは**コンプライアンス**（法令遵守）の説明です。\n    *   cは**事業ドメイン**（事業領域）の説明です。\n    *   dは**BPR**（ビジネスプロセス・リエンジニアリング）や**EA**（エンタープライズアーキテクチャ）などの全体最適化に関する手法の説明です。"
  },
  {
    "qNo": 53,
    "text": "新しい事業に取り組む際の手法として, E. リースが提唱したリーンスタートアップの説明はどれか。",
    "options": [
      {
        "id": "a",
        "text": "国・地方公共団体など, 公共機関の補助金・助成金の交付を前提とし, 事前に詳細な事業計画を検討・立案した上で, 公共性のある事業を立ち上げる手法"
      },
      {
        "id": "b",
        "text": "市場環境の変化によって競争力を喪失した事業分野に対して, 経営資源を大規模に追加投入し, リニューアルすることによって, 基幹事業として再出発を期す手法"
      },
      {
        "id": "c",
        "text": "持続可能な事業を迅速に構築し, 展開するために, あらかじめ詳細に立案された事業計画を厳格に遂行して, 成果の検証や計画の変更を最小限にとどめる手法"
      },
      {
        "id": "d",
        "text": "実用最小限の製品・サービスを短期間で作り, 構築・計測・学習というフィードバックループで改良や方向転換をして, 継続的にイノベーションを行う手法"
      }
    ],
    "correctOption": "d",
    "explanation": "リーンスタートアップは、新しい事業や製品を開発する際に、**無駄を極力なくし、素早い検証と改善を繰り返す**手法です。\n\n正解の **d** は、この考え方を正確に説明しています。「実用最小限の製品・サービス（MVP：Minimum Viable Product）」をまず作り、顧客の反応を「構築→計測→学習」のループで確認します。これにより、詳細な計画に固執せず、市場のニーズに合わせて製品を素早く改良（イテレーション）したり、事業の方向性を変える（ピボット）ことが可能です。\n\n他の選択肢は以下の理由で誤りです。\n- **a**：補助金や公共性のある事業に限定した話ではありません。\n- **b**：大規模な資源投入は、資源を最小限にするリーンスタートアップの考え方と異なります。\n- **c**：詳細な計画を厳格に遂行し、計画変更を最小限にするのは、リーンスタートアップとは対極の、従来の開発手法の説明です。"
  },
  {
    "qNo": 54,
    "text": "IoT の応用事例のうち, HEMS の説明はどれか。",
    "options": [
      {
        "id": "a",
        "text": "工場内の機械に取り付けたセンサで振動, 温度, 音などを常時計測し, 収集したデータを基に機械の劣化状態を分析して, 適切なタイミングで部品を交換する。"
      },
      {
        "id": "b",
        "text": "自動車に取り付けたセンサで車両の状態, 路面状況などのデータを計測し, ネットワークを介して保存し分析することによって, 効率的な運転を支援する。"
      },
      {
        "id": "c",
        "text": "情報通信技術や環境技術を駆使して, 街灯などの公共設備や交通システムをはじめとする都市基盤のエネルギーの可視化と消費の最適制御を行う。"
      },
      {
        "id": "d",
        "text": "太陽光発電装置などのエネルギー機器, 家電機器, センサ類などを家庭内通信ネットワークに接続して, エネルギーの可視化と消費の最適制御を行う。"
      }
    ],
    "correctOption": "d",
    "explanation": "HEMSは「**Home Energy Management System**（ホーム・エネルギー・マネジメント・システム）」の略であり、**家庭**内のエネルギー消費を効率的に管理・最適化するためのシステムです。\n\n**正解のd**は、太陽光発電装置や家電などを家庭内ネットワークに接続し、エネルギーの使用状況を「可視化」（見える化）し、消費量を最適に制御するという、HEMSの目的と機能を正確に説明しています。\n\nその他の選択肢は、管理対象が家庭ではないため誤りです。\naは**工場**の機械管理（予知保全）の事例です。bは**自動車**の運行管理（コネクテッドカー）の事例です。cは**都市**全体のエネルギー管理（スマートシティ、CEMS）の事例です。したがって、家庭を対象とするHEMSの説明としてはdが適切です。"
  },
  {
    "qNo": 55,
    "text": "ロングテールの説明はどれか。",
    "options": [
      {
        "id": "a",
        "text": "Web コンテンツを構成するテキストや画像などのデジタルコンテンツに, 統合的・体系的な管理, 配信などの必要な処理を行うこと"
      },
      {
        "id": "b",
        "text": "インターネットショッピングで, 売上の全体に対して, あまり売れない商品群の売上合計が無視できない割合になっていること"
      },
      {
        "id": "c",
        "text": "自分の Web サイトやブログに企業へのリンクを掲載し, 他者がこれらのリンクを経由して商品を購入したときに, 企業が紹介料を支払うこと"
      },
      {
        "id": "d",
        "text": "メーカや卸売業者から商品を直接発送することによって, 在庫リスクを負うことなく自分の Web サイトで商品が販売できること"
      }
    ],
    "correctOption": "b",
    "explanation": "ロングテールとは、**インターネット販売において、売れ筋ではないニッチな（特定の層にしか売れない）商品の種類を大量に揃えることで、その合計売上が無視できないほど大きな割合になる現象**を指します。\n\n選択肢bがこの説明に完全に一致しています。インターネット（特にECサイト）では、実店舗と違い棚の制約がないため、多品種少量販売が可能になり、全体の売上グラフの「長い尻尾（テール）」の部分が重要になります。\n\n他の選択肢は以下の通りです。\n- aはデジタルアセットマネジメント（DAM）などのコンテンツ管理に関する説明です。\n- cはアフィリエイト（成功報酬型広告）の説明です。\n- dはドロップシッピング（無在庫販売）の説明です。"
  },
  {
    "qNo": 56,
    "text": "CGM (Consumer Generated Media) の例はどれか。",
    "options": [
      {
        "id": "a",
        "text": "企業が, 経営状況や財務状況, 業績動向に関する情報を, 個人投資家向けに公開する自社の Web サイト"
      },
      {
        "id": "b",
        "text": "企業が, 自社商品の特徴や使用方法に関する情報を, 一般消費者向けに発信する自社の Web サイト"
      },
      {
        "id": "c",
        "text": "行政機関が, 政策, 行政サービスに関する情報を, 一般市民向けに公開する自組織の Web サイト"
      },
      {
        "id": "d",
        "text": "個人が, 自らが使用した商品などの評価に関する情報を, 不特定多数に向けて発信するブログや SNS などの Web サイト"
      }
    ],
    "correctOption": "d",
    "explanation": "CGM（Consumer Generated Media）とは、直訳すると「消費者生成メディア」であり、**一般の消費者（ユーザー）が主体となってコンテンツを作成・投稿**し、それが主な情報源となるWebサイトやサービスを指します。\n\n正解の**d**は、「個人が、自らが使用した商品などの評価に関する情報を、不特定多数に向けて発信するブログや SNS」であり、消費者がコンテンツ（商品評価など）を生成・発信しているため、CGMの定義に完全に合致します。\n\n一方、選択肢**a**と**b**は「企業」が、**c**は「行政機関」が情報を発信しています。これらは組織側がコンテンツを生成しているメディアであり、消費者による生成ではないため、CGMの例としては誤りです。CGMを理解する鍵は、**発信者が組織ではなく一般ユーザーである**という点です。"
  },
  {
    "qNo": 57,
    "text": "製品 X 及び Y を生産するために 2 種類の原料 A, B が必要である。製品 1 個の生産に必要となる原料の量と調達可能量は表に示すとおりである。製品 X と Y の 1 個当たりの販売利益が, それぞれ 100 円, 150 円であるとき, 最大利益は何円か。\n\n| 原料 | 製品 X の 1 個当たりの必要量 | 製品 Y の 1 個当たりの必要量 | 調達可能量 |\n|:---:|:---:|:---:|:---:|\n| A | 2 | 1 | 100 |\n| B | 1 | 2 | 80 |",
    "options": [
      {
        "id": "a",
        "text": "5,000"
      },
      {
        "id": "b",
        "text": "6,000"
      },
      {
        "id": "c",
        "text": "7,000"
      },
      {
        "id": "d",
        "text": "8,000"
      }
    ],
    "correctOption": "c",
    "explanation": "この問題は、限られた原料（制約条件）の中で最大の利益（目的関数）を追求する「**線形計画法**」の典型です。\n\n最大の利益は、通常、原料の制約線が交わる点（生産量の限界点）で発生します。\n\n製品 X の生産量を $x$、製品 Y の生産量を $y$ とします。\n利益を最大化するため、原料を使い切る条件で連立方程式を立てます。\n\n1.  **原料 A の制約**: $2x + y = 100$\n2.  **原料 B の制約**: $x + 2y = 80$\n\nこの連立方程式を解くと、最適な生産量は $x = 40$（製品 X 40個）、$y = 20$（製品 Y 20個）となります。\n\nこの値を利益の計算式（$100x + 150y$）に代入します。\n$$100 \\times 40 + 150 \\times 20 = 4,000 + 3,000 = 7,000$$\n\n最大利益は **7,000 円**（選択肢 c）です。\n\n選択肢 a (5,000円) や b (6,000円) は、どちらか一方の製品のみを生産した場合の利益であり、両方の原料を組み合わせて効率的に使用する方が、より大きな利益を得られることがわかります。"
  },
  {
    "qNo": 58,
    "text": "令和 2 年 4 月に 30 万円で購入した PC を 3 年後に 1 万円で売却するとき, 固定資産売却損は何万円か。ここで, 耐用年数は 4 年, 減価償却は定額法, 定額法の償却率は 0.250, 残存価額は 0 円とする。",
    "options": [
      {
        "id": "a",
        "text": "6.0"
      },
      {
        "id": "b",
        "text": "6.5"
      },
      {
        "id": "c",
        "text": "7.0"
      },
      {
        "id": "d",
        "text": "7.5"
      }
    ],
    "correctOption": "b",
    "explanation": "この問題は、固定資産（PC）を売却した際に生じる損失（売却損）を計算する会計の知識を問うものです。損失を計算するためには、売却時点でのPCの「帳簿価額」（簿記上の価値）を把握する必要があります。\n\n1. **毎年の減価償却費の計算**:\n定額法なので、毎年同じ額を費用として計上します。(取得原価 30万円) × (償却率 0.250) = **7.5万円/年**。\n\n2. **売却時点の帳簿価額の計算**:\n3年経過した時点での償却累計額は 7.5万円 × 3年 = **22.5万円** です。\n帳簿価額は、取得原価から累計額を引きます。30万円 − 22.5万円 = **7.5万円**。\n\n3. **売却損の計算**:\n売却損益は「売却価格 − 帳簿価額」で求めます。\n1万円 (売却価格) − 7.5万円 (帳簿価額) = **-6.5万円**。\n\nマイナスの値が出たため、**6.5万円の固定資産売却損**が発生したことになります。したがって、**b** が正解です。他の選択肢は、償却年数を誤るなど、計算過程での誤りによって導かれます。"
  },
  {
    "qNo": 59,
    "text": "売上高が 100 百万円のとき, 変動費が 60 百万円, 固定費が 30 百万円掛かる。変動費率, 固定費は変わらないものとして, 目標利益 18 百万円を達成するのに必要な売上高は何百万円か。",
    "options": [
      {
        "id": "a",
        "text": "108"
      },
      {
        "id": "b",
        "text": "120"
      },
      {
        "id": "c",
        "text": "156"
      },
      {
        "id": "d",
        "text": "180"
      }
    ],
    "correctOption": "b",
    "explanation": "この問題は、目標利益を達成するために必要な売上高を求める**損益分岐点分析**の応用です。\n\n1. **変動費率の算出**: まず、売上高に対する変動費の割合（変動費率）を求めます。\n   変動費率 = 変動費 60百万円 ÷ 売上高 100百万円 = **0.6 (60%)**\n\n2. **目標達成に必要な売上高の公式**:\n   目標売上高 = (固定費 + 目標利益) ÷ (1 - 変動費率)\n   ※ (1 - 変動費率)は**限界利益率**と呼ばれ、売上高から変動費を引いた利益の割合を示します。\n\n3. **計算**:\n   目標売上高 = (固定費 30百万円 + 目標利益 18百万円) ÷ (1 - 0.6)\n   目標売上高 = 48百万円 ÷ 0.4 = **120百万円**\n\nしたがって、正解は **b: 120** です。\n\n他の選択肢は、計算ミスや変動費率の誤った使用に基づいています。例えば、売上高に変動費率を単純に足し引きしても正しい結果は得られません。"
  },
  {
    "qNo": 60,
    "text": "労働者派遣法に基づく, 派遣先企業と労働者との関係(図の太線部分)はどれか。\n\n```mermaid\nflowchart TD\n    A[派遣元企業] -- 雇用契約 --> B[労働者]\n    A -- 派遣契約 --> C[派遣先企業]\n    B -- 指揮命令関係 (太線) --> C\n```",
    "options": [
      {
        "id": "a",
        "text": "請負契約関係"
      },
      {
        "id": "b",
        "text": "雇用契約関係"
      },
      {
        "id": "c",
        "text": "指揮命令関係"
      },
      {
        "id": "d",
        "text": "労働者派遣契約関係"
      }
    ],
    "correctOption": "c",
    "explanation": "労働者派遣の仕組みでは、労働者は自分の所属先（**派遣元企業**）と「雇用契約」を結びますが、実際に業務を行う場所（**派遣先企業**）から直接、仕事の指示や命令を受けます。\n\nしたがって、図の太線で示されている、労働者と派遣先企業の間で結ばれる業務上の指示・命令の関係は、**c: 指揮命令関係**が正解となります。\n\n他の選択肢は以下の通りです。\n*   **b: 雇用契約関係**：労働者と派遣元企業の間で結ばれます。\n*   **d: 労働者派遣契約関係**：派遣元企業と派遣先企業の間で結ばれる、労働者の派遣に関する契約です。\n*   **a: 請負契約関係**：仕事の完成を目的とする契約であり、派遣元と労働者の間に指揮命令関係はありません。これは派遣とは異なる契約形態です。"
  }
]