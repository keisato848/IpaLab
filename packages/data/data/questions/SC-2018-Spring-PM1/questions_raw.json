{
  "questions": [
    {
      "qNo": 1,
      "theme": "ソフトウェアの脆弱性に関する学習",
      "description": "V社は、従業員数100名のソフトウェア開発会社である。V社では、開発に関わる全員が情報セキュリティを意識した実装を行えるよう、開発経験が浅い従業員にセキュリティ教育を行っている。次は、任意の攻撃コードが実行され得る脆弱性について、開発チームのT主任が部下のUさんに教えていた時の会話である。\n\nT主任：任意の攻撃コードが実行され得る脆弱性は幾つかある。確保済みメモリ領域を超えてデータを書き込んでしまう [  a  ] と呼ばれる脆弱性の報告が以前から多かった。最近は解放したメモリ領域を後から使用してしまう [  b  ] と呼ばれる脆弱性の報告も多くなってきている。\nUさん： [  b  ] という脆弱性は具体的にはどのようなものなのですか。\nT主任：例えば、図1のC++ソースコードからなるプログラム（以下、例示プログラムという）があったとする。例示プログラムは、図2に示すシステム構成の中で動作し、ノートと呼ぶメモ書き機能を実現するものであり、クライアントから利用者が自身の名前とメッセージを登録したり、それを他の利用者が参照したりする。例示プログラムでは、ノートは Note 構造体で表現され、利用者の操作に応じて、NoteManager クラスの各メンバ関数が個別に呼び出される。各メンバ関数では、ノートの生成 (CreateNote)、利用者の名前の登録 (RegisterName)、メッセージの登録 (RegisterMsg)、ノートの登録内容表示 (DisplayNote)、ノートの破棄 (DeleteNote) を行う機能を実装している。例示プログラムにおいて、DeleteNote メンバ関数内で m_note の指すメモリ領域を解放しているが、仮に DeleteNote メンバ関数が呼び出された直後に RegisterName メンバ関数が呼び出されると、解放した m_note の指すメモリ領域にアクセスできてしまう。これが [  b  ] という脆弱性だ。例示プログラムでは、悪意をもつ利用者（以下、攻撃者という）の操作によって、任意の攻撃コードを実行され、サーバを乗っ取られてしまうおそれがある。\n\n### 図1 脆弱性が存在するC++ソースコード\n```cpp\n1: #include <cstdio>\n2:\n3: struct Note{\n4:   char *name;\n5:   char *msg;\n6: };\n7:\n8: class NoteManager {\n9:   Note *m_note;\n10: public:\n11:   NoteManager() { m_note = NULL; }\n12:   void CreateNote(){\n13:     if(m_note = new Note()){\n14:       m_note->name = NULL;\n15:       m_note->msg = NULL;\n16:     }\n17:   }\n18:   void RegisterName(){\n19:     if(m_note && !m_note->name) m_note->name = new char[8];\n20:     if(m_note && m_note->name){\n21:       printf(\"Input name: \");\n22:       scanf(\"%7s%*[^\\n]%*c\", m_note->name);\n23:     }\n24:   }\n25:   void RegisterMsg(){\n26:     if(m_note && !m_note->msg) m_note->msg = new char[100];\n27:     if(m_note && m_note->msg){\n28:       printf(\"Input message: \");\n29:       scanf(\"%99s%*[^\\n]%*c\", m_note->msg);\n30:     }\n31:   }\n32:   void DisplayNote() {\n33:     if(m_note && m_note->name) printf(\"Name: %s\\n\", m_note->name);\n34:     if(m_note && m_note->msg) printf(\"Message: %s\\n\", m_note->msg);\n35:   }\n36:   void DeleteNote(){\n37:     delete[] m_note->name;\n38:     delete[] m_note->msg;\n39:     delete m_note;\n40:   }\n41: };\n42: (省略)\n```\n注記 メモリアドレスが32ビットの環境で動作させるものとする。\n\n### 図2 例示プログラムが動作するシステム構成の例\n\n```mermaid\ngraph LR\n    subgraph Client [クライアント]\n        Menu[操作メニュー<br/>1. ノートの生成<br/>2. 名前の登録<br/>3. メッセージの登録<br/>4. 登録内容表示<br/>5. ノートの破棄]\n    end\n    subgraph Server [Linuxサーバ]\n        Front[フロントサービス] \n        Program[例示プログラム]\n        \n        Front -- 選択メニューに応じた<br/>メンバ関数の呼出し --> Program\n        Redirect1[リダイレクト]\n        Redirect2[リダイレクト]\n        Front -- リダイレクト --> Redirect1\n        Redirect1 -- 標準入力 --> Program\n        Program -- 標準出力 --> Redirect2\n        Redirect2 -- リダイレクト --> Front\n    end\n    \n    Menu -- メニュー表示 --> Front\n    Menu -- メニュー選択 --> Front\n    Menu -- 利用者からの入力 --> Front\n    Front -- 利用者への出力 --> Menu\n```\n\nUさん：解放したメモリ領域にアクセスされると、どのように攻撃コードが実行されるのですか。\nT主任：例示プログラムにおいて、図3に示す(1)～(3)の順でメンバ関数の呼出しが行われたとしよう。その場合、図3の(1)で確保されていた Note 構造体用のメモリ領域と、図3の(3)で確保された char[8] 用のメモリ領域が同じアドレスに割り当てられる可能性がある。その場合、①RegisterName メンバ関数内で読み込まれる攻撃者からの入力値によって、元々 Note 構造体用であったメモリ領域が上書きされる。このときの攻撃者からの入力値がうまく細工されていると、②次に RegisterName メンバ関数が呼ばれた際、その際に読み込まれる攻撃者からの入力値が、攻撃者の指定したアドレスに書き込まれることになる。このように、攻撃者からの入力値が攻撃者の指定したアドレスに書き込まれる場合には攻撃コードが実行され得る。\n\n### 図3 脆弱性を悪用する関数呼出しの過程とメモリマップ\n\n```mermaid\ngraph TD\n    subgraph S1 [ (1) CreateNoteメンバ関数実行後 ]\n        M1[m_note] --> NoteStruct[Note構造体領域]\n        NoteStruct --- NamePtr[name 指針]\n        NoteStruct --- MsgPtr[msg 指針]\n    end\n    \n    subgraph S2 [ (2) DeleteNoteメンバ関数実行後 ]\n        M2[m_note] --> Freed[解放済みメモリ領域]\n    end\n    \n    subgraph S3 [ (3) RegisterNameメンバ関数内のnew実行後 ]\n        M3[m_note] --> Overlap[char 8 用メモリ領域]\n    end\n```\n\n### 図4 ライブラリ関数の呼出し時の動き\n\n```mermaid\ngraph LR\n    subgraph FT [関数テーブル]\n        entry1[\"scanfの実行コードの<br/>先頭アドレスの値\"]\n        entry2[\"printfの実行コードの<br/>先頭アドレスの値\"]\n    end\n    subgraph MP [メイン処理]\n        call[\"scanfの呼出し処理\"]\n    end\n    subgraph SL [共有ライブラリ]\n        code1[printfの実行コード]\n        code2[scanfの実行コード]\n    end\n\n    call -- \"(1)参照\" --> entry1\n    call -- \"(2)遷移\" --> code2\n```\n\nT主任：攻撃者が既に、攻撃コードをメモリ上に書き込んでいるとしよう。この状態で、例えば、攻撃コードが存在するアドレスを関数テーブルに書き込まれた場合、関数の呼出し時に関数テーブルが参照されると、攻撃コードに処理が遷移してしまう。\nUさん：例示プログラムを攻撃する場合だと、関数テーブルに書き込むアドレスは具体的にどのような値になりますか。\nT主任：例えば、RegisterMsg メンバ関数の呼出しによって m_note->msg が指し示すメモリ領域に攻撃コードが書き込まれていて、その先頭アドレスが 0x0b123400 と分かっていたとする。その場合、関数テーブルが表1に示すようになっていたとすると、アドレス [  c  ] 番地に値 [  d  ] を書き込むことによって、次に CreateNote メンバ関数が呼び出された際、攻撃コードに処理が遷移することになる。\n\n### 表1 関数テーブル\n| アドレス | 値 | 値の意味 |\n| :--- | :--- | :--- |\n| (ア) 0x08049e30 | (キ) 0xf7cfcd70 | delete の実行コードの先頭アドレス |\n| (イ) 0x08049e38 | (ク) 0xf7ce9370 | scanf の実行コードの先頭アドレス |\n| (ウ) 0x08049e3c | (ケ) 0xf7cd7670 | printf の実行コードの先頭アドレス |\n| (エ) 0x08049e40 | (コ) 0xf7cff150 | new の実行コードの先頭アドレス |\n| (オ) 0x08049e44 | (サ) 0xf7cff230 | new[] の実行コードの先頭アドレス |\n| (カ) 0x08049e4c | (シ) 0xf7cfcdd0 | delete[] の実行コードの先頭アドレス |\n\nUさん：RegisterMsg メンバ関数の呼出しによって入力された攻撃コードは [  e  ] 領域に書き込まれるので、データ実行防止と呼ばれる機能が有効化されていた場合、実行されませんよね。\nT主任：確かにそのとおりだ。ただし、③関数テーブルに書き込むアドレスとして、例えば、共有ライブラリ内のメモリアドレスを選べば、データ実行防止が有効化されていた場合でも、攻撃者が任意の処理を実行できる可能性がある。例示プログラムにおいて、共有ライブラリ内のメモリアドレスが表2のようになっていたとすると、関数テーブルに書き込むアドレスを [  f  ] 番地にすることによって、データ実行防止が有効化されていた場合でも、/bin/sh を起動して任意のシェルコマンドを実行できる可能性がある。\n\n### 表2 共有ライブラリ内のメモリアドレス\n| アドレス | 内容 |\n| :--- | :--- |\n| (ア) 0xf7cc8da0 | system の実行コード |\n| (イ) 0xf7cd7670 | printf の実行コード |\n| (ウ) 0xf7ce9370 | scanf の実行コード |\n| (エ) 0xf7cfcd70 | delete の実行コード |\n| (オ) 0xf7cfcdd0 | delete[] の実行コード |\n| (カ) 0xf7cff150 | new の実行コード |\n| (キ) 0xf7cff230 | new[] の実行コード |\n| (ク) 0xf7de99ab | \"/bin/sh\" の文字列 |\n\nUさん：共有ライブラリ内のメモリアドレスは、表2のように前もって知ることができるものなのですか。\nT主任：共有ライブラリをメモリに読み込む際、それを配置するアドレスを毎回ランダムに選ぶ ASLR (Address Space Layout Randomization) と呼ばれるセキュリティ機能がある。この機能が有効な場合、共有ライブラリ内のメモリアドレスを前もって知ることは難しい。しかし、例示プログラムにおいて、図3の(3)の状態をつくり出せれば、RegisterName メンバ関数と [  g  ] メンバ関数を利用することによって、ASLR が有効化されていた場合でも、共有ライブラリ内のメモリアドレスを特定できる可能性がある。データ実行防止や ASLR などは効果的な機能ではあるが、根本的な対策にはならない。やはり脆弱性そのものを修正することが重要だ。\nUさん：では、 [  b  ] の脆弱性を修正するには、例示プログラムではどうすればよいのでしょうか。\nT主任：図1の39行目の直後に [  h  ] という1文を加えればよいだろう。\nUさんは、今回学んだことをコードレビューの観点として生かしていくことにした。",
      "questions": [
        {
          "subQNo": "設問1",
          "text": "本文中の [ a ], [ b ] に入れる適切な脆弱性名を、解答群の中から選び、記号で答えよ。",
          "explanation": "### 解説\nこの問題は、メモリ管理に関する典型的な脆弱性を問うものです。\n- **[ a ]**: 確保したバッファ（メモリ領域）のサイズを超えてデータを書き込むことで、隣接するメモリ領域を破壊する攻撃を**バッファオーバフロー** (Buffer Overflow) と呼びます。\n- **[ b ]**: 動的に確保し、一度解放 (free/delete) したメモリ領域を、ポインタがその領域を指したままの状態で再度アクセスしてしまう脆弱性を **Use-After-Free** と呼びます。例示プログラムの `DeleteNote` でポインタが NULL にされていないことが原因です。\n\n```mermaid\ngraph TD\n    A[メモリ確保] --> B[利用]\n    B --> C[メモリ解放 delete]\n    C -- ポインタが残っている --> D[再度利用 Use-After-Free]\n```",
          "subQuestions": [
            {
              "label": "a",
              "text": "解答群：ア CSRF, イ SQL インジェクション, ウ Use-After-Free, エ クロスサイトスクリプティング, オ コマンドインジェクション, カ バッファオーバフロー, キ フォーマットストリングバグ, ク レースコンディション"
            },
            {
              "label": "b",
              "text": "解答群：同上"
            }
          ]
        },
        {
          "subQNo": "設問2",
          "text": "本文中の下線②のようになるためには、本文中の下線①で読み込まれる攻撃者からの入力値はどのような値である必要があるか。攻撃者の指定したアドレスを 0x12345678, 改行コードを 0x0a とした場合について、入力値の具体的なバイト列を 14字以内の 16進数文字列で答えよ。ここで、アドレスは 32ビットであり、バイトオーダがリトルエンディアンのバイトマシンによって扱われるものとする。",
          "explanation": "### 解説\n図3(3)の状態で `RegisterName` が呼ばれると、`new char[8]` によって確保される領域が、解放済みの `Note` 構造体（メンバに `name` ポインタと `msg` ポインタを持つ）と同じ場所に割り当てられます。 \n1.  `Note` 構造体はポインタ2つ分（32ビット×2 = 8バイト）のサイズを持ちます。\n2.  攻撃者が `char[8]` 領域（実際には `Note` 構造体の位置）にデータを書き込むと、`m_note->name` ポインタの値を上書きできます。\n3.  リトルエンディアンでは、アドレス `0x12345678` は `78 56 34 12` の順でメモリに並びます。\n4.  `scanf` でこの値を書き込むことで、次に `RegisterName` が呼ばれた際、`m_note->name` が攻撃者の意図する `0x12345678` を指すようになります。\n\n16進数文字列：`78563412`"
        },
        {
          "subQNo": "設問3",
          "text": "本文中の [ c ] に入れる適切なアドレスを表1中の (ア) ～ (シ) から選び、記号で答えよ。",
          "explanation": "### 解説\n「次に `CreateNote` メンバ関数が呼び出された際、攻撃コードに処理が遷移する」ようにするためには、`CreateNote` 内で使用されているライブラリ関数の関数テーブルエントリを書き換える必要があります。\n図1の 13行目で `new Note()` が呼ばれています。表1を見ると、`new` の実行コードの先頭アドレスを保持しているのはアドレス **0x08049e40** (エ) です。\n\n```mermaid\nsequenceDiagram\n    participant P as 例示プログラム\n    participant FT as 関数テーブル\n    participant A as 攻撃コード\n    P->>FT: CreateNote内の'new'実行時に参照\n    FT-->>A: 攻撃者がアドレス(エ)を書き換えていれば遷移\n```"
        },
        {
          "subQNo": "設問4",
          "text": "本文中の [ d ] に入れる適切な値を 16 進数で答えよ。",
          "explanation": "### 解説\n[ d ] には遷移させたい「攻撃コードの先頭アドレス」を入れます。本文中に「攻撃コードが書き込まれていて、その先頭アドレスが **0x0b123400** と分かっていたとする」と記述されています。"
        },
        {
          "subQNo": "設問5",
          "text": "本文中の [ e ] に入れるメモリ領域の名称を答えよ。",
          "explanation": "### 解説\nC++において `new` 演算子で動的に確保されるメモリ領域は **ヒープ** (Heap) 領域です。"
        },
        {
          "subQNo": "設問6",
          "text": "本文中の下線③の理由を、45字以内で述べよ。",
          "explanation": "### 解説\nデータ実行防止 (DEP/NXビット) は、スタックやヒープ上のデータをコードとして実行することを防ぎますが、既存の実行可能な共有ライブラリ内のコード（例えば `system` 関数など）へジャンプして実行することを防ぐことはできません。このような攻撃手法を Return-into-libc 攻撃などと呼びます。\n\n解答例：**データ実行防止機能は、元々実行許可のある共有ライブラリ内のコードの実行を制限できないから。**"
        },
        {
          "subQNo": "設問7",
          "text": "本文中の [ f ] に入れる適切なアドレスを表2中の (ア) ～ (ク) から選び、記号で答えよ。",
          "explanation": "### 解説\n「/bin/sh を起動して任意のシェルコマンドを実行」するためには、`system` 関数の引数に \"/bin/sh\" を渡して実行する必要があります。関数テーブルのアドレスを `system` 関数のアドレス **0xf7cc8da0** (ア) に書き換えることで、関数呼び出し時に `system` が実行されます。"
        },
        {
          "subQNo": "設問8",
          "text": "本文中の [ g ] に入れるメンバ関数の名前を答えよ。",
          "explanation": "### 解説\nASLR を突破するには、メモリ上のアドレスをリーク（特定）させる必要があります。図3(3)のように `Note` 構造体の領域が上書きされている状態で、`DisplayNote` 関数を呼び出すと、`m_note->name` や `m_note->msg` が指す先を表示しようとします。攻撃者がこれらを共有ライブラリのインポートテーブルのアドレスなどに書き換えておけば、その中身（関数の実アドレス）が表示され、特定が可能になります。\n\n解答：**DisplayNote**"
        },
        {
          "subQNo": "設問9",
          "text": "本文中の [ h ] に入れる適切なソースコードを答えよ。",
          "explanation": "### 解説\nUse-After-Free の根本的な対策は、メモリを解放した直後に、そのメモリを指していたポインタに `NULL` を代入して「 dangling pointer（宙ぶらりんのポインタ）」を解消することです。39行目で `delete m_note;` を行っているので、その直後に `m_note` をクリアします。\n\n解答：**m_note = NULL;**"
        }
      ],
      "point": 34
    },
    {
      "qNo": 2,
      "theme": "情報セキュリティ対策の強化",
      "description": "T社は、従業員数300名の小売業者である。T社のネットワーク構成を図1に示す。\n\n### 図1 T社のネットワーク構成\n```mermaid\ngraph TD\n    Internet((インターネット)) --- FW[FW]\n    FW --- L3SW1[L3SW1]\n    \n    subgraph DMZ\n        L3SW1 --- L2SW1[L2SW1]\n        L2SW1 --- Spam[迷惑メール対策サーバ]\n        L2SW1 --- DNS[DNSサーバ]\n        L2SW1 --- Mail[外部メールサーバ]\n        L2SW1 --- Proxy[プロキシサーバ]\n    end\n    \n    subgraph InternalLAN [内部システムLAN]\n        L3SW1 --- L2SW2[L2SW2]\n        L2SW2 --- WebMail[Webメールサーバ]\n        L2SW2 --- SalesInfo[営業情報サーバ]\n        L2SW2 --- Business[業務サーバ]\n    end\n    \n    subgraph PC-LAN\n        L3SW1 --- L3SW2[L3SW2]\n        L3SW2 --- SalesLAN[営業部LAN]\n        L3SW2 --- BizLAN[業務部LAN]\n        L3SW2 --- SysLAN[システム部LAN]\n    end\n```\n\n[内部システムLAN上のサーバの概要]\n表1 内部システムLAN上のサーバの機能の概要（抜粋）\n| サーバ名 | IPアドレス | 機能概要 |\n| :--- | :--- | :--- |\n| Webメールサーバ | 192.168.1.11 | SMTPで、迷惑メール対策サーバからのメールを受信する。メール転送機能、Webブラウザでのメール送受信機能、マルウェアスキャン機能、送信ドメイン認証(SPF)機能、利用者ごとのインターネット送信可否設定機能、DNS機能を持つ。 |\n\n[DMZ上のサーバの概要]\n表2 DMZ上のサーバの機能の概要\n| サーバ名 | IPアドレス | 機能概要 |\n| :--- | :--- | :--- |\n| 迷惑メール対策サーバ | x1.y1.z1.2 | SMTPで受信したメールをWebメールサーバへ転送する。SPFによる認証、迷惑メール判定を行う。 |\n| DNSサーバ | x1.y1.z1.3 | インターネット向けのT社ドメイン名を管理する。オープンリゾルバ防止機能がある。 |\n| 外部メールサーバ | x1.y1.z1.4 | 転送されてきたメールをインターネットにSMTPで転送する。 |\n| プロキシサーバ | x1.y1.z1.5 | PCからのHTTP/HTTPS通信を中継する。CONNECTメソッドを利用する。アクセス制限機能、ポート制限機能（デフォルトは1023以下の宛先ポート番号を許可）を持つ。 |\n\n図2 T社ドメイン名に対するTXTレコードの設定内容\n`t-sha.co.jp.  IN TXT \"v=spf1 +ip4: [  a  ] -all\"`",
      "questions": [
        {
          "subQNo": "設問1",
          "text": "DMZ上のサーバ及びFWの概要について、答えよ。",
          "explanation": "### 解説\n(1) SPFレコードには、自社からメールを送信する正当なサーバのIPアドレスを記述します。T社では「外部メールサーバ」がインターネットへメールを送信するため、そのIPアドレス `x1.y1.z1.4` が入ります。\n(2) FWのフィルタリングルール（表3）を埋める問題です。項番1はインターネットから届くメール、項番2は内部へ転送されるメール、項番3は内部から外部へ送るメールの流れを考えます。\n\n### メールの流れ\n```mermaid\ngraph LR\n    I((インターネット)) -- SMTP --> Spam[迷惑メール対策サーバ]\n    Spam -- SMTP --> WM[Webメールサーバ]\n    WM -- SMTP --> EM[外部メールサーバ]\n    EM -- SMTP --> I\n```",
          "subQuestions": [
            {
              "label": "(1)",
              "text": "図2中の [ a ] に入れる適切な字句を答えよ。"
            },
            {
              "label": "(2)",
              "text": "表3中の [ b ] ～ [ d ] に入れる適切なサーバ名を答えよ。"
            }
          ]
        }
      ],
      "point": 33
    },
    {
      "qNo": 3,
      "theme": "LAN分離に関する記述",
      "description": "N社は、創薬ベンチャ企業である。従業員は10名で、研究開発員5名、事務員5名である。N社のネットワーク構成を図1に示す。N社が利用しているクラウドサービスを表1に示す。\n\n### 図1 N社のネットワーク構成\n```mermaid\ngraph TD\n    Internet((インターネット)) --- FW1[FW1]\n    FW1 --- L2SW[L2SW]\n    L2SW --- RD_File[研究開発用ファイルサーバ]\n    L2SW --- Gen_File[一般事務用ファイルサーバ]\n    L2SW --- DNS[内部DNSサーバ]\n    L2SW --- PC[社内PC]\n```\n\n### 表1 利用しているクラウドサービス\n| サービス名称 | 内容 |\n| :--- | :--- |\n| 電子メールサービス | 社内PCのメールソフトからのアクセスに応じて、メールの送受信を行う。 |\n| Webプロキシサービス | インターネット上のWebサイトへのアクセスを中継する。FW1は社内PCからの直接アクセスを禁止している。 |\n| 更新ファイル提供サービス | 社内PC等に脆弱性修正プログラム（パッチ）や定義ファイルを提供する。 |\n\n[リスクアセスメント]\nB取締役とRさんは、A氏の支援の下でリスクアセスメントを開始した。その結果、新薬ファイルに影響を及ぼすリスクの一覧として表2が得られた。\n\n### 表2 リスク一覧（抜粋）\n| 項番 | リスク | 内容 |\n| :--- | :--- | :--- |\n| リスク1 | インターネットからの不正侵入による新薬ファイルの漏えい | インターネット経由でファイルサーバに侵入され、新薬ファイルが流出する。 |\n| リスク2 | 標的型攻撃による新薬ファイルの漏えい | メールでマルウェアが送られ、PCやサーバが感染し、新薬ファイルが流出する。 |\n| リスク3 | 従業員の故意又は過失による新薬ファイルの漏えい | メールの誤送信やSNSへの書き込みによって、外部に流出する。 |\n\n[LAN分離案の検討]\nリスク2への対応として、新薬ファイルを保管する機器を収容する「研究開発LAN」と、それ以外の「事務LAN」に分離する。図3にLAN分離案を示す。\n\n### 図3 LAN分離案\n```mermaid\ngraph TD\n    Internet((インターネット)) --- FW2[FW2]\n    FW2 --- FW1[FW1]\n    \n    subgraph RD_LAN [研究開発LAN]\n        L2SW_RD[L2SW] --- RD_File2[研究開発用ファイルサーバ]\n        L2SW_RD --- RD_PC[研究開発用PC]\n    end\n    \n    subgraph Mid_LAN [中間LAN]\n        FW1 --- L2SW_Mid[L2SW]\n        L2SW_Mid --- File_Trans[ファイル転送サーバ]\n    end\n    \n    subgraph Biz_LAN [事務LAN]\n        FW1 --- L2SW_Biz[L2SW]\n        L2SW_Biz --- Gen_File2[一般事務用ファイルサーバ]\n        L2SW_Biz --- Biz_PC[事務用PC]\n        L2SW_Biz --- In_DNS[内部DNSサーバ]\n    end\n    \n    FW2 --- RD_LAN\n    FW2 --- Mid_LAN\n```",
      "questions": [
        {
          "subQNo": "設問1",
          "text": "[リスクアセスメント] について、(1), (2)に答えよ。",
          "explanation": "### 解説\nJIS Q 31000 におけるリスク管理プロセスの順序を問う問題です。\n1. **リスク特定** (a): どのようなリスクがあるかを洗い出す。\n2. **リスク分析**: リスクの大きさ（起こりやすさと結果）を特定する。\n3. **リスク評価** (b): 分析結果を基準と比較し、対策の優先順位を決める。\nこれらを合わせて「リスクアセスメント」と呼び、その後「リスク対応」を行います。",
          "subQuestions": [
            {
              "label": "(1)",
              "text": "本文中の [ a ], [ b ] に入れる適切な字句を解答群から選べ。"
            },
            {
              "label": "(2)",
              "text": "本文中の [ c ], [ d ] に入れる適切な字句を解答群から選べ。"
            }
          ]
        }
      ],
      "point": 33
    }
  ]
}