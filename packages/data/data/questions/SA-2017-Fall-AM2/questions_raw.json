{
  "questions": [
    {
      "qNo": 1,
      "text": "アジャイル開発プロセスにおいて, Bill Wake が提案した “INVEST” と呼ばれる六つの観点を用いて行うことはどれか。",
      "options": [
        {
          "id": "a",
          "text": "効率よくアクティビティ図を作成する。"
        },
        {
          "id": "b",
          "text": "コード化できるレベルまで詳細化されたデータフロー図を作成する。"
        },
        {
          "id": "c",
          "text": "再利用しやすいソフトウェアパターンとなっているかどうかを評価する。"
        },
        {
          "id": "d",
          "text": "質の高いユーザストーリーとなっているかどうかを評価する。"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "正解は **d** です。\n\n**INVEST**とは、アジャイル開発で使われる「ユーザーストーリー」が、開発を進める上で適切な品質を持っているかを確認するための、6つの観点をまとめた言葉です。\n\nユーザーストーリーは、「（誰）として、（何）をしたい。それは（なぜ）か」といった形式で記述される、ユーザー視点での要求のことです。\n\nINVESTは、良いユーザーストーリーが持つべき特性を、以下の6つの英単語の頭文字で表しています。\n\n*   **I**ndependent (独立している)\n*   **N**egotiable (交渉可能である)\n*   **V**aluable (価値がある)\n*   **E**stimable (見積り可能である)\n*   **S**mall (小さい)\n*   **T**estable (テスト可能である)\n\nこのように、INVESTはユーザーストーリーがこれらの基準を満たしているか、すなわち**質の高いユーザストーリーとなっているかどうかを評価する**ために使われます。したがって、dが正解です。\n\n- a, b, cは誤りです。INVESTは、アクティビティ図、データフロー図、ソフトウェアパターンの評価に用いられるものではありません。"
    },
    {
      "qNo": 2,
      "text": "機能要件と非機能要件のうち, 機能要件を満たすために行う設計はどれか。",
      "options": [
        {
          "id": "a",
          "text": "業務システムを開発するための開発環境を設計する。"
        },
        {
          "id": "b",
          "text": "業務の重要度を分析して障害発生時の復旧時間を明確にする。"
        },
        {
          "id": "c",
          "text": "業務を構成する要素間のデータの流れを明確にする。"
        },
        {
          "id": "d",
          "text": "部門業務の効率性と業務間の関連性を考慮して最適なサーバ配置を設計する。"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "この問題を理解するには、まず**機能要件**と**非機能要件**の違いをしっかり押さえることが大切です。\n\n*   **機能要件**: システムが**「何をするか」**を定めたもの。ユーザが行いたい業務を実現するための、具体的な機能に関する要件です。（例：商品を登録できる、売上レポートを出力できる）\n*   **非機能要件**: システムが**「どのように動くか」**を定めたもの。性能、信頼性、セキュリティなど、システムの品質や制約に関する要件です。（例：応答時間は3秒以内、24時間365日稼働する）\n\nこの問題は「機能要件を満たす設計はどれか？」と尋ねているので、「何をするか」を具体的に設計している選択肢を探します。\n\n- **c (正解):** 「業務を構成する要素間のデータの流れを明確にする」ことは、「誰がデータを入力し、システムがそれをどう処理して、何を出力するのか」という業務の流れ、つまり**システムの機能そのもの**を設計する行為です。したがって、これが正解です。\n\n- **a (誤り):** 開発環境の設計は、開発のしやすさといった**「保守性」**に関するもので、非機能要件です。\n- **b (誤り):** 障害からの復旧時間は、システムの**「信頼性」**に関する品質の話なので、非機能要件です。\n- **d (誤り):** 最適なサーバ配置は、システムの応答速度などの**「性能」**や可用性に関わるもので、非機能要件です。"
    },
    {
      "qNo": 3,
      "text": "図は “顧客が商品を注文する” を表現した UML のクラス図である。 “顧客が複数の商品をまとめて注文する” を表現したクラス図はどれか。ここで, 注文明細は注文に含まれる一つの商品に対応し, 注文は一つ以上の注文明細を束ねたもので, 一つの注文に対応する。\n\n```mermaid\nclassDiagram\n    顧客 \"1\" -- \"0..*\" 注文\n    注文 \"0..*\" -- \"1\" 商品\n```\n\n凡例:\n- クラス\n- 関連\n- コンポジション (塗りつぶされた菱形)\n- 多重度: 1 (必ず1), 0..* (0以上), 1..* (1以上)",
      "options": [
        {
          "id": "a",
          "text": "```mermaid\nclassDiagram\n    顧客 \"1\" -- \"0..*\" 注文\n    注文 \"1\" *-- \"1..*\" 注文明細\n    注文明細 \"0..*\" -- \"1\" 商品\n```"
        },
        {
          "id": "b",
          "text": "```mermaid\nclassDiagram\n    顧客 \"1\" -- \"0..*\" 注文\n    注文 \"1..*\" --* \"1\" 注文明細\n    注文明細 \"0..*\" -- \"1\" 商品\n```"
        },
        {
          "id": "c",
          "text": "```mermaid\nclassDiagram\n    注文 \"1\" *-- \"1..*\" 注文明細\n    注文 \"0..*\" -- \"1\" 商品\n    顧客 \"1\" -- \"0..*\" 注文明細\n```"
        },
        {
          "id": "d",
          "text": "```mermaid\nclassDiagram\n    注文 \"0..*\" -- \"1\" 商品\n    注文 \"1..*\" --* \"1\" 注文明細\n    顧客 \"1\" -- \"0..*\" 注文明細\n```"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "この問題は、1回の注文で複数の商品を扱えるように、UMLのクラス図を正しく変更するものです。元の図では「注文」と「商品」が直接結びついており、1回の注文で1種類の商品しか扱えません。\n\n複数の商品を扱うには、「注文」と「商品」の間に**「注文明細」**というクラスを設けるのが一般的です。これにより、1つの「注文」に複数の「注文明細」がぶら下がり、各「注文明細」が個別の「商品」と数量を管理できます。\n\n- **正解 a の解説**\n    - **`注文 \"1\" *-- \"1..*\" 注文明細`**: 1つの「注文」は、**1つ以上**（`1..*`）の「注文明細」から構成される、という関係を正しく表現しています。黒い菱形◆（コンポジション）は、「注文」がなくなれば「注文明細」も存在しなくなるという、全体と部分の強い関係を示します。\n    - **`注文明細 \"0..*\" -- \"1\" 商品`**: 1つの「注文明細」は、必ず**1つ**（`1`）の「商品」に対応することを表します。\n    - **`顧客 \"1\" -- \"0..*\" 注文`**: 顧客と注文の関係は元の図から変更ありません。\n\n- **その他の選択肢**\n    - **b**: 「注文」と「注文明細」の多重度が逆になっています。\n    - **c, d**: 「顧客」が直接「注文明細」を持つ関係になっていたり、元の「注文」と「商品」の関係が残っていたりするため、不適切です。"
    },
    {
      "qNo": 4,
      "text": "複数のシステムの組合せによって実現する SoS (System of Systems) をモデル化するのに適した表記法である SysML の特徴はどれか。",
      "options": [
        {
          "id": "a",
          "text": "オブジェクト図によって, インスタンスの静的なスナップショットが記述できる。"
        },
        {
          "id": "b",
          "text": "単純な図形と矢印によって, システムのデータの流れが記述できる。"
        },
        {
          "id": "c",
          "text": "パラメトリック図によって, モデル要素間の制約条件が記述できる。"
        },
        {
          "id": "d",
          "text": "連接, 反復, 選択の記述パターンによって, ソフトウェアの構造を分かりやすく視覚化できる。"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "SysML (Systems Modeling Language) は、ソフトウェアだけでなく、ハードウェアやプロセスなども含めた**システム全体を設計するためのモデリング言語**です。特に、複数の独立したシステムが連携して動作するSoS (System of Systems) のような、複雑なシステムのモデル化に適しています。\n\n*   **c. (正解)**\n    SysMLの大きな特徴の一つに**パラメトリック図**があります。これは、システムの性能（例：速度、応答時間）や物理的な制約（例：重さ、消費電力）などを数式で表現し、システム間の関係性や制約条件を明確にするための図です。SoSでは、構成要素となる各システムの性能が全体の目標達成にどう影響するかを分析する必要があるため、このパラメトリック図が非常に有効です。\n\n*   **a.** オブジェクト図は、SysMLの基になったUMLにも含まれる基本的な図であり、SoSのモデル化に適したSysML「ならでは」の特徴とは言えません。\n*   **b.** 単純な図形と矢印でデータの流れを記述するのは、DFD (Data Flow Diagram) という別の手法の説明です。\n*   **d.** 「連接, 反復, 選択」は、PAD (Problem Analysis Diagram) やフローチャートで用いられるソフトウェアの構造化の考え方です。"
    },
    {
      "qNo": 5,
      "text": "ソフトウェアパターンのうち, GoF のデザインパターンの説明はどれか。",
      "options": [
        {
          "id": "a",
          "text": "Java のパターンとして引数オブジェクト, オブジェクトの可変性などで構成される。"
        },
        {
          "id": "b",
          "text": "オブジェクト指向開発のためのパターンとして生成, 構造, 振る舞いの三つのカテゴリで分類される。"
        },
        {
          "id": "c",
          "text": "構造, 分散システム, 対話型システム及び適合型システムの四つのカテゴリで分類される。"
        },
        {
          "id": "d",
          "text": "抽象度が異なる要素を分割して階層化するための Layers, コンポーネント分割のための Broker などで構成される。"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "GoF（Gang of Four）のデザインパターンとは、オブジェクト指向プログラミングにおける設計上の問題を解決するための、再利用可能な23種類の「設計の型（パターン）」をまとめたものです。\n\n-   **b. (正解)**\n    GoFのデザインパターンは、その目的と役割に応じて、以下の3つのカテゴリに分類されます。この分類はGoFのデザインパターンの最も重要な特徴です。\n    -   **生成**: オブジェクトを効率的に生成するためのパターン\n    -   **構造**: クラスやオブジェクトを組み合わせて、より大きな構造を作るためのパターン\n    -   **振る舞い**: オブジェクト間の責務の割り当てや、アルゴリズムに関するパターン\n\n-   **a. (誤り)**\n    GoFのデザインパターンは、Javaに限定されたものではなく、C++やPythonなど、様々なオブジェクト指向言語で利用できる普遍的な概念です。\n\n-   **c, d. (誤り)**\n    これらは**POSA (Pattern-Oriented Software Architecture)** という、GoFとは異なるソフトウェアアーキテクチャパターンの説明です。「Layers」や「Broker」といったパターンはPOSAで紹介されているものであり、GoFのデザインパターンとは異なります。"
    },
    {
      "qNo": 6,
      "text": "組込みシステムの開発における, ハードウェアとソフトウェアのコデザインを適用した開発手法の説明として, 適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "ハードウェアとソフトウェアの切分けをシミュレーションによって十分に検証し, その後もシミュレーションを活用しながらハードウェアとソフトウェアを並行して開発していく手法"
        },
        {
          "id": "b",
          "text": "ハードウェアの開発とソフトウェアの開発を独立して行い, それぞれの完了後に組み合わせて統合テストを行う手法"
        },
        {
          "id": "c",
          "text": "ハードウェアの開発をアウトソーシングし, ソフトウェアの開発に注力することによって, 短期間に高機能の製品を市場に出す手法"
        },
        {
          "id": "d",
          "text": "ハードウェアをプラットフォーム化し, 主にソフトウェアで機能を差別化することによって, 短期間に多数の製品ラインアップを構築する手法"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "ハードウェアとソフトウェアの**コデザイン（Co-design）**とは、「Co（共同）」という言葉が示す通り、ハードウェアとソフトウェアを個別に開発するのではなく、**協調させながら設計・開発を進める手法**です。開発の初期段階で、両者の最適な機能分担を決め、並行して開発することで、開発期間の短縮やシステム全体の性能向上を目指します。\n\n-   **a. 正解**\n    選択肢aは、コデザインの典型的な流れを説明しています。まずシミュレーション（コンピュータ上での模擬実験）でハードウェアとソフトウェアの最適な役割分担（切分け）を検証し、その後も連携しながら**並行して開発を進める**という点が、コデザインの考え方と一致します。\n\n-   **b. 誤り**\n    ハードウェアとソフトウェアを**独立して**開発し、最後に結合する手法です。これは協調を重視するコデザインとは逆のアプローチです。\n\n-   **c. 誤り**\n    開発の一部を外部委託する（アウトソーシング）という経営戦略の話であり、コデザインという開発手法そのものの説明ではありません。\n\n-   **d. 誤り**\n    これは「プラットフォームベース開発」と呼ばれる手法です。共通のハードウェア基盤を用いる点で効率的ですが、コデザインの核となる「初期段階での協調設計」とは少し異なります。"
    },
    {
      "qNo": 7,
      "text": "イベント駆動型のアプリケーションにおけるイベント処理のタイミングを設計するのに有用なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "DFD"
        },
        {
          "id": "b",
          "text": "E-R 図"
        },
        {
          "id": "c",
          "text": "シーケンス図"
        },
        {
          "id": "d",
          "text": "ペトリネット"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "この問題は、システムの振る舞いを表現する様々な図の中から、目的に合ったものを選ぶ知識を問うています。イベント駆動型アプリケーションとは、ユーザのクリック操作などの「イベント」をきっかけに処理が動くアプリケーションのことです。\n\n**正解はcのシーケンス図です。**\n\n*   **c: シーケンス図**\n    プログラムを構成する部品（オブジェクト）同士が、メッセージをどのように送り合うかを**時系列**で表現する図です。縦の軸が時間の流れを示しており、「イベントが発生してから、どの部品がどの順番で処理を行うか」という**処理のタイミング**を設計するのに非常に適しています。\n\n**その他の選択肢**\n\n*   **a: DFD (Data Flow Diagram)**\n    データの流れに着目した図です。「どこから来たデータが、どう処理されて、どこへ行くか」を示しますが、処理の順序やタイミングは表現しません。\n*   **b: E-R図 (Entity-Relationship Diagram)**\n    システムが扱うデータの構造と、データ同士の関連性を表現する図です。主にデータベースの設計で使われ、プログラムの動作とは関係ありません。\n*   **d: ペトリネット**\n    複数の処理が同時に動くような、複雑なシステムの振る舞いを厳密にモデル化するための図です。イベント処理のタイミング設計も可能ですが、シーケンス図の方がより直感的で一般的に用いられます。"
    },
    {
      "qNo": 8,
      "text": "フェールセーフの考えに基づいて設計したものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "乾電池のプラスとマイナスを逆にすると, 乾電池が装填できないようにする。"
        },
        {
          "id": "b",
          "text": "交通管制システムが故障したときには, 信号機に赤色が点灯するようにする。"
        },
        {
          "id": "c",
          "text": "ネットワークカードのコントローラを二重化しておき, 故障したコントローラの方を切り離しても運用できるようにする。"
        },
        {
          "id": "d",
          "text": "ハードディスクに RAID1 を採用して, MTBF で示される信頼性が向上するようにする。"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "この問題は、システムの信頼性に関する設計思想の違いを理解しているかを問うています。\n\n**フェールセーフ (Fail Safe)** とは、システムに故障（Fail）が発生した場合に、**常に安全（Safe）な状態**へ移行させる設計思想です。危険な状態になることを防ぎ、被害を最小限に抑えることを最優先します。\n\n*   **b (正解):** 交通管制システムが故障した際に、信号機を赤色で点灯させるのは、車両を停止させて事故の発生を防ぐという、最も安全な状態に移行させる考え方です。これはフェールセーフの典型例です。\n\n*   **a:** 利用者の誤った操作（電池の逆挿入）を物理的に防ぐ設計は、**フールプルーフ**（fool-proof）と呼ばれます。\n\n*   **c, d:** 故障が発生しても、予備の装置（二重化したコントローラやRAID1のディスク）に切り替えて、**システムを停止させずに処理を継続する**設計は、**フォールトトレラント**（fault-tolerant）と呼ばれます。\n\nこのように、「安全側に倒す」のがフェールセーフ、「止めずに耐える」のがフォールトトレラント、「誤操作させない」のがフールプルーフと区別して覚えましょう。"
    },
    {
      "qNo": 9,
      "text": "ソフトウェアの潜在エラー数を推定する方法の一つにエラー埋込み法がある。100 個のエラーを意図的に埋め込んだプログラムを, そのエラーの存在を知らない検査グループがテストして 30 個のエラーを発見した。そのうち 20 個は意図的に埋め込んでおいたものであった。この時点で, このプログラムの埋込みエラーを除く残存エラー数は幾つと推定できるか。",
      "options": [
        {
          "id": "a",
          "text": "40"
        },
        {
          "id": "b",
          "text": "50"
        },
        {
          "id": "c",
          "text": "70"
        },
        {
          "id": "d",
          "text": "150"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "エラー埋込み法は、プログラムに意図的にエラーを埋め込み、テストでそれがどのくらいの割合で発見されるか（発見率）を調べることで、元々プログラムに潜んでいるエラー（潜在エラー）の総数を推定する手法です。\n\nこの問題では、以下のステップで考えます。\n\n1.  **テストチームの「エラー発見率」を求めます。**\n    - 100個埋め込んだエラーのうち20個を発見したので、発見率は `20 ÷ 100 = 0.2` (20%) です。\n    - このチームは、プログラムに存在するエラーの20%を見つけ出す能力があると仮定できます。\n\n2.  **元々あったエラーの総数を推定します。**\n    - 発見された30個のエラーのうち、埋め込まれたものでない「元々のエラー」は `30 - 20 = 10` 個です。\n    - この10個が、元々あったエラー全体の20%にあたると考えられるため、元々のエラーの総数は `10 ÷ 0.2 = 50` 個と推定できます。\n\n3.  **残存エラー数を計算します。**\n    - 求めたいのは「まだ見つかっていない元々のエラー数」です。\n    - 推定した元々のエラー総数50個から、発見済みの10個を引きます。\n    - `50 - 10 = 40` 個\n\nしたがって、正解は **a** の40です。\n\n- **b: 50** は、残存数ではなく、元々あったエラーの「総数」の推定値です。\n- **c: 70** や **d: 150** は、発見率を正しく用いていない計算結果です。"
    },
    {
      "qNo": 10,
      "text": "ハードウェアの経験が豊富なプログラマ A と, 経験の少ないプログラマ B がペアプログラミングの手法を利用して組込みシステムの開発を進める。ペアプログラミングによる開発の進め方として, 適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "A がデバイスドライバの開発を担当し, B がアプリケーションの開発を担当する。"
        },
        {
          "id": "b",
          "text": "A がプロジェクトマネージャとして, プロジェクトの調整役になる。"
        },
        {
          "id": "c",
          "text": "A と B がエディタの画面を共有し, B が記述したコードに対して A が助言する。"
        },
        {
          "id": "d",
          "text": "ハードウェアとソフトウェアの切分けをシミュレーションで検証してから, A と B とで分担して開発する。"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "この問題のポイントは「ペアプログラミング」がどのような開発手法かを理解しているかです。\n\nペアプログラミングとは、2人1組で1つのコンピュータを使い、共同でプログラムを作成する手法です。一人が実際にコードを書く**「ドライバー」**、もう一人がそのコードをレビューし、次の展開を考えたり助言したりする**「ナビゲーター」**という役割を担い、適宜交代しながら進めます。\n\n-   **c: 正解です。**\n    この選択肢は、ペアプログラミングの典型的な進め方そのものです。経験の少ないBが「ドライバー」としてコードを書き、経験豊富なAが「ナビゲーター」として助言することで、リアルタイムでのレビューや技術の継承が行われ、コードの品質向上と人材育成を同時に実現できます。\n\n-   **a, d:** 誤りです。これらは単に作業を分担しているだけであり、2人で1つのプログラムを共同作成するペアプログラミングとは異なります。\n\n-   **b:** 誤りです。Aがプログラミング作業ではなく管理業務を行っているため、ペアプログラミングにはあたりません。"
    },
    {
      "qNo": 11,
      "text": "探索的テスト技法の説明はどれか。",
      "options": [
        {
          "id": "a",
          "text": "起こり得る全ての条件と, それに対して実行すべき動作とを組み合わせた表に基づいてテストする技法"
        },
        {
          "id": "b",
          "text": "経験に基づいて, 起こりがちなエラーを推測してテストケースを決定する技法"
        },
        {
          "id": "c",
          "text": "経験や推測から重要と思われる領域に焦点を当ててテストし, その結果を基にした新たなテストケースを作成して, テストを繰り返す技法"
        },
        {
          "id": "d",
          "text": "システムの取り得る状態と, 状態を遷移させる事象又は条件を示した図に基づいてテストする技法"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "正解は選択肢 **c** です。\n\n**探索的テスト**は、事前に詳細なテスト計画やテストケースをがっちり固めるのではなく、テスト対象のソフトウェアを操作しながら学び、その場で得た気づきや発見に基づいて、次に実施するテストを考えて実行していく、柔軟なテスト技法です。\n選択肢cの「**テストし, その結果を基にした新たなテストケースを作成して, テストを繰り返す**」という説明は、この「学習」「実行」「設計」のサイクルを繰り返す探索的テストの特徴を的確に表しています。\n\nその他の選択肢は以下の通りです。\n*   **a**: 条件と動作の組み合わせ表を用いるのは「**デシジョンテーブルテスト**」です。\n*   **b**: 経験からエラーを推測するのは「**エラー推測テスト**」です。探索的テストと似ていますが、「結果を基にテストを繰り返す」という動的な側面が探索的テストの重要な特徴です。\n*   **d**: 状態遷移図を用いるのは「**状態遷移テスト**」です。"
    },
    {
      "qNo": 12,
      "text": "故障の予防を目的とした解析手法である FMEA の説明はどれか。",
      "options": [
        {
          "id": "a",
          "text": "個々のシステム構成要素に起こり得る潜在的な故障モードを特定し, それらの影響度を評価する。"
        },
        {
          "id": "b",
          "text": "故障を, 発生した工程や箇所などで分類し, 改善すべき工程や箇所を特定する。"
        },
        {
          "id": "c",
          "text": "発生した故障について, 故障の原因に関係するデータ, 事象などを収集し, “なぜ”を繰り返して原因を掘り下げ, 根本的な原因を追究する。"
        },
        {
          "id": "d",
          "text": "発生した故障について, その引き金となる原因を列挙し, それらの関係を木構造で表現する。"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "FMEA（Failure Mode and Effects Analysis：故障モード影響解析）は、故障を**未然に防ぐ（予防する）**ことを目的とした分析手法です。システムを構成する部品や工程ごとに、起こりうる潜在的な故障（故障モード）を洗い出し、その故障がシステム全体にどのような影響を与えるかを評価・分析します。\n\n*   **a: 正解です。** FMEAの定義そのものです。「潜在的な故障モードを特定」し、「影響度を評価する」という点が、故障の予防を目的としたFMEAの活動内容と一致します。\n\n*   **b: 誤りです。** これは**パレート図**を用いた分析の説明です。発生した不良や故障を項目別に分類し、件数の多い順に並べて、どの項目から対策すべきか優先順位を判断する際に使います。\n\n*   **c: 誤りです。** これは**なぜなぜ分析**の説明です。発生した問題に対して「なぜ？」を5回など繰り返し、根本的な原因を追究する手法です。\n\n*   **d: 誤りです。** これは**FTA（Fault Tree Analysis：故障の木解析）**の説明です。特定の重大な故障（例えばシステムのダウン）を頂点に置き、その原因となる事象をツリー状に展開して解析する手法です。"
    },
    {
      "qNo": 13,
      "text": "銀行の勘定系システムなどのような特定の分野のシステムに対して, 業務知識, 再利用部品, ツールなどを体系的に整備し, 再利用を促進することによって, ソフトウェア開発の効率向上を図る活動や手法はどれか。",
      "options": [
        {
          "id": "a",
          "text": "コンカレントエンジニアリング"
        },
        {
          "id": "b",
          "text": "ドメインエンジニアリング"
        },
        {
          "id": "c",
          "text": "フォワードエンジニアリング"
        },
        {
          "id": "d",
          "text": "リバースエンジニアリング"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "この問題のポイントは、「特定の分野」と「再利用」です。\n\n**ドメインエンジニアリング**は、特定の業務分野（**ドメイン**）に特化して、そこで共通して使えるソフトウェア部品や設計ノウハウなどを資産として体系的に整備し、再利用することで開発効率を上げる手法です。問題文の「銀行の勘定系システム」という特定の分野で、「業務知識や再利用部品を整備し、効率向上を図る」という記述は、まさにドメインエンジニアリングの説明そのものです。したがって、**b**が正解です。\n\n他の選択肢も確認しておきましょう。\n\n*   **a: コンカレントエンジニアリング**は、設計や製造など、開発の各工程を同時並行で進めることで開発期間を短縮する手法です。\n*   **c: フォワードエンジニアリング**は、要求定義→設計→実装という、通常の順序でソフトウェアを開発するプロセスを指します。\n*   **d: リバースエンジニアリング**は、既存のソフトウェアを解析して、その仕様や設計情報を明らかにすることです。開発とは逆の方向の作業になります。"
    },
    {
      "qNo": 14,
      "text": "IT 投資を, 投資目的によって表のように分類した。IT 投資評価の KPI のうち, 戦略的投資に対する KPI の例はどれか。\n\n| 分類 | 投資目的 |\n|---|---|\n| 業務効率投資 | 業務の効率向上, 業務の生産性向上など |\n| 情報活用投資 | ナレッジの共有, 管理精度の向上など |\n| 戦略的投資 | 競争優位の確立, ビジネスの創出など |\n| IT 基盤投資 | IT コスト削減, システム性能向上など |",
      "options": [
        {
          "id": "a",
          "text": "システムの障害件数"
        },
        {
          "id": "b",
          "text": "新製品投入後の市場シェア"
        },
        {
          "id": "c",
          "text": "提案事例の登録件数"
        },
        {
          "id": "d",
          "text": "連結決算処理の所要日数"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "この問題は、IT投資の目的と、その成果を測るための指標（KPI）の正しい組み合わせを選ぶ問題です。KPIとは「Key Performance Indicator」の略で、目標の達成度合いを測るための具体的な指標を指します。\n\nまず、問題で問われている**「戦略的投資」**の目的を確認しましょう。表によると、その目的は**「競争優位の確立」**や**「ビジネスの創出」**です。つまり、会社の将来の成長や、他社との競争に勝つための投資を指します。\n\n*   **b (正解):** 「新製品投入後の市場シェア」は、新しいビジネスが市場にどれだけ受け入れられ、競争相手に対して優位に立てたかを示す直接的な指標です。したがって、戦略的投資の成果を測るKPIとして最も適切です。\n\n他の選択肢も見てみましょう。\n*   **a: システムの障害件数** は、システムの安定性に関する指標であり、**「IT基盤投資」**のKPIです。\n*   **c: 提案事例の登録件数** は、社内での知識共有の度合いを示す指標であり、**「情報活用投資」**のKPIです。\n*   **d: 連結決算処理の所要日数** は、業務がどれだけ速くなったかを示す指標であり、**「業務効率投資」**のKPIです。"
    },
    {
      "qNo": 15,
      "text": "グラントバックの説明はどれか。",
      "options": [
        {
          "id": "a",
          "text": "異なる分野で特許技術をもつ事業者同士が技術供与協定を締結し, 互いに無償で特許の実施権を許諾すること"
        },
        {
          "id": "b",
          "text": "自社固有のビジネスモデルに関してビジネスモデル特許を取得した上で, 無償で広くその利用を許諾すること"
        },
        {
          "id": "c",
          "text": "ライセンスを受けた者が特許技術を改良し, 新たに取得した特許は, ライセンスを与えた者に実施権が許諾されること"
        },
        {
          "id": "d",
          "text": "ライセンスを受けた者が特許技術を改良し, 新たに取得した特許は, ライセンスを与えた者へ譲渡される義務が課されること"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "正解は **c** です。\n\n「グラントバック」とは、特許技術のライセンス（利用許諾）契約における条件の一つです。具体的には、ライセンスを受けた側（ライセンシ）が、その技術を基に改良を加えて新たな特許（改良特許）を取得した場合、その改良特許を使う権利（**実施権**）を、元のライセンスを与えた側（ライセンサー）に許諾（**バック**）することを指します。選択肢cはこの内容を正しく説明しています。\n\nその他の選択肢は以下の通りです。\n\n*   **a**: 事業者同士が互いの特許の実施権を許諾し合うことで、「**クロスライセンス**」と呼ばれます。\n*   **b**: 特許技術を無償で広く公開する戦略で、「**オープンパテント（特許の開放）**」の一例です。\n*   **d**: 改良特許の「実施権」ではなく、特許権そのものを譲渡する義務を課すもので、「**アサインバック**」と呼ばれます。グラントバックよりも強い拘束力があります。"
    },
    {
      "qNo": 16,
      "text": "システム開発における発注者とベンダとの契約方法のうち, 実費償還型契約はどれか。",
      "options": [
        {
          "id": "a",
          "text": "委託業務の進行中に発生するリスクはベンダが負い, 発注者は注文時に合意した価格を支払う。"
        },
        {
          "id": "b",
          "text": "インフレ率や特定の製品の調達コストの変化に応じて, あらかじめ決められた契約金額を調整する。"
        },
        {
          "id": "c",
          "text": "契約時に, 目標とするコスト, 利益, 利益配分率, 上限額を合意し, 目標とするコストと実際に発生したコストの差異に基づいて利益を配分する。"
        },
        {
          "id": "d",
          "text": "ベンダの役務や技術に対する報酬に加え, 委託業務の遂行に要した費用の全てをベンダに支払う。"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "正解は **d** です。\n\n**実費償還型契約**とは、システム開発で実際にかかった費用（人件費、機材費など）の全額と、ベンダ（開発会社）の利益となる報酬を発注者が支払う契約形態です。「コストプラスフィー契約」とも呼ばれます。\n\n-   **d (正解)**: 「委託業務の遂行に要した費用の全て（＝実費）」と「役務や技術に対する報酬（＝利益）」を支払うと説明しており、**実費償還型契約の定義そのもの**です。要件がまだ固まっていないプロジェクトなどで、仕様変更のリスクを発注者側が負担する場合に用いられます。\n\n---\n### 他の選択肢\n\n-   **a**: 最初に価格を決めてしまう契約方法で、「**定額請負契約**」と呼ばれます。コスト超過のリスクはベンダが負います。\n-   **b**: 経済状況の変化に応じて価格を調整する条項が付いた「**定額契約**」の一種です。\n-   **c**: 目標コストと実績の差に応じて利益を配分する「**インセンティブ契約**」の説明です。コストを削減できた場合に、その利益を発注者とベンダで分け合うような契約です。"
    },
    {
      "qNo": 17,
      "text": "ビッグデータを有効活用し, 事業価値を生み出す役割を担う専門人材であるデータサイエンティストに求められるスキルセットを表の三つの領域と定義した。データサイエンスに該当する具体的なスキルはどれか。\n\n| 領域 | 定義 |\n|---|---|\n| ビジネス力 | 課題の背景を理解した上で, ビジネス課題を整理・分析し, 解決する力 |\n| データサイエンス力 | 人工知能や統計学などの情報科学に関する知識を用いて, 予測, 検定, 関係性の把握及びデータ加工・可視化する力 |\n| データエンジニアリング力 | データ分析によって作成したモデルを使えるように, 分析システムを実装, 運用する力 |",
      "options": [
        {
          "id": "a",
          "text": "扱うデータの規模や機密性を理解した上で, 分析システムをオンプレミスで構築するか, クラウドコンピューティングを利用して構築するか判断し設計できる。"
        },
        {
          "id": "b",
          "text": "事業モデルやバリューチェーンなどの特徴や事業の主たる課題を自力で構造的に理解でき, 問題の大枠を整理できる。"
        },
        {
          "id": "c",
          "text": "分散処理のフレームワークを用いて, 計算処理を複数サーバに分散させる並列処理システムを設計できる。"
        },
        {
          "id": "d",
          "text": "分析要件に応じ, 決定木分析, ニューラルネットワークなどのモデリング手法の選択, モデルへのパラメタの設定, 分析結果の評価ができる。"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "この問題は、データサイエンティストに求められる3つのスキル領域のうち、「データサイエンス力」に該当するものを選ぶ問題です。\n\n正解は選択肢 **d** です。\n\n問題の表にある「データサイエンス力」の定義は、「人工知能や統計学などの情報科学に関する知識を用いて、予測...する力」です。\n\n- **d (正解):** 「決定木分析」や「ニューラルネットワーク」は、まさに人工知能や統計学の具体的な分析手法です。これらの手法を用いてモデルを作成し、評価するスキルは、データから価値ある知見を引き出すための中心的な活動であり、「データサイエンス力」そのものです。\n\n### 他選択肢の解説\n- **a**と**c**は、分析システムを構築・運用するための技術的なスキルです。これは「分析システムを実装、運用する力」と定義される「**データエンジニアリング力**」に該当します。\n- **b**は、ビジネスの課題を理解し、分析の方向性を定めるスキルです。これは「ビジネス課題を整理・分析し、解決する力」と定義される「**ビジネス力**」に該当します。\n\nこのように、各スキル領域の定義と選択肢の内容を照らし合わせることで、正解を導き出すことができます。"
    },
    {
      "qNo": 18,
      "text": "表の CPI と構成比率で, 3 種類の演算命令が合計 1,000,000 命令実行されるプログラムを, クロック周波数が 1 GHz のプロセッサで実行するのに必要な時間は何ミリ秒か。\n\n| 演算命令 | CPI (Cycles Per Instruction) | 構成比率 (%) |\n|---|---|---|\n| 浮動小数点加算 | 3 | 20 |\n| 浮動小数点乗算 | 5 | 20 |\n| 整数演算 | 2 | 60 |",
      "options": [
        {
          "id": "a",
          "text": "0.4"
        },
        {
          "id": "b",
          "text": "2.8"
        },
        {
          "id": "c",
          "text": "4.0"
        },
        {
          "id": "d",
          "text": "28.0"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "この問題は、プロセッサの性能指標を用いてプログラムの実行時間を計算する問題です。以下のステップで解いていきましょう。\n\n1.  **平均CPIの計算**\n    まず、プログラム全体での「1命令あたりの平均クロックサイクル数（平均CPI）」を求めます。**CPI (Cycles Per Instruction)** とは、1つの命令を実行するために必要なクロックの回数を示す値です。各命令のCPIに、その命令が全体の何%を占めるか（構成比率）を掛けて、すべて足し合わせます。\n    *   平均CPI = (3 × 0.2) + (5 × 0.2) + (2 × 0.6) = 0.6 + 1.0 + 1.2 = **2.8**\n\n2.  **実行時間の計算**\n    次に、全体の実行時間を計算します。実行時間は、以下の式で求められます。\n    `実行時間 = (総命令数 × 平均CPI) ÷ クロック周波数`\n    *   総命令数：1,000,000 命令\n    *   クロック周波数：1 GHz = 1,000,000,000 Hz（1秒間に10億回クロックが進む）\n    *   実行時間 = (1,000,000 × 2.8) ÷ 1,000,000,000 = 2,800,000 ÷ 1,000,000,000 = **0.0028 秒**\n\n3.  **単位の変換**\n    最後に、問題で問われている「ミリ秒」に単位を変換します（1秒 = 1000ミリ秒）。\n    *   0.0028秒 × 1000 = **2.8 ミリ秒**\n\nしたがって、正解は **b** です。他の選択肢は、平均CPIの計算ミスや、単位の変換ミスによって生じる誤った値です。"
    },
    {
      "qNo": 19,
      "text": "Web ブラウザや HTTP を用いず, 独自の GUI とデータ転送機構を用いた, ネットワーク対戦型のゲームを作成する。仕様の (2) の実現に用いることができる仕組みはどれか。\n\n〔仕様〕\n(1) ゲームは囲碁や将棋のように 2 人のプレーヤの間で行われ, ゲームの状態はサーバで管理する。プレーヤはそれぞれクライアントプログラムを操作してゲームに参加する。\n(2) プレーヤが新たな手を打ったとき, クライアントプログラムはサーバにある関数を呼び出す。サーバにある関数は, その手がルールに従っているかどうかを調べて, ルールに従った手であればゲームの状態を変化させ, そうでなければその手が無効であることをクライアントプログラムに知らせる。\n(3) ゲームの状態に変化があれば, サーバは各クライアントプログラムにその旨を知らせることによって GUI に反映させる。",
      "options": [
        {
          "id": "a",
          "text": "CGI"
        },
        {
          "id": "b",
          "text": "PHP"
        },
        {
          "id": "c",
          "text": "RPC"
        },
        {
          "id": "d",
          "text": "XML"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "この問題の正解は **c: RPC** です。\n\n**RPC (Remote Procedure Call)** は、日本語で「遠隔手続き呼出し」と訳されます。これは、ネットワークで接続された他のコンピュータ上にあるプログラム（関数や手続き）を、まるで自分のプログラムの一部であるかのように直接呼び出すための仕組みです。\n\n問題の仕様には「クライアントプログラムはサーバにある関数を呼び出す」とあり、これはRPCの考え方と完全に一致します。また、「WebブラウザやHTTPを用いず」という条件にも、RPCは合致しています。\n\n### 他の選択肢がなぜ誤りか\n*   **a: CGI** と **b: PHP** は、主にWebサーバがWebブラウザからの要求（HTTP通信）に応じてプログラムを実行するための技術です。問題文の「HTTPを用いず」という条件に合いません。\n*   **d: XML** は、データを構造化して記述するためのマークアップ言語です。データの形式を定めるものであり、RPCのように関数を呼び出す「仕組み」そのものではありません。"
    },
    {
      "qNo": 20,
      "text": "マルチプロセッサによる並列処理で得られる高速化率 (単一プロセッサのときと比べた倍率) E を, 次の式によって評価する。r = 0.9 のアプリケーションの高速化率が r = 0.3 のものの 3 倍となるのは, プロセッサが何台のときか。\n\n$$E = \\frac{1}{1-r + \\frac{r}{n}}$$\n\nここで,\nn: プロセッサの台数 ($1 \\le n$)\nr: 対象とする処理のうち, 並列化が可能な部分の割合 ($0 \\le r \\le 1$)\nとし, 並列化に伴うオーバヘッドは考慮しないものとする。",
      "options": [
        {
          "id": "a",
          "text": "3"
        },
        {
          "id": "b",
          "text": "4"
        },
        {
          "id": "c",
          "text": "5"
        },
        {
          "id": "d",
          "text": "6"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "この問題は、並列処理による性能向上を計算する「アムダールの法則」に関する問題です。与えられた式を使って、プロセッサの台数 `n` を求めます。\n\nまず、問題文の条件を数式で表しましょう。\n- r = 0.9 のときの高速化率: $E_{0.9} = \\frac{1}{1-0.9 + \\frac{0.9}{n}}$\n- r = 0.3 のときの高速化率: $E_{0.3} = \\frac{1}{1-0.3 + \\frac{0.3}{n}}$\n\n条件は「$E_{0.9}$ が $E_{0.3}$ の3倍になる」なので、$E_{0.9} = 3 \\times E_{0.3}$ という式が成り立ちます。この式に、上の2つの式を代入して `n` を計算します。\n\n1.  **式を立てる**\n    $\\frac{1}{0.1 + \\frac{0.9}{n}} = 3 \\times \\frac{1}{0.7 + \\frac{0.3}{n}}$\n\n2.  **式を整理する**\n    両辺の逆数をとると、次のようになります。\n    $0.1 + \\frac{0.9}{n} = \\frac{0.7 + \\frac{0.3}{n}}{3}$\n\n3.  **`n` について解く**\n    - 両辺を3倍します: $0.3 + \\frac{2.7}{n} = 0.7 + \\frac{0.3}{n}$\n    - `n` の項を左辺に、定数を右辺に集めます: $\\frac{2.7}{n} - \\frac{0.3}{n} = 0.7 - 0.3$\n    - 計算します: $\\frac{2.4}{n} = 0.4$\n    - 最後に `n` を求めます: $n = \\frac{2.4}{0.4} = 6$\n\n計算の結果、プロセッサが**6台**のときに条件を満たすことがわかります。\nしたがって、正解は **d** です。他の選択肢は、この計算結果と一致しないため誤りとなります。"
    },
    {
      "qNo": 21,
      "text": "UML を用いて表した図のデータモデルを基にして設計したテーブルのうち, 適切なものはどれか。ここで, “担当委員会 ID” と “所属委員会 ID” は “委員会 ID” を参照する外部キーである。 “役員 ID” と “委員 ID” は “生徒 ID” を参照する外部キーである。実線の下線は主キー, 破線の下線は外部キーを表す。\n\n```mermaid\nclassDiagram\n    委員会 \"0..1\" -- \"1..*\" 役員 : 担当する\n    委員会 \"0..*\" -- \"1..*\" 委員 : 所属する\n    class 委員会 {\n        委員会ID\n        委員会名\n    }\n    class 役員 {\n        生徒\n        氏名\n    }\n    class 委員 {\n        氏名\n    }\n```",
      "options": [
        {
          "id": "a",
          "text": "委員会 (<u>委員会 ID</u>, 委員会名)\n所属関連 (<u>所属委員会 ID</u>, <u>委員 ID</u>)\n生徒 (<u>生徒 ID</u>, 氏名, <span style=\"text-decoration: underline dashed;\">担当委員会 ID</span>)"
        },
        {
          "id": "b",
          "text": "委員会 (<u>委員会 ID</u>, 委員会名)\n役員関連 (<u>担当委員会 ID</u>, <u>役員 ID</u>)\n生徒 (<u>生徒 ID</u>, 氏名, <span style=\"text-decoration: underline dashed;\">所属委員会 ID</span>)"
        },
        {
          "id": "c",
          "text": "委員会 (<u>委員会 ID</u>, 委員会名, <span style=\"text-decoration: underline dashed;\">委員 ID</span>)\n生徒 (<u>生徒 ID</u>, 氏名, <span style=\"text-decoration: underline dashed;\">所属委員会 ID</span>, <span style=\"text-decoration: underline dashed;\">担当委員会 ID</span>)"
        },
        {
          "id": "d",
          "text": "委員会 (<u>委員会 ID</u>, 委員会名, <span style=\"text-decoration: underline dashed;\">役員 ID</span>)\n生徒 (<u>生徒 ID</u>, 氏名, <span style=\"text-decoration: underline dashed;\">所属委員会 ID</span>)"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "この問題は、UMLクラス図で示されたクラス間の関係（関連）を、データベースのテーブルで正しく表現する方法を問うています。ポイントは、関連線の両端にある**多重度**（数字や`*`）の解釈です。\n\n1.  **「委員会」と「役員」の“担当する”関係**\n    - 多重度は `委員会 0..1` と `役員 1..*` です。これは、1人の役員が担当する委員会は0または1つ（`0..1`）、1つの委員会は1人以上の役員が担当する（`1..*`）という**「1対多」**の関係を表します。\n    - 「1対多」の関係は、**「多」側**のテーブルに、「1」側のテーブルの主キーを**外部キー**として持たせることで表現します。\n    - つまり、「役員」のデータを持つ「生徒」テーブルに、「委員会ID」を参照する「担当委員会ID」を外部キーとして追加するのが適切です。\n\n2.  **「委員会」と「委員」の“所属する”関係**\n    - 多重度は `委員会 0..*` と `委員 1..*` です。これは、1人の委員が複数の委員会に所属でき、1つの委員会にも複数の委員が所属できる**「多対多」**の関係を表します。\n    - 「多対多」の関係は、両者の主キーを外部キーとして持つ、新しい**関連テーブル（中間テーブル）**を作成して表現します。\n    - よって、「所属委員会ID」と「委員ID」を主キーとする「所属関連」テーブルを作成するのが適切です。\n\n以上の2点を満たしているのは選択肢**a**だけです。他の選択肢は、「多対多」の関係を外部キーだけで表現しようとしたり、「1対多」の関係に不要な関連テーブルを作成したりしているため、誤りとなります。"
    },
    {
      "qNo": 22,
      "text": "図は, 既存の電話機と PBX を使用した企業内の内線網を, IP ネットワークに統合する場合の接続構成を示している。図中の a ～ c に該当する装置の適切な組合せはどれか。\n\n電話機 --- [a] --- [b] --- [c] --- IPネットワーク\n\n| | a | b | c |\n|---|---|---|---|\n| ア | PBX | VoIP ゲートウェイ | ルータ |\n| イ | PBX | ルータ | VoIP ゲートウェイ |\n| ウ | VoIP ゲートウェイ | PBX | ルータ |\n| エ | VoIP ゲートウェイ | ルータ | PBX |",
      "options": [
        {
          "id": "a",
          "text": "ア"
        },
        {
          "id": "b",
          "text": "イ"
        },
        {
          "id": "c",
          "text": "ウ"
        },
        {
          "id": "d",
          "text": "エ"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "この問題は、既存の電話システムをIPネットワークに接続する際の機器の正しい順序を理解しているかを問う問題です。\n\n正解は選択肢**ア**です。各装置の役割を順に見ていきましょう。\n\n1.  **a: PBX (構内交換機)**\n    - まず、複数の既存の電話機を束ねて、内線通話や外線への発信を管理するために**PBX**が必要です。電話機は最初にPBXに接続されます。\n\n2.  **b: VoIPゲートウェイ**\n    - 次に、PBXからの音声信号を、IPネットワークで通信できるデータ形式（IPパケット）に変換する必要があります。この「音声信号とIPパケットの相互変換」という橋渡しの役割を担うのが**VoIPゲートウェイ**です。\n\n3.  **c: ルータ**\n    - 最後に、VoIPゲートウェイでIPパケット化されたデータを、社内のネットワークから外部のIPネットワークへ送り出すために**ルータ**が必要です。ルータは異なるネットワーク間を接続し、データの通り道を制御します。\n\nしたがって、「電話機 → PBX → VoIPゲートウェイ → ルータ → IPネットワーク」という接続順が正しい構成となります。他の選択肢は、これらの装置の役割や接続順序が異なっているため誤りです。"
    },
    {
      "qNo": 23,
      "text": "署名されたソフトウェアを導入する前に, そのソフトウェアの開発元又は発行元を確認するために使用する証明書はどれか。",
      "options": [
        {
          "id": "a",
          "text": "EV SSL 証明書"
        },
        {
          "id": "b",
          "text": "クライアント証明書"
        },
        {
          "id": "c",
          "text": "コードサイイニング証明書"
        },
        {
          "id": "d",
          "text": "サーバ証明書"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "正解は **c: コードサイニング証明書** です。\n\nソフトウェアを安全に利用するためには、「そのソフトウェアが本物であること（開発元が正しいこと）」と「途中で悪意のある第三者に書き換えられていないこと（改ざんされていないこと）」を確認する必要があります。\n\n- **c: コードサイニング証明書**は、この目的のために使われます。「コード（ソフトウェア）」に「サイニング（署名）」するための証明書で、開発元がこれを使ってデジタル署名を行います。これにより、利用者はソフトウェアの**発行元が正当であること**と、**改ざんされていないこと**をインストール前に確認できます。\n\n他の選択肢は以下の理由で誤りです。\n- **a: EV SSL 証明書**と**d: サーバ証明書**は、Webサイトの運営者が本物であることを証明するためのものです。\n- **b: クライアント証明書**は、Webサービスにログインする際などに、利用者（クライアント）自身が正当なユーザーであることを証明するために使います。"
    },
    {
      "qNo": 24,
      "text": "米国 NIST が制定した, AES における鍵長の条件はどれか。",
      "options": [
        {
          "id": "a",
          "text": "128 ビット, 192 ビット, 256 ビットから選択する。"
        },
        {
          "id": "b",
          "text": "256 ビット未満で任意に指定する。"
        },
        {
          "id": "c",
          "text": "暗号化処理単位のブロック長よりも 32 ビット長くする。"
        },
        {
          "id": "d",
          "text": "暗号化処理単位のブロック長よりも 32 ビット短くする。"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "AES（Advanced Encryption Standard）は、現在、世界標準として広く利用されている共通鍵暗号方式です。この規格は、米国のNIST（アメリカ国立標準技術研究所）によって公募・選定されました。\n\n-   **a. 正解です。**\n    NISTが定めたAESの規格では、鍵の長さ（鍵長）として**128ビット、192ビット、256ビット**の3種類が定義されています。利用者は、求めるセキュリティレベルや処理性能に応じて、この3つの中から1つを選択します。\n\n-   **b. 誤りです。**\n    鍵長は任意に指定できるわけではなく、規格で定められた3種類から選択する必要があります。\n\n-   **c, d. 誤りです。**\n    AESが一度に暗号化するデータのサイズ（ブロック長）は**128ビットで固定**です。鍵長はブロック長と直接的な関係（例：「ブロック長より32ビット長い」など）で決まるわけではありません。鍵長128ビットはブロック長と同じですが、192ビットや256ビットはブロック長より長くなります。"
    },
    {
      "qNo": 25,
      "text": "スパムメール対策として, サブミッションポート (ポート番号 587) を導入する目的はどれか。",
      "options": [
        {
          "id": "a",
          "text": "DNS サーバに SPF レコードを問い合わせる。"
        },
        {
          "id": "b",
          "text": "DNS サーバに登録されている公開鍵を用いて署名を検証する。"
        },
        {
          "id": "c",
          "text": "POP before SMTP を使用して, メール送信者を認証する。"
        },
        {
          "id": "d",
          "text": "SMTP-AUTH を使用して, メール送信者を認証する。"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "スパムメール対策として、メール送信の仕組みを理解することが重要です。\n\nメールを送信する際、利用者がメールサーバにメールを「提出（サブミッション）」するために使われるのが**サブミッションポート（ポート番号587）**です。このポートを利用する最大の目的は、**SMTP-AUTH（SMTP認証）**という仕組みを使って、メール送信者を確実に認証することにあります。\n\n*   **SMTP-AUTHとは？**\n    *   メールを送信するときに、IDとパスワードによる本人確認を行う仕組みです。\n    *   これにより、認証された正規の利用者だけがメールを送信できるようになり、なりすましや、無関係な第三者がサーバを不正に利用してスパムメールを送る「踏み台」にされるのを防ぎます。\n\nしたがって、正解は **d** となります。\n\n---\n*   **a (SPF)** と **b (署名検証)** は、受信側のサーバが送信元ドメインの正当性を検証するための技術であり、ポート番号とは直接関係ありません。\n*   **c (POP before SMTP)** は、メール受信（POP）を先に行うことで送信を許可する古い認証方式で、サブミッションポートの主目的ではありません。"
    }
  ]
}