{
  "questions": [
    {
      "qNo": 1,
      "text": "アジャイル開発プロセスにおいて，Bill Wake が提案した“INVEST”と呼ばれる六つの観点を用いて行うことはどれか。",
      "options": [
        {
          "id": "a",
          "text": "効率よくアクティビティ図を作成する。"
        },
        {
          "id": "b",
          "text": "コード化できるレベルまで詳細化されたデータフロー図を作成する。"
        },
        {
          "id": "c",
          "text": "再利用しやすいソフトウェアパターンとなっているかどうかを評価する。"
        },
        {
          "id": "d",
          "text": "質の高いユーザーストーリーとなっているかどうかを評価する。"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "アジャイル開発において用いられる「INVEST」は、**ユーザーストーリーの品質を評価するための六つの観点**をまとめたものです。ユーザーストーリーとは、「〇〇として、△△したい」のように、ユーザーの視点から要求を簡潔に記述したアジャイル開発の基本単位を指します。\n\nINVESTは、\n- **I**ndependent（独立している）\n- **N**egotiable（交渉可能である）\n- **V**aluable（価値がある）\n- **E**stimable（見積もり可能である）\n- **S**mall（小さい）\n- **T**estable（テスト可能である）\nの頭文字を取ったもので、これらの観点からユーザーストーリーが適切に書かれているかをチェックし、質の向上を目指します。\n\nしたがって、正解は**d**です。INVESTを用いることで、開発チームが理解しやすく、開発・テストしやすい質の高いユーザーストーリーとなっているか評価します。\n\n- aのアクティビティ図（システムの動作フローを記述するUMLの図）や、bのデータフロー図（データの流れを記述する図）は、それぞれシステムの振る舞いやデータの流れを表現する設計工程のツールであり、INVESTとは目的が異なります。\n- cのソフトウェアパターンは、設計の再利用性を高めるためのもので、ユーザーストーリーの評価とは関係ありません。"
    },
    {
      "qNo": 2,
      "text": "組込みシステムで DBMS を用いるときには，通信のオーバーヘッド，通信負荷の発生を防ぐこと，必要なメモリ容量をリソース制限内に抑えることなどを目的として，インプロセスデータベースを用いることがある。このインプロセスデータベースの説明として，適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "クライアントサーバ形式のクライアントとなるアプリケーションプログラムとソケットを介して通信し，SQL を用いて処理を記述する。"
        },
        {
          "id": "b",
          "text": "データベースエンジンはライブラリ形式で提供され，アプリケーションプログラムとリンクされて同一メモリ空間で動作する。"
        },
        {
          "id": "c",
          "text": "テーブルデータの全体をメモリ上に配置して，データベース処理を高速化する。"
        },
        {
          "id": "d",
          "text": "一つのテーブルを一つのファイルで管理し，アプリケーションプログラムからはファイル入出力の API で操作する。"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "インプロセスデータベースとは、データベース管理システム（DBMS）の機能をアプリケーションプログラム自身に組み込む形式のことです。\n\n正解は **b** です。\nインプロセスデータベースは、データベースエンジンがライブラリ（部品）として提供され、アプリケーションプログラムに直接組み込まれて、同じメモリ空間で動作します。これにより、アプリケーションとデータベースエンジン間の通信が不要になり、プロセス間通信によるオーバーヘッド（処理の無駄や遅延）や負荷の発生を防ぎます。これは、リソースが限られる組込みシステムに適した方式です。\n\n- **a** は、データベースとアプリケーションが別プロセスとして動作する「クライアントサーバ形式」の説明であり、ソケット通信によるオーバーヘッドが発生するため不適切です。\n- **c** は、データをメモリに置く「インメモリデータベース」の説明で、インプロセスとは別の概念です。インプロセスデータベースでもデータは通常ディスクに保存されます。\n- **d** は、DBMSではなくファイルシステムを直接操作する方法に近く、本来のDBMSの機能（トランザクション管理など）が欠けているため不適切です。"
    },
    {
      "qNo": 3,
      "text": "マイクロサービスアーキテクチャを採用してアプリケーションソフトウェアを設計している。障害発生による影響の範囲を局所化してシステム全体への波及を抑えるために，マイクロサービスへリクエストを送ったときのエラーが，あらかじめ設定している回数を超えた場合に，障害が解消するまでは，リクエストを送らない方式とする。この方式を何と呼ぶか。",
      "options": [
        {
          "id": "a",
          "text": "CQRS"
        },
        {
          "id": "b",
          "text": "RPC"
        },
        {
          "id": "c",
          "text": "サーキットブレーカー"
        },
        {
          "id": "d",
          "text": "サービスディスカバリー"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "この問題は、マイクロサービスアーキテクチャにおける障害対策に関する知識を問うものです。\n\n正解は **c: サーキットブレーカー** です。\n\n問題文にある「リクエストを送ったときのエラーが、あらかじめ設定している回数を超えた場合に、障害が解消するまでは、リクエストを送らない方式」は、まさにサーキットブレーカーパターンの説明です。これは、電気のブレーカーが過負荷を検知して回路を遮断するように、障害が発生しているサービスへのリクエストを一時的に遮断することで、呼び出し元まで障害が波及する（カスケード障害）のを防ぎ、システム全体の安定性を保つ仕組みです。これにより、障害の影響範囲を局所化できます。\n\n他の選択肢は以下の理由で誤りです。\n*   **a: CQRS (Command Query Responsibility Segregation)**: データの書き込み（Command）と読み込み（Query）の処理を別々に設計するパターンです。障害対策の方式ではありません。\n*   **b: RPC (Remote Procedure Call)**: ネットワーク越しに別のコンピューターのプログラムの関数を呼び出す技術（通信プロトコル）です。障害を局所化する仕組みとは異なります。\n*   **d: サービスディスカバリー (Service Discovery)**: 複数のサービスの中から、特定のサービスがどこにあるか（IPアドレスやポート番号など）を見つける仕組みです。これも障害対策とは直接関係ありません。"
    },
    {
      "qNo": 4,
      "text": "オブジェクト指向におけるデザインパターンに関する記述として，適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "幾つかのクラスに共通する性質を抽出して，一般化したクラスを定義したものである。"
        },
        {
          "id": "b",
          "text": "同じ性質をもつオブジェクト群を，更にクラスとして抽象化したものである。"
        },
        {
          "id": "c",
          "text": "オブジェクトの内部にデータを隠蔽し，オブジェクトの仕様と実装とを分離したものである。"
        },
        {
          "id": "d",
          "text": "システムの構造や機能について，設計上の典型的な問題とその解決策とを示し，再利用できるようにしたものである。"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "デザインパターンとは、ソフトウェア開発における設計上の「お決まりの解決策」のことです。システム開発でよく遭遇する問題に対し、過去の成功事例から導き出された効果的な解決策をパターンとして整理し、再利用できるようにしたものです。\n\nしたがって、**d**が適切です。これはデザインパターンそのものの定義であり、例えば「シングルトン」や「オブザーバ」といった具体的なパターンがあります。これらを活用することで、開発効率の向上や保守性の高いコードの実現が期待できます。\n\n他の選択肢は、オブジェクト指向の異なる概念を説明しています。\n- **a**と**b**は、共通の性質を抜き出して一般化する「抽象化」や「継承」の考え方に近いです。\n- **c**は、オブジェクトの内部構造を隠し、外部からの直接操作を防ぐ「カプセル化（情報隠蔽）」と呼ばれる重要な原則を説明しています。\n\nこれらの概念もオブジェクト指向の基本ですが、デザインパターンとは異なります。"
    },
    {
      "qNo": 5,
      "text": "モジュール間のデータの受渡し方法のうち，最も低いモジュール結合度となるものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "単一のデータ項目を大域的データで受け渡す。"
        },
        {
          "id": "b",
          "text": "単一のデータ項目を引数で受け渡す。"
        },
        {
          "id": "c",
          "text": "データ構造を大域的データで受け渡す。"
        },
        {
          "id": "d",
          "text": "データ構造を引数で受け渡す。"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "ソフトウェア開発における「モジュール結合度」とは、プログラムの部品（モジュール）同士がどれくらい密接に結びついているかを示す指標です。結合度が**低いほど**、各モジュールは独立性が高く、変更や再利用がしやすいため、良い設計とされます。\n\nこの問題では、データの渡し方による結合度の違いを問われています。\n\n**正解: b**\n\n*   **b: 単一のデータ項目を引数で受け渡す。**\n    *   「**引数**」とは、モジュールを呼び出す際に明示的に渡すデータのことです。これを使うことで、どのデータがモジュールに渡されるかが明確になり、モジュールの独立性が高まります。\n    *   「**単一のデータ項目**」とは、一つの数値や文字列など、必要最小限の情報を指します。これにより、モジュールは余計な情報に依存せず、関心事が限定されます。\n    *   この方法は最もデータの依存関係が限定的で明確なため、**データ結合**と呼ばれ、最も結合度が低いとされます。\n\n**他の選択肢が誤りである理由:**\n\n*   **a: 単一のデータ項目を大域的データで受け渡す。**\n*   **c: データ構造を大域的データで受け渡す。**\n    *   「**大域的データ（グローバル変数）**」とは、プログラム全体からアクセスできる共通のデータです。どのモジュールからも自由に読み書きできてしまうため、特定のモジュールとの関係が不透明になりやすく、影響範囲が広がるため、結合度は高くなります（**共通結合**）。\n    *   特にcのように「データ構造」（複数のデータ項目をまとめたもの）を大域的データで渡すと、影響範囲がさらに広がる可能性があります。\n\n*   **d: データ構造を引数で受け渡す。**\n    *   引数で渡す点はbと同じで良いのですが、「**データ構造**」を渡す場合、モジュールが必要とする以上のデータが含まれている可能性があります。これにより、モジュールがそのデータ構造全体の変更に影響されるリスクがあるため、bよりも結合度は少し高くなります（**スタンプ結合**）。"
    },
    {
      "qNo": 6,
      "text": "プログラムに，実行中の特定の時点で成立すべき変数間の関係や条件を記述した論理式を埋め込んで，そのプログラムの正当性を検証する手法はどれか。",
      "options": [
        {
          "id": "a",
          "text": "アサーションチェック"
        },
        {
          "id": "b",
          "text": "コード追跡"
        },
        {
          "id": "c",
          "text": "スナップショットダンプ"
        },
        {
          "id": "d",
          "text": "テストカバレッジ分析"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "プログラムに特定の条件が成立するかどうかを「表明（アサート）」する論理式を埋め込み、その条件が満たされない場合にエラーを検出する手法が、**アサーションチェック**です。これにより、プログラムの実行中の特定の時点で、開発者が意図した状態が維持されているかを確認し、予期せぬバグ（不具合）を早期に発見してプログラムの正当性を検証できます。\n\n*   **a: アサーションチェック**は、まさに問題文の説明に合致します。例えば、「この時点では変数が正の値であるべき」といった条件をプログラム中に記述します。\n*   **b: コード追跡**は、プログラムの実行の流れや変数の変化を追いかけるデバッグ手法です。\n*   **c: スナップショットダンプ**は、プログラム実行中の特定の瞬間のメモリ内容を記録し、後で分析する手法です。\n*   **d: テストカバレッジ分析**は、テストがプログラムのどの部分をどれだけ実行したかを測定し、テストの網羅率を評価する手法です。\n\nしたがって、正解は **a** です。"
    },
    {
      "qNo": 7,
      "text": "現在のプログラム A, B に，在庫テーブルを更新した後に更新ログを出力する機能を追加する。この機能は共通モジュールで実装し，どのプログラムからも利用できるようにする。図は，プログラムの実装案である。案 1 も案 2 も，在庫テーブルを更新した後に更新ログが出力される。更新ログを出力する共通モジュールを呼び出す処理を，案 1 のように各プログラム中に直接記述するのではなく，案 2 のように呼び出し方の宣言を共通プログラムなどに記述することによって，開発の効率を高めたり，保守性を高めたりするプログラミング技法はどれか。\n\n```mermaid\ngraph TD\n    subgraph Current [\"〔現在〕\"]\n        direction TB\n        A[\"プログラムA\"] --- A_C[\"...<br/>在庫テーブルを更新する<br/>...\"]\n        B[\"プログラムB\"] --- B_C[\"...<br/>在庫テーブルを更新する<br/>...\"]\n    end\n\n    subgraph Plan1 [\"〔案1〕\"]\n        direction TB\n        A1[\"プログラムA\"] --- A1_C[\"...<br/>在庫テーブルを更新する<br/>モジュールCを呼び出す<br/>...\"]\n        B1[\"プログラムB\"] --- B1_C[\"...<br/>在庫テーブルを更新する<br/>モジュールCを呼び出す<br/>...\"]\n        M1[\"モジュールC\"] --- M1_C[\"更新ログを出力する\"]\n    end\n\n    subgraph Plan2 [\"〔案2〕\"]\n        direction TB\n        X2[\"プログラムX\"] --- X2_C[\"宣言：在庫テーブルを更新した後に<br/>モジュールCを呼び出す\"]\n        A2[\"プログラムA\"] --- A2_C[\"...<br/>在庫テーブルを更新する<br/>...\"]\n        B2[\"プログラムB\"] --- B2_C[\"...<br/>在庫テーブルを更新する<br/>...\"]\n        M2[\"モジュールC\"] --- M2_C[\"更新ログを出力する\"]\n    end\n```",
      "options": [
        {
          "id": "a",
          "text": "アスペクト指向プログラミング"
        },
        {
          "id": "b",
          "text": "オブジェクト指向プログラミング"
        },
        {
          "id": "c",
          "text": "関数型プログラミング"
        },
        {
          "id": "d",
          "text": "構造化プログラミング"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "問題の状況は、複数のプログラムで共通して行われる「在庫テーブル更新後のログ出力」という処理を、**各プログラムに直接記述するのではなく**、**別の場所で「宣言」するだけで自動的に実行されるようにしたい**、というものです。\n\nこれは**アスペクト指向プログラミング**（AOP）の考え方と一致します。アスペクト指向プログラミングは、プログラムの様々な部分にまたがる「横断的関心事」（例えば、ログ出力、認証、トランザクション管理など）を、**アスペクト**という独立した部品として定義し、**既存のプログラムコードを直接変更することなく、特定の処理（今回の場合は「在庫テーブルを更新する」処理）の前後や特定のタイミングに、そのアスペクト（ログ出力モジュール）を自動的に「織り込む」技術**です。\n\n問題の「案2」では、プログラムXで「宣言：在庫テーブルを更新した後にモジュールCを呼び出す」と記述することで、プログラムA2やB2が在庫更新処理を行う際に、自動的にモジュールCが呼び出されるようになっています。これにより、各プログラムは自身の主要な処理（在庫更新）に集中でき、共通処理の変更（例えばログ出力内容の変更）が必要になった場合でも、宣言部分だけを修正すればよく、**開発効率と保守性が向上**します。\n\n他の選択肢は以下の理由で誤りです。\n-   **オブジェクト指向プログラミング**は、データと操作を一体化した「オブジェクト」として扱うことで、再利用性やカプセル化を高めますが、今回のような横断的な処理の差し込みとは直接関係しません。\n-   **関数型プログラミング**は、副作用のない純粋関数を中心にプログラムを構築する手法です。\n-   **構造化プログラミング**は、順次・分岐・反復の3つの制御構造でプログラムを構成する基本的な手法です。"
    },
    {
      "qNo": 8,
      "text": "純粋関数型言語がもつ特性の一つである参照透過性の説明はどれか。",
      "options": [
        {
          "id": "a",
          "text": "同じ引数を渡せば，関数は常に同じ結果を返す。"
        },
        {
          "id": "b",
          "text": "関数を引数とすることや返却値とすることができる。"
        },
        {
          "id": "c",
          "text": "コンパイル時に型検査を行い，型誤りがないことを保証する。"
        },
        {
          "id": "d",
          "text": "実際に評価が必要になるまで式の評価を行わない。"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "純粋関数型言語がもつ**参照透過性**とは、「**同じ引数（入力）を渡せば、関数は常に同じ結果（出力）を返す**」という性質を指します。これは、関数が外部の状態（例えば、グローバル変数や現在の時刻など）に一切影響されず、また、外部の状態にも影響を与えない「副作用がない」ことを意味します。そのため、プログラムのどこでその関数を呼び出しても、入力が同じであれば必ず同じ出力が得られるため、コードの予測可能性が高まり、テストやデバッグが容易になります。\n\n-   選択肢 **a** は、この参照透過性の定義そのものです。\n-   選択肢 **b** は、関数を引数にしたり返却値にしたりできる「第一級関数（ファーストクラスファンクション）」という特性の説明です。\n-   選択肢 **c** は、コンパイル時に型チェックを行う「静的型付け」の説明です。\n-   選択肢 **d** は、実際に値が必要になるまで式の評価を行わない「遅延評価（レイジー評価）」の説明です。\n\nこれらb、c、dも関数型言語でよく見られる特性ですが、参照透過性とは異なる概念です。"
    },
    {
      "qNo": 9,
      "text": "論理型プログラミングにおいて，命題の証明を行うための基本的な機能はどれか。",
      "options": [
        {
          "id": "a",
          "text": "オーバーライド"
        },
        {
          "id": "b",
          "text": "オーバーロード"
        },
        {
          "id": "c",
          "text": "メッセージパッシング"
        },
        {
          "id": "d",
          "text": "ユニフィケーション"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "論理型プログラミングの核となる機能は**ユニフィケーション**です。\nユニフィケーションとは、変数を含む2つの項（データや式）が同じになるように、変数に具体的な値を割り当てる（代入する）操作を指します。例えば、「Xは果物である」というルールと「リンゴは果物である」という事実があった場合、ユニフィケーションによって変数Xに「リンゴ」が代入され、命題（問い）が証明されます。これにより、与えられた事実やルールと照らし合わせながら、目標が達成できるか（命題が正しいか）を推論（証明）していくことができます。\n\n一方、\n- **a: オーバーライド**と**b: オーバーロード**は、オブジェクト指向プログラミングにおけるメソッド（関数）の定義に関する機能です。オーバーライドは親クラスのメソッドを子クラスで再定義すること、オーバーロードは同じ名前のメソッドを引数の型や数に応じて複数定義することです。\n- **c: メッセージパッシング**も、オブジェクト指向プログラミングにおいてオブジェクト同士が通信し、処理を依頼する仕組みを指します。\nこれら3つは論理型プログラミングとは異なるパラダイム（考え方）の機能であるため、誤りです。"
    },
    {
      "qNo": 10,
      "text": "JIS X 0160:2021 (ソフトウェアライフサイクルプロセス) によれば，移行プロセスで実施するタスクはどれか。",
      "options": [
        {
          "id": "a",
          "text": "システムの利用及び支援に必要な情報ニーズを識別し，利用者用文書，並びに運用操作者，利用者及びその他の利害関係者への教育訓練を用意する。"
        },
        {
          "id": "b",
          "text": "システム又はシステム要素が明示された要件 (要求事項) に合致していることについて，利害関係者の合意を得る。"
        },
        {
          "id": "c",
          "text": "ソフトウェアシステム又は要素が利害関係者ニーズに合致していることについて，利害関係者の合意を獲得する。"
        },
        {
          "id": "d",
          "text": "統合されたソフトウェアのインタフェース及び機能が，始動時点から期待されている終了時点まで，期待されるデータ値の範囲内で実行動作することのチェックを実施する。"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "JIS X 0160:2021における「移行プロセス」とは、開発が完了した新しいシステムを実際の運用環境に導入し、利用者や運用者が問題なく使い始められるようにするまでの一連の活動を指します。\n\n正解の選択肢**a**は、「システムの利用及び支援に必要な情報ニーズを識別し，利用者用文書，並びに運用操作者，利用者及びその他の利害関係者への教育訓練を用意する」と述べています。これは、新しいシステムへスムーズに切り替えるために、マニュアルなどの情報を提供し、使い方を教える（教育訓練）といった準備を行うことで、利用者や運用者がシステムを円滑に利用開始できるようにするための重要なタスクであり、移行プロセスの核心をなします。\n\n他の選択肢は以下の理由で誤りです。\n-   **b**と**c**は、システムが要件やニーズに合致していることについて利害関係者の合意を得る、という内容であり、これは一般的に**受入れプロセス**（システムが要求通りかを確認し承認する段階）で行われるタスクです。\n-   **d**は、統合されたソフトウェアの実行動作のチェックであり、これは**統合テスト**や**システムテスト**といった品質保証プロセスのタスクに該当します。\n\nしたがって、新システムを円滑に導入し、利用者が使えるようにする準備活動である**a**が、移行プロセスのタスクとして最も適切です。"
    },
    {
      "qNo": 11,
      "text": "JIS X 0160:2021 (ソフトウェアライフサイクルプロセス) によれば，廃棄プロセスに関する記述のうち，適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "使用には不十分なシステム要素は，廃棄せずにサプライチェーンで再利用できるように修正する。"
        },
        {
          "id": "b",
          "text": "ソフトウェアシステムの廃棄には，サービスの終了は含まない。"
        },
        {
          "id": "c",
          "text": "廃棄プロセスは，ソフトウェアシステムのライフサイクルのどの段階でも適用できることが意図されている。"
        },
        {
          "id": "d",
          "text": "プロトタイプの廃棄には，廃棄プロセスは適用されない。"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "JIS X 0160は、ソフトウェアの企画から廃棄までの活動（ライフサイクルプロセス）に関する国際的な指針（ISO/IEC/IEEE 12207の日本版）です。廃棄プロセスとは、不要になったシステム全体やその一部を、情報セキュリティや環境に配慮して適切に処理する一連の活動を指します。\n\n**正解のc**が正しいのは、ソフトウェアのライフサイクル（開発、テスト、運用、保守など）のどの段階でも、不要なデータ、一時ファイル、古いモジュール、プロトタイプ、テスト環境などが生じる可能性があるからです。これらも放置せず、情報漏洩のリスクをなくしたり、リソースを解放したりするために、適切な廃棄プロセスを適用する必要があります。\n\n**a**は、再利用が望ましい場合もありますが、常に修正・再利用が選択肢となるわけではなく、廃棄という選択肢もあります。\n**b**は、システムの廃棄には、それまで提供していたサービスの終了も重要な要素として含まれます。\n**d**は、プロトタイプであっても、開発途中の機密情報が含まれる可能性があるため、適切に廃棄プロセスを適用する必要があります。"
    },
    {
      "qNo": 12,
      "text": "リーンソフトウェア開発の説明として，適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "経験的プロセス制御の理論を基本としており，スプリントと呼ばれる周期で“検査と適応”を繰り返しながら開発を進める。"
        },
        {
          "id": "b",
          "text": "製造業の現場から生まれた考え方をソフトウェア開発に適用したものであり，“ムダをなくす”，“品質を作り込む”といった七つの原則を重視して，具体的な開発プロセスやプラクティスを策定する。"
        },
        {
          "id": "c",
          "text": "比較的小規模な開発に適した，プログラミングに焦点を当てた開発アプローチであり，“コミュニケーション”などの五つの価値を定義し，それらを高めるように具体的な開発プロセスやプラクティスを策定する。"
        },
        {
          "id": "d",
          "text": "利用者から見て価値があるまとまりを一つの機能単位とし，その単位ごとに，設計や構築などの五つのプロセスを繰り返しながら開発を進める。"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "リーンソフトウェア開発は、自動車製造で有名なトヨタ生産方式からヒントを得て、ソフトウェア開発に適用された考え方です。この手法の核心は、**開発プロセスにおける「ムダ」（例えば、過剰な機能、手戻り、待ち時間など）を徹底的に排除**し、顧客にとっての価値を最大化することにあります。「品質を作り込む」など、効率と価値創造を高める七つの原則を重視します。したがって、これらの特徴を記述している**選択肢bが適切**です。\n\n*   **選択肢a**は、短い期間（スプリント）で開発を繰り返し、その都度改善していく「スクラム」というアジャイル開発手法の説明です。\n*   **選択肢c**は、「コミュニケーション」「シンプルさ」などの五つの価値を重視し、プログラミングに焦点を当てる「XP（エクストリームプログラミング）」というアジャイル開発手法の説明です。\n*   **選択肢d**は、利用者にとって価値のある機能単位で開発を繰り返すという、アジャイル開発全般に共通する考え方ですが、特定の手法ではありません。"
    },
    {
      "qNo": 13,
      "text": "スタンフォード大学ハッソ・プラットナー・デザイン研究所によるデザイン思考の説明はどれか。",
      "options": [
        {
          "id": "a",
          "text": "与えられた問題に対して一つの正しい解決策を見つけるために，アイディア出しの段階で，テーマに制限を設けてアイディアが発散しないようにする手法"
        },
        {
          "id": "b",
          "text": "本質的な問題がどこにあるのかを絞り込むために，利用者との対話よりも，過去のデータや経験を分析することを重視する手法"
        },
        {
          "id": "c",
          "text": "利用者の立場から問題解決に取り組む方法論であり，現場を観察することによって利用者を理解し，共感することから始め，問題定義，アイディア出し，試作，試行を繰り返す手法"
        },
        {
          "id": "d",
          "text": "類似の問題が発生した場合に，迅速に解決策を探り当てるために，過去の問題とその解決策をナレッジデータベースとして蓄積する手法"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "デザイン思考は、利用者の視点に立ち、問題解決を目指す創造的なアプローチです。\n\n**選択肢cが正しい理由:**\nスタンフォード大学D.school（デザインスクール）が提唱するデザイン思考は、**「人間中心」**のアプローチを核としています。これは、まず利用者（ユーザー）が何に困っているのか、何を求めているのかを深く理解し、**「共感」**することから始めます。具体的には、現場での観察や対話を通じて洞察を得ます。その後、「問題定義」「アイデア出し」「試作品作成」「テスト（検証）」といったプロセスを**繰り返し**（反復）行いながら、より良い解決策を形にしていきます。この説明は、まさに選択肢cの内容と一致します。\n\n**他の選択肢が誤りである理由:**\n*   **a:** デザイン思考では、アイデア出しの段階で、むしろ制約を設けずに多様な発想を**発散**させることを重視します。\n*   **b:** 利用者との対話や観察による「共感」が最も重要であり、過去のデータ分析だけでは不十分です。\n*   **d:** これは既存の知識を再利用する「ナレッジマネジメント」に近い考え方で、創造的に新しい解決策を生み出すデザイン思考とは異なります。"
    },
    {
      "qNo": 14,
      "text": "WTO 政府調達協定に関する記述として，適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "WTO 政府調達協定加盟各国に平等になるように，政府調達協定の定める発注金額の基準額は，各国で同一金額となっている。"
        },
        {
          "id": "b",
          "text": "WTO 政府調達協定の目的は，政府調達における国際的な競争の機会を増大させるとともに，政府調達をめぐる締約国間の問題につき円滑な解決を図ることである。"
        },
        {
          "id": "c",
          "text": "WTO 政府調達協定は，各国の中央政府が発注する案件に適用され，特殊法人など政府関係機関が発注する案件には適用されない。"
        },
        {
          "id": "d",
          "text": "政府公共調達データベースでは，WTO 政府調達協定の適用を受ける案件の検索はできないので，政府調達案件を知るためには，官報を入手する必要がある。"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "**WTO（世界貿易機関）の政府調達協定**は、加盟国が物品やサービスを調達する際、特定の基準額以上の案件について、国際的な企業にも公平な競争機会を与えることを目的としています。これにより、各国企業間の競争を促し、より良い品質や価格での調達を実現します。また、貿易上の紛争を円滑に解決するためのルールも定めています。したがって、選択肢**b**の「国際的な競争の機会を増大させるとともに、政府調達をめぐる締約国間の問題につき円滑な解決を図ること」は、まさに協定の目的そのものであり、**正しい記述**です。\n\n他の選択肢は以下の理由で誤りです。\n*   **a:** 発注金額の基準額は、為替レートを考慮し、各国通貨に換算されるため、数値上は必ずしも同一金額ではありません。\n*   **c:** 協定の適用範囲は、中央政府だけでなく、その付属書で指定された地方政府や特殊法人などの政府関係機関にも及びます。\n*   **d:** 政府公共調達データベースや各省庁のウェブサイト、電子調達システムなどで、WTO政府調達協定の適用を受ける案件を検索できます。官報だけが唯一の情報源ではありません。"
    },
    {
      "qNo": 15,
      "text": "組込みシステム開発において，製品に搭載する LSI を新規に開発する。LSI 設計を自社で行い，LSI 製造を外部に委託する場合の委託先として，適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "IP プロバイダ"
        },
        {
          "id": "b",
          "text": "デザインハウス"
        },
        {
          "id": "c",
          "text": "ファウンドリー"
        },
        {
          "id": "d",
          "text": "ファブレスメーカー"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "LSI（大規模集積回路）の製造を外部に委託する場合、その委託先となるのは「ファウンドリー」です。\n\nファウンドリーとは、半導体工場（ファブ）を保有し、他社からの委託を受けて半導体の製造を専門に行う企業のことです。自社でLSIの設計は行うものの、製造設備を持たない「ファブレスメーカー」が利用する形態で、問題文の「LSI設計を自社で行い，LSI製造を外部に委託する場合」にぴったり当てはまります。\n\n一方、他の選択肢は以下の理由で不適切です。\n*   **a: IPプロバイダ** は、半導体設計に必要な部品（回路ブロックなど）を提供する企業です。製造そのものは行いません。\n*   **b: デザインハウス** は、LSIの設計を専門に行う企業です。問題文では設計は自社で行うとされているため、委託先としては誤りです。\n*   **d: ファブレスメーカー** は、自社で製造設備を持たず、設計と販売のみを行う企業のことです。LSI製造を委託する「側」の企業であり、委託「先」ではありません。"
    },
    {
      "qNo": 16,
      "text": "e シールの説明はどれか。",
      "options": [
        {
          "id": "a",
          "text": "インターネット上のゲーム内に限定されたキャラクターのイメージデータの作成者を証明する仕組みの一つである。"
        },
        {
          "id": "b",
          "text": "個人の意思表示や，意思表示をしている個人の本人確認が必要な電子文書データについて，その電子文書データの作成者の証明と改ざん防止のために，個人が行う電子署名である。"
        },
        {
          "id": "c",
          "text": "電子文書データの作成者の証明と改ざん防止のために，重要文書を扱う国や地方自治体などの公共機関だけに使用が許されている電子署名である。"
        },
        {
          "id": "d",
          "text": "法人が作成した電子文書データについて，その電子文書データの作成者が間違いなくその法人であり，かつ，その電子文書データは作成後に改ざんされていないことを証明する仕組みである。"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "eシールは、**法人が作成した電子文書の信頼性を証明するための仕組み**です。\n\n正解は**d**です。\n*   **dの解説:** eシールは、**法人が作成した電子文書**に対して適用されます。その文書が**確かにその法人によって作成された**こと（作成者の証明）と、**作成後に内容が変更されていない**こと（改ざん防止）を保証します。これにより、電子的な契約書や請求書など、法人の業務でやり取りされる文書の信頼性が高まります。\n\n他の選択肢は以下の理由で誤りです。\n*   **a:** eシールはゲームに限定されたものではなく、法人全体の業務で利用されます。\n*   **b:** 個人の意思表示や本人確認に使うのは一般的な「電子署名」であり、eシールは「法人」が主体です。ここが決定的な違いです。\n*   **c:** 国や地方自治体などの公共機関だけでなく、一般の企業など**幅広い法人が利用できる**仕組みです。特定の機関に限定されるものではありません。"
    },
    {
      "qNo": 17,
      "text": "デジタル署名のあるソフトウェアをインストールするときに，そのソフトウェアの発行元を確認するために使用する証明書はどれか。",
      "options": [
        {
          "id": "a",
          "text": "EV SSL 証明書"
        },
        {
          "id": "b",
          "text": "クライアント証明書"
        },
        {
          "id": "c",
          "text": "コードサイニング証明書"
        },
        {
          "id": "d",
          "text": "サーバ証明書"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "この問題は、ソフトウェアの「発行元確認」に関連する証明書について問われています。\n\n正解は **c: コードサイニング証明書** です。\n*   **コードサイニング証明書** は、ソフトウェア（プログラムコード）の作成者が誰であるかを証明し、そのソフトウェアが発行後に改ざんされていないことを保証するために使われます。ソフトウェアにデジタル署名を付与する際に用いられ、インストールの際に利用者が「このソフトウェアは信頼できる発行元から提供され、途中で変更されていない」と確認できるようになります。これは問題文の目的に完全に合致します。\n\n他の選択肢は目的が異なります。\n*   **a: EV SSL 証明書** は、ウェブサイトの運営組織の信頼性を厳格に証明するもので、主にWebブラウザでの信頼性向上に使われます。\n*   **b: クライアント証明書** は、利用者がサーバーにアクセスする際に、利用者自身を認証するために使われる証明書です。\n*   **d: サーバ証明書** は、ウェブサイト（サーバ）の運営元を証明し、ウェブサイトとの通信を暗号化するために使われます。"
    },
    {
      "qNo": 18,
      "text": "NIST が制定した，AES における鍵長の条件はどれか。",
      "options": [
        {
          "id": "a",
          "text": "128 ビット，192 ビット，256 ビットから選択する。"
        },
        {
          "id": "b",
          "text": "256 ビット未満で任意に指定する。"
        },
        {
          "id": "c",
          "text": "暗号化処理単位のブロック長よりも 32 ビット長くする。"
        },
        {
          "id": "d",
          "text": "暗号化処理単位のブロック長よりも 32 ビット短くする。"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "AES（Advanced Encryption Standard）は、現在の最も一般的な共通鍵暗号方式の一つで、米国の標準化機関であるNIST（National Institute of Standards and Technology）によって標準化されました。\n\nこのAESの大きな特徴の一つが、暗号化・復号に使う秘密のデータである**鍵長**が厳密に定められていることです。具体的には、**128ビット、192ビット、256ビット**の3種類の中から選択することが必須条件となっています。これにより、高いセキュリティを確保しつつ、互換性も保たれています。\n\nしたがって、正解は選択肢**a**です。\n\n*   選択肢bのように鍵長を「任意」に指定することはできません。セキュリティと標準化のため、指定された選択肢の中から選びます。\n*   選択肢cとdは、鍵長と「ブロック長」（一度に処理するデータの固まりの長さ。AESでは128ビット固定）の関係を示していますが、AESの鍵長はブロック長に依存する形では決まりません。特定のビット数の選択肢が決まっています。"
    },
    {
      "qNo": 19,
      "text": "デジタル証明書が失効しているかどうかをオンラインで確認するためのプロトコルはどれか。",
      "options": [
        {
          "id": "a",
          "text": "CHAP"
        },
        {
          "id": "b",
          "text": "LDAP"
        },
        {
          "id": "c",
          "text": "OCSP"
        },
        {
          "id": "d",
          "text": "SNMP"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "デジタル証明書の失効状態をオンラインで確認するためのプロトコルは **c: OCSP** です。\n\nOCSP（Online Certificate Status Protocol）は、デジタル証明書が現在も有効であるか、あるいは何らかの理由（例えば、秘密鍵の漏洩や証明書所有者の変更など）で失効しているかを、リアルタイムでオンライン照会するためのプロトコルです。これにより、Webサイトなどが提示する証明書が信頼できるものかを即座に確認できます。\n\n他の選択肢は以下の理由で誤りです。\n*   **a: CHAP**（Challenge-Handshake Authentication Protocol）は、主にユーザーの認証（本人確認）に使われるプロトコルです。\n*   **b: LDAP**（Lightweight Directory Access Protocol）は、ユーザー情報などを管理するディレクトリサービスにアクセスするためのプロトコルで、証明書の失効確認そのものではありません。\n*   **d: SNMP**（Simple Network Management Protocol）は、ルータやスイッチなどのネットワーク機器を監視・管理するためのプロトコルです。"
    },
    {
      "qNo": 20,
      "text": "日本の IT セキュリティ評価及び認証制度 (JISEC) に関する記述のうち，適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "IT 製品のうち，利用者ガイダンス，管理者ガイダンスを除いた部分だけが評価用提供物件である。"
        },
        {
          "id": "b",
          "text": "ハードウェア，ファームウェア，システムは制度の対象外であり，ソフトウェアだけが対象である。"
        },
        {
          "id": "c",
          "text": "ファイアウォールのように，セキュリティ機能に特化した IT 製品だけが制度の対象である。"
        },
        {
          "id": "d",
          "text": "保護すべき資産，対抗すべき脅威，適用すべき環境が具体化できる IT 製品だけが制度の対象である。"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "日本のITセキュリティ評価及び認証制度（JISEC：ジーセック）は、IT製品のセキュリティ機能が適切に実装され、期待通りに動作するかを客観的に評価し、認証する制度です。\n\n正解である**d**が適切な理由は、JISECでの評価は、その製品が「何を（保護すべき資産）」「何から（対抗すべき脅威）」「どのような環境で（適用すべき環境）」守るのかが具体的に定義されていることを前提とするからです。これらの要素が明確でなければ、製品のセキュリティ機能が何をどの程度満たしているべきか評価の基準が定まらず、適切な認証ができません。この定義は「セキュリティターゲット (ST)」と呼ばれ、評価の出発点となります。\n\n他の選択肢が誤りである理由は以下の通りです。\n*   **a**: 利用者ガイダンスや管理者ガイダンスも、セキュリティ機能の一部として適切に運用されるために不可欠であり、評価対象に含まれます。\n*   **b**: JISECの対象はソフトウェアに限定されず、ハードウェア、ファームウェア、システム全体も評価の対象となり得ます。\n*   **c**: ファイアウォールのようにセキュリティ機能に特化した製品だけでなく、OSやデータベースなど、セキュリティ機能を持つ幅広いIT製品が対象となります。"
    },
    {
      "qNo": 21,
      "text": "プロセッサの高速化を図る手法であるスーパスカラの説明として，適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "互いに依存関係のない複数の命令を動的に並列実行する。"
        },
        {
          "id": "b",
          "text": "同時に実行可能な複数の機能が埋め込まれた語長の長い命令を実行する。"
        },
        {
          "id": "c",
          "text": "パイプラインのステージを細分化する。"
        },
        {
          "id": "d",
          "text": "一つの命令で同時に複数のデータの処理を行う。"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "スーパスカラとは、プロセッサの高速化技術の一つです。これは、プロセッサの内部に命令を実行する部品（実行ユニット）を複数持ち、複数の命令を同時に処理することで性能を高める手法を指します。\n\n正解は**a**です。\nスーパスカラプロセッサは、**互いに依存関係のない**（つまり、ある命令の結果が別の命令の入力にならない）複数の命令を、**動的に**（プロセッサ自身が実行時に判断して）**並列に**（同時に）実行することで、処理速度を向上させます。例えるなら、同時に複数の作業をこなせるように、プロセッサに複数の手を持たせるようなイメージです。\n\n他の選択肢は、異なる高速化手法を説明しています。\n*   **b**はVLIW（Very Long Instruction Word）という、コンパイラが並列実行可能な命令をまとめて長い命令語にする手法に近いです。\n*   **c**はスーパーパイプラインという、命令処理の各段階（ステージ）をさらに細かく分割して処理効率を高める手法です。\n*   **d**はSIMD（Single Instruction, Multiple Data）という、一つの命令で複数のデータを同時に処理する手法です。これはベクトルプロセッサなどで利用されます。"
    },
    {
      "qNo": 22,
      "text": "ストレージ仮想化技術のシンプロビジョニングに関する記述として，適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "アプリケーションに対して，物理ストレージの容量を実際よりも大きく見せかけること"
        },
        {
          "id": "b",
          "text": "サーバの OS が利用するボリュームとして，複数のストレージにまたがる大きな容量のボリュームを作成しておくこと"
        },
        {
          "id": "c",
          "text": "複数の利用者が仮想化されたストレージを共有しているときに，利用者ごとに利用できる容量の上限を定めて割り当てておくこと"
        },
        {
          "id": "d",
          "text": "利用者には意識させることなく，利用者間で重複しているデータを削除することによって，ストレージの使用効率を高めること"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "ストレージ仮想化技術のシンプロビジョニングは、**物理的に存在するストレージ容量よりも、仮想的に多くの容量をユーザーやアプリケーションに割り当てる技術**です。正解の選択肢**a**が、まさにこの説明に該当します。\n\nシンプロビジョニングでは、例えば「100TBの容量を使えるよ」と見せかけておきながら、実際にデータが書き込まれるまでは物理ストレージを消費しません。データが書き込まれる「その都度」必要な物理容量を割り当てるため、ストレージの利用効率を高め、初期投資を抑えることができます。\n\n*   **a**：この記述がシンプロビジョニングの核心です。仮想的な容量を大きく見せかけ、実際にデータが書き込まれたときに物理容量を割り当てます。\n*   **b**：これは「RAID」や「ボリュームグループ」といった、複数のストレージを統合して一つの大きな論理ボリュームとして扱う技術の説明に近いです。\n*   **c**：これは「クォータ（割り当て制限）」という機能です。利用者が使える上限を設定することで、公平な利用を促します。\n*   **d**：これは「データ重複排除」や「データ圧縮」と呼ばれる技術です。同じデータを物理的に複数持たずに済ませることで、ストレージ使用効率を高めます。\n\nしたがって、物理容量を「実際よりも大きく見せかける」ことで、必要なときに必要なだけ物理容量を割り当てるのがシンプロビジョニングの特徴です。"
    },
    {
      "qNo": 23,
      "text": "システムに異常が起きた際の対応方法の一つであるフェールソフトとして，適切な動作はどれか。",
      "options": [
        {
          "id": "a",
          "text": "警告を出し，処理続行の判断をオペレーターに任せる。"
        },
        {
          "id": "b",
          "text": "システムのサービスを順次，安全に停止する。"
        },
        {
          "id": "c",
          "text": "性能が低下しても，処理を継続する。"
        },
        {
          "id": "d",
          "text": "データや装置を損なうことなく運転を停止する。"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "フェールソフト（Fail Soft）とは、システムの一部に障害が発生しても、**システム全体を完全に停止させることなく、機能を制限したり性能を落としたりしながら、処理を継続する**ための設計思想や動作を指します。これにより、全停止によるサービスへの影響を最小限に抑えることを目指します。\n\n選択肢c「性能が低下しても，処理を継続する」は、まさにこのフェールソフトの定義に合致しています。例えば、データベースサーバーの一部に障害が起きても、処理速度が遅くなったり一部機能が使えなくなったりしても、最低限のサービスは継続する、といったケースです。\n\n一方、選択肢aはオペレーターの判断に委ねるものであり、システムが自律的に縮退（機能を制限して継続）するフェールソフトとは異なります。選択肢bとdは、異常発生時にシステムを安全な状態へ**停止させる**ことを目的とした「フェールセーフ（Fail Safe）」の考え方に近いです。フェールセーフは被害の拡大を防ぐために安全な停止を優先しますが、フェールソフトは可能な限り運転を継続しようとします。"
    },
    {
      "qNo": 24,
      "text": "DBMS において，デッドロックを検出するために使われるデータ構造はどれか。",
      "options": [
        {
          "id": "a",
          "text": "資源割当表"
        },
        {
          "id": "b",
          "text": "時刻印順管理表"
        },
        {
          "id": "c",
          "text": "トランザクションの優先順管理表"
        },
        {
          "id": "d",
          "text": "待ちグラフ"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "デッドロックとは、複数のトランザクション（データベースに対する一連の処理単位）がお互いに相手が占有している資源（データなど）を待ち合っているため、処理が永遠に進まなくなる状態のことです。DBMS（データベース管理システム）は、この状態を検出し、適切な処置を行う必要があります。\n\n正解は**d: 待ちグラフ**です。待ちグラフは、どのトランザクションがどの資源を占有し、どの資源を待っているかを視覚的に表現したものです。このグラフの中に「閉路（サイクル）」、つまり出発点に戻る一巡する経路が存在する場合、それはデッドロックが発生していることを意味します。DBMSはこの待ちグラフを定期的に分析することでデッドロックを検出します。\n\n他の選択肢はデッドロックの検出には直接使われません。\naの資源割当表は、どの資源がどのトランザクションに割り当てられているかを示しますが、待ちの状態や閉路を直接検出する仕組みではありません。\nbの時刻印順管理表は、トランザクションの開始時刻（時刻印）に基づいて処理の競合を調整し、デッドロックの発生を「回避」する戦略の一つとして使われることがありますが、検出するためのものではありません。\ncのトランザクションの優先順管理表は、トランザクションの優先度を管理するもので、デッドロック発生後の「解決」策などで用いられることはありますが、検出には使用しません。"
    },
    {
      "qNo": 25,
      "text": "HTTP 応答のステータスコードで，指定された URL にはコンテンツがなく，別の URL へアクセスし直すように Web ブラウザに促す (リダイレクトさせる) ことを意味するコードはどれか。ここで，左側の 3 桁の数字がステータスコードで，右側の語句は HTTP 応答のステータス行にステータスコードとともに示される説明メッセージである。",
      "options": [
        {
          "id": "a",
          "text": "204 No Content"
        },
        {
          "id": "b",
          "text": "302 Found"
        },
        {
          "id": "c",
          "text": "404 Not Found"
        },
        {
          "id": "d",
          "text": "501 Not Implemented"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "この問題は、WebサーバーがWebブラウザに送る「HTTPステータスコード」の意味を問うものです。HTTPステータスコードとは、WebサーバーがWebブラウザに対し、リクエスト（要求）がどう処理されたかを伝える3桁の数字のメッセージのことです。\n\n正解は **b: 302 Found** です。\nHTTPステータスコードの**3xx系**は、すべて「リダイレクト」を意味します。リダイレクトとは、Webブラウザを「指定されたURLとは別の場所へ自動的に転送してください」と指示することです。302 Foundは、一時的に別のURLへ誘導する際に使われるコードであり、問題文の「別のURLへアクセスし直すようにWebブラウザに促す (リダイレクトさせる)」という内容に完全に合致します。\n\n他の選択肢は誤りです。\n*   **a: 204 No Content**: 2xx系はリクエストが「成功」したことを意味します。コンテンツは返しませんが、リダイレクトではありません。\n*   **c: 404 Not Found**: 4xx系は「クライアントエラー」を示し、「指定されたページが見つかりません」というエラーです。リダイレクトではありません。\n*   **d: 501 Not Implemented**: 5xx系は「サーバーエラー」を示し、「サーバーが要求された機能を処理できません」というエラーです。リダイレクトとは異なります。"
    }
  ]
}