{
  "questions": [
    {
      "qNo": 1,
      "text": "JIS X 0160 で規定しているテクニカルプロセスにおける, システム要件事項分析プロセスの成果はどれか。",
      "options": [
        {
          "id": "a",
          "text": "システムの要素を識別し, 定義された要求事項を満たすシステム方式設計が定義されている。"
        },
        {
          "id": "b",
          "text": "システム要求事項の優先度に従ってシステムを結合するための戦略が, 作成されている。"
        },
        {
          "id": "c",
          "text": "システム要求事項は, 影響のある全ての当事者へ伝えられ, ベースラインとなっている。"
        },
        {
          "id": "d",
          "text": "システム要求事項への適合を評価するための基準が作成されている。"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "正解は **c** です。\n\nJIS X 0160で定義されている「システム要件事項分析プロセス」は、システム開発の最初のステップの一つです。このプロセスでは、利用者などの関係者（当事者）から「どんなシステムが欲しいか」という要求を集め、内容を分析して、実現すべき機能や性能を仕様として明確にします。\n\nこのプロセスのゴールは、**分析・明確化された要求事項について、関係者全員で合意し、確定させること**です。この合意形成された仕様書は「**ベースライン**」と呼ばれ、今後の設計や開発を進める上での「公式な基準」となります。\n\nしたがって、選択肢cの「システム要求事項は, 影響のある全ての当事者へ伝えられ, ベースラインとなっている」状態が、このプロセスの成果として最も適切です。\n\nその他の選択肢は以下の理由で誤りです。\n*   **a**: 「システム方式設計」は、要求事項が決まった**後**に行う「システム方式設計プロセス」の成果です。\n*   **b**: 「結合するための戦略」は、システムを組み立てる「統合プロセス」などで検討される内容です。\n*   **d**: 「適合を評価するための基準」の作成は、主にテストに関連するプロセスで具体化されます。"
    },
    {
      "qNo": 2,
      "text": "共通フレームにおけるシステム方式設計プロセスで文書化する項目として, 適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "システム移行の移行要件"
        },
        {
          "id": "b",
          "text": "システム構成要件"
        },
        {
          "id": "c",
          "text": "システムの機能及び能力"
        },
        {
          "id": "d",
          "text": "システム方式及び品目に割り当てたシステム要件"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "この問題は、システム開発の工程を定めた「共通フレーム」における、「システム方式設計プロセス」の役割を理解しているかを問うています。\n\n正解は選択肢**d**です。\n\nシステム開発は、大まかに「何を作るか（要件定義）」→「どうやって作るか（設計）」の順で進みます。「システム方式設計プロセス」は、「どうやって作るか」の最初のステップです。\n\n-   **正解の理由 (d)**\n    「システム方式設計プロセス」では、前工程の「要件定義プロセス」で決まったシステム要件（機能など）を、どのように実現するかの大枠（方式）を決定します。具体的には、システム全体をハードウェア、ソフトウェア、手作業などの**「品目」**と呼ばれる構成要素に分割し、それぞれの品目にどの要件を割り当てるかを設計します。したがって、「システム方式及び品目に割り当てたシステム要件」を文書化するのがこのプロセスの中心的な活動です。\n\n-   **その他の選択肢**\n    -   **a (システム移行の移行要件)** と **c (システムの機能及び能力)** は、「何を作るか」を決める**「要件定義プロセス」**で文書化される項目です。\n    -   **b (システム構成要件)** は、システム方式設計の結果として具体化されるものですが、このプロセスの本質は「要件を品目に割り当てる」ことなので、dが最も的確な説明です。"
    },
    {
      "qNo": 3,
      "text": "DFD で用いられる図形要素を列記したものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "関連, 実体, データストア"
        },
        {
          "id": "b",
          "text": "関連, データストア, データフロー"
        },
        {
          "id": "c",
          "text": "源泉と吸収, 実体, プロセス"
        },
        {
          "id": "d",
          "text": "源泉と吸収, データフロー, プロセス"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "DFD（Data Flow Diagram）は、業務やシステムにおける「データの流れ」を視覚的に表現するための図です。DFDは、主に4つの基本的な図形要素で構成されます。\n\n*   **プロセス（Process）**: データを処理・変換する機能を表します（例：受注処理）。円や角の丸い四角形で描かれます。\n*   **データフロー（Data Flow）**: データの流れそのものを表します。矢印で描かれます。\n*   **データストア（Data Store）**: 処理のためにデータを保管しておく場所を表します（例：顧客マスタ）。平行な二重線で描かれます。\n*   **源泉と吸収（Source/Sink）**: データの発生源（源泉）や最終的な行き先（吸収）となる、システムの外部の存在を表します（例：顧客）。四角形で描かれます。\n\n選択肢dの「源泉と吸収」「データフロー」「プロセス」は、これらDFDの主要な構成要素です。\n\n一方、選択肢a、b、cに含まれる「実体（Entity）」や「関連（Relationship）」は、主にデータベース設計で用いられる**E-R図**の構成要素です。DFDとE-R図は、モデル化の対象が異なる（DFDはデータの「流れ」、E-R図はデータの「構造」）ため、使われる要素も異なります。\n\n以上の理由から、DFDの図形要素を正しく列記しているのは選択肢dとなります。"
    },
    {
      "qNo": 4,
      "text": "並列に動作する事象間の同期を表現することが可能な, ソフトウェアの要求モデルはどれか。",
      "options": [
        {
          "id": "a",
          "text": "E-R モデル"
        },
        {
          "id": "b",
          "text": "データフローモデル"
        },
        {
          "id": "c",
          "text": "ペトリネットモデル"
        },
        {
          "id": "d",
          "text": "有限状態機械モデル"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "正解は **c: ペトリネットモデル** です。\n\nペトリネットモデルは、システムの状態と状態変化をモデル化するための手法です。このモデルは、システムの「状態」と、状態を変化させる「処理（イベント）」の流れを視覚的に表現します。\n\n*   **なぜ正しいか**\n    ペトリネットモデルは、複数の処理が同時に実行される**並列動作**や、ある処理の完了を待って次の処理を開始する**同期**を表現することを得意としています。例えば、複数の場所にトークン（現在の状態を示す印）を置くことで並列状態を、ある処理の実行条件が複数の入力元のトークンが揃うことである、と定義することで同期をモデル化できます。\n\n*   **他の選択肢がなぜ誤りか**\n    *   **a: E-R モデル**は、データベース設計で使われ、データの構造（モノとモノの関係）を表現するものです。\n    *   **b: データフローモデル**は、データの流れに着目したモデルで、処理の順序やタイミングは考慮しません。\n    *   **d: 有限状態機械モデル**は、システムの状態遷移を表現しますが、基本的に一度に一つの状態しか取れないため、並列動作を直接表現するのは困難です。"
    },
    {
      "qNo": 5,
      "text": "論理データモデル作成におけるトップダウンアプローチ, ボトムアップアプローチに関する記述のうち, 適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "トップダウンアプローチでは, 新規システムの利用者要求だけに基づいて論理データモデルを作成するので, 現状業務の分析は行えない。"
        },
        {
          "id": "b",
          "text": "トップダウンアプローチでもボトムアップアプローチでも, 最終的な論理データモデルは正規化され, かつ, 業務上の属性は全て備えていなければならない。"
        },
        {
          "id": "c",
          "text": "トップダウンアプローチでもボトムアップアプローチでも, 利用者が使用する現状の画面や帳票を素材として分析を行うのは同じである。"
        },
        {
          "id": "d",
          "text": "ボトムアップアプローチは現状業務の分析に限定して用いるものであり, 新規システムの設計ではトップダウンアプローチを使用しなければならない。"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "データベースの設計（論理データモデル作成）には、大きく2つのアプローチがあります。\n\n*   **トップダウンアプローチ**: 経営や業務全体の視点から、まず大枠となるデータのまとまり（エンティティ）を決め、徐々に詳細な項目（属性）を定義していく、\"森から木を見る\"ような方法です。\n*   **ボトムアップアプローチ**: 帳票や画面など、現場で実際に使われているデータ項目を洗い出し、それらをグループ化してエンティティを定義していく、\"木から森を見る\"ような方法です。\n\n**b. (正解)**\nどちらのアプローチを採用しても、最終的に目指すゴールは同じです。それは、品質の高い論理データモデルを作成することです。そのためには、データの重複をなくし整合性を保つための「**正規化**」を行い、業務に必要なデータ項目（**属性**）を漏れなく含んでいる必要があります。したがって、この記述は正しいです。\n\n**a. (誤り)**\nトップダウンアプローチは新規システムの要求が中心ですが、より良いシステムを設計するために、現状業務の分析を参考にすることはあります。\n\n**c. (誤り)**\n「現状の画面や帳票を素材として分析する」のは、具体的なデータ項目から始める**ボトムアップアプローチ**の典型的な手法です。\n\n**d. (誤り)**\nアプローチは目的によって使い分けます。新規システムの設計でも、既存の帳票などを参考にボトムアップアプローチを用いることや、両方を併用することもあります。"
    },
    {
      "qNo": 6,
      "text": "図は, デマルコの提唱による構造化技法を基本としたシステム開発プロジェクトのライフサイクルを表現したものである。図中の a に入れる適切なプロセスはどれか。\n\n```mermaid\ngraph TD\n    UserReq((ユーザの要求)) --> P1((1 調査))\n    P1 --> Feasibility[フィージビリティ資料]\n    P1 --> P2((2 構造化分析))\n    Feasibility --> P2\n    P2 --> Budget[予算, スケジュール]\n    P2 --> PhysReq[物理的要求]\n    P2 --> StructSpec[構造化仕様書]\n    P2 --> P3((3 a))\n    StructSpec --> P3\n    PhysReq --> P4((4 ハードウェアの調査))\n    P4 --> Hardware[ハードウェア]\n    P4 --> SysConfig[システム構成データ]\n    SysConfig --> P5((5 システム開発))\n    P3 --> TestPlan[テスト計画]\n    P3 --> PackDesign[パッケージ化した設計]\n    TestPlan --> P5\n    PackDesign --> P5\n    P5 --> System((システム))\n```",
      "options": [
        {
          "id": "a",
          "text": "機能設計"
        },
        {
          "id": "b",
          "text": "構造化設計"
        },
        {
          "id": "c",
          "text": "プログラム設計"
        },
        {
          "id": "d",
          "text": "プロトタイピング"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "この問題は、システム開発の工程に関する知識を問うています。特に、デマルコが提唱した**構造化技法**のライフサイクルを理解することがポイントです。\n\n-   **正解の選択肢「b: 構造化設計」が正しい理由**\n    構造化技法では、まず「**構造化分析**」でシステムが「何を（What）」すべきかを定義し、その結果を「構造化仕様書」としてまとめます。次に、その仕様書をもとに、「**構造化設計**」でシステムを「どのように（How）」実現するかを具体的に設計します。\n    問題の図を見ると、`a` のプロセスは `構造化仕様書` をインプットとして、プログラムのモジュール構成を示す `パッケージ化した設計` をアウトプットしています。これは、まさに構造化設計の役割そのものです。\n\n-   **その他の選択肢が誤りである理由**\n    -   **a: 機能設計**: システムの機能を決める工程で、図中の「2 構造化分析」の段階で行われる内容と重複します。\n    -   **c: プログラム設計**: 個々のプログラムの内部処理を設計する、より詳細な工程です。「構造化設計」の後、または「5 システム開発」の内部で行われます。\n    -   **d: プロトタイピング**: 試作品を作って確認する開発手法の一つであり、この図のような一連の流れの中の特定のプロセス名としては適切ではありません。\n\nしたがって、構造化分析の次に来るプロセスとして、`b: 構造化設計` が正解となります。"
    },
    {
      "qNo": 7,
      "text": "プログラムの構造化設計におけるモジュール分割技法の説明のうち, 適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "STS 分割は, データの流れに着目してプログラムを分割する技法であり, 入力データの処理, 入力から出力への変換処理及び出力データの処理の三つの部分で構成することによって, モジュールの独立性が高まる。"
        },
        {
          "id": "b",
          "text": "TR 分割は, データの構造に着目してプログラムを分割する技法であり, オンラインリアルタイム処理のように, 入力トランザクションの種類に応じて処理が異なる場合に有効である。"
        },
        {
          "id": "c",
          "text": "共通機能分割は, データの構造に着目してプログラムを分割する技法であり, 共通の処理を一つにまとめ, モジュール化する。"
        },
        {
          "id": "d",
          "text": "ジャクソン法は, データの流れに着目してプログラムを分割する技法であり, バッチ処理プログラムの分割に適している。"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "プログラムを機能ごとの部品（モジュール）に分ける、モジュール分割技法についての問題です。それぞれの技法が何に着目して分割するかがポイントになります。\n\n正解の選択肢**a**は、**STS分割**を正しく説明しています。\nSTS分割は「データの流れ」に着目し、プログラムの機能を以下の3つに分割する手法です。\n*   **S (Source):** 外部からデータを入力する部分\n*   **T (Transform):** 入力されたデータを処理・変換する中心部分\n*   **S (Sink):** 処理結果を出力する部分\nデータの流れに沿って処理を分割するため、各モジュールの役割が明確になり、独立性が高まります。その結果、修正や変更がしやすいプログラムになります。\n\nその他の選択肢は、着目点が誤っています。\n*   **b**: TR分割は、入力される処理の種類（トランザクション）に応じて処理を振り分ける手法で、「データの**流れ**」に着目します。\n*   **c**: 共通機能分割は、複数の箇所で利用される共通の「**機能**」をまとめる手法です。\n*   **d**: ジャクソン法は、入出力される「データの**構造**」に着目して、プログラムの構造を決める手法です。"
    },
    {
      "qNo": 8,
      "text": "JIS X 25010:2013 におけるシステムの利用時の品質特性の一つである, 効率性の説明はどれか。",
      "options": [
        {
          "id": "a",
          "text": "製品又はシステムが, 経済状況, 人間の生活又は環境に対する潜在的なリスクを緩和する度合い"
        },
        {
          "id": "b",
          "text": "製品又はシステムが明示された利用状況において使用されるとき, 利用者ニーズが満足される度合い"
        },
        {
          "id": "c",
          "text": "明示された目標を利用者が達成する上での正確さ及び完全さの度合い"
        },
        {
          "id": "d",
          "text": "利用者が特定の目標を達成するための正確さ及び完全さに関連して, 使用した資源の度合い"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "この問題は、ソフトウェアの品質を評価する規格「JIS X 25010:2013」における「利用時の品質」の定義に関する問題です。\n\n**正解は選択肢dです。**\n「効率性」とは、簡単に言うと「かけた労力や時間（資源）に対して、どれだけ目的を達成できたか」という度合いのことです。選択肢dの「**使用した資源の度合い**」という部分が、まさしくこの効率性の定義に合致しています。少ない時間や労力で目的を達成できるシステムは、効率性が高いと言えます。\n\n他の選択肢も確認しましょう。\n*   **a**は「**リスク回避性**」の説明です。システム利用による経済的・環境的な危険性をどれだけ減らせるかを示します。\n*   **b**は「**満足度**」の説明です。利用者がシステムを使ってどれだけ満足したか、という主観的な評価基準です。\n*   **c**は「**有効性**」の説明です。そもそも目的をどれだけ正確に達成できたか、という成果そのものを示します。\n\n「有効性」と「効率性」の違いは重要です。「有効性」が目的を達成できたか**どうか**であるのに対し、「効率性」は目的を達成するために**どれだけの資源を使ったか**というコストの観点が加わります。"
    },
    {
      "qNo": 9,
      "text": "組込みシステムの開発におけるソースコードの品質向上のために, C 言語のコーディング規則をまとめたものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "CSS"
        },
        {
          "id": "b",
          "text": "GCC"
        },
        {
          "id": "c",
          "text": "MISRA-C"
        },
        {
          "id": "d",
          "text": "SystemC"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "正解は **c** の「MISRA-C」です。\n\n**MISRA-C（マイズラシー）**は、自動車産業ソフトウェア信頼性協会（MISRA）が策定した、C言語でプログラミングする際の**コーディング規則集**です。\n特に、安全性や信頼性が非常に重要視される**組込みシステム**（自動車、医療機器、航空機など）の開発において、バグの発生を未然に防ぎ、ソースコードの品質を向上させることを目的として広く採用されています。\n\n他の選択肢は以下の理由で誤りです。\n\n*   **a: CSS** (Cascading Style Sheets) は、Webページの見た目（スタイル）を指定するための言語です。\n*   **b: GCC** (GNU Compiler Collection) は、C言語などのソースコードをコンピュータが実行できる形式に変換（コンパイル）するためのソフトウェア（コンパイラ）です。\n*   **d: SystemC**は、ハードウェアの設計や検証を行うための、C++をベースとした言語（クラスライブラリ）です。"
    },
    {
      "qNo": 10,
      "text": "ブラックボックステストのテストデータの作成方法のうち, 最も適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "稼働中のシステムから実データを無作為に抽出し, テストデータを作成する。"
        },
        {
          "id": "b",
          "text": "機能仕様から同値クラスや限界値を識別し, テストデータを作成する。"
        },
        {
          "id": "c",
          "text": "業務で発生するデータの発生頻度を分析し, テストデータを作成する。"
        },
        {
          "id": "d",
          "text": "プログラムの流れ図から, 分岐条件に基づいたテストデータを作成する。"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "ブラックボックステストは、プログラムの内部構造（ソースコード）を考慮せず、**仕様書通りにシステムが機能するか**を検証するテストです。まるで中身が見えない黒い箱（ブラックボックス）を外から操作して確認するイメージです。\n\n-   **b（正解）**: このテストでは、「何を入力したら、何が出力されるべきか」という**機能仕様**が全ての基準となります。「同値クラス分析」や「限界値分析（境界値分析）」は、その仕様から効果的なテストデータを見つけ出す代表的な手法です。そのため、これが最も適切な方法です。\n    -   **同値クラス**: 同じような結果になる入力値のグループ。\n    -   **限界値**: 仕様の境界となる値（例: 「100まで入力可」なら100や101）。バグが出やすい箇所です。\n\n-   **a, c**: 実データや発生頻度を使う方法も存在しますが、仕様を網羅的に検証する観点では、同値クラス分析などに劣ります。\n-   **d**: プログラムの流れ図や分岐条件は、プログラムの**内部構造**に関する情報です。内部構造に基づいてテストするのは**ホワイトボックステスト**と呼ばれる手法です。"
    },
    {
      "qNo": 11,
      "text": "エラー埋込み法では, 検出したエラー数を測定することによって, その時点での埋込みエラー数を除いた潜在エラー数 T を推定することができる。T を求める次の計算式の変数 A, B, C に対応する項目の適切な組合せはどれか。\n\n総エラー数 = A × B / C\nT = 総エラー数 - A - (B - C)\n\n| | A | B | C |\n| :--- | :--- | :--- | :--- |\n| ア | 埋込みエラー数 | 検出した埋込みエラー数 | 検出した総エラー数 |\n| イ | 埋込みエラー数 | 検出した総エラー数 | 検出した埋込みエラー数 |\n| ウ | 検出した埋込みエラー数 | 埋込みエラー数 | 検出した総エラー数 |\n| エ | 検出した埋込みエラー数 | 検出した総エラー数 | 埋込みエラー数 |",
      "options": [
        {
          "id": "a",
          "text": "ア"
        },
        {
          "id": "b",
          "text": "イ"
        },
        {
          "id": "c",
          "text": "ウ"
        },
        {
          "id": "d",
          "text": "エ"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "エラー埋込み法は、ソフトウェアに意図的にエラー（**埋込みエラー**）を仕込み、テストでどれだけ発見できるかを調べる手法です。この「埋込みエラーの発見率」を手がかりに、元々隠れているエラー（**潜在エラー**）の総数を推定します。\n\nこの手法は、以下の考え方に基づいています。\n**「テストによるエラー発見率は、埋込みエラーでも潜在エラーでも同じはずだ」**\n\nこれを比率の式で表すと、次のようになります。\n`(検出した埋込みエラー数) / (全ての埋込みエラー数) = (検出した総エラー数) / (ソフトウェア全体の総エラー数)`\n\nこの式を「ソフトウェア全体の総エラー数」について解くと、\n`総エラー数 = (全ての埋込みエラー数) × (検出した総エラー数) / (検出した埋込みエラー数)`\nとなります。\n\n問題の式 `総エラー数 = A × B / C` と見比べると、\n*   **A: 埋込みエラー数**\n*   **B: 検出した総エラー数**\n*   **C: 検出した埋込みエラー数**\nとなり、選択肢**イ**が正解です。\n\n他の選択肢（ア、ウ、エ）では、この比率の式が成り立たず、正しい総エラー数を計算できないため誤りとなります。"
    },
    {
      "qNo": 12,
      "text": "全国に分散しているシステムの保守に関する記述のうち, 適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "故障発生時に遠隔保守を実施することによって駆け付け時間が不要になり, MTBF は長くなる。"
        },
        {
          "id": "b",
          "text": "故障発生時に行う是正保守によって, MTBF は長くなる。"
        },
        {
          "id": "c",
          "text": "保守センタを 1 か所集中から分散配置に変えて駆け付け時間を短縮することによって, MTTR は短くなる。"
        },
        {
          "id": "d",
          "text": "予防保守を実施することによって, MTTR は短くなる。"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "この問題を解く鍵は、システムの信頼性や保守性を示す2つの重要な指標、**MTTR**と**MTBF**の違いを正しく理解することです。\n\n*   **MTTR (Mean Time To Repair): 平均修復時間**\n    *   システムが故障してから、修理が完了するまでの平均時間です。\n    *   この時間が短いほど「すぐに直せる」、つまり**保守性が高い**ことを意味します。\n\n*   **MTBF (Mean Time Between Failures): 平均故障間隔**\n    *   システムが故障してから、次に故障するまでの平均時間です。\n    *   この時間が長いほど「壊れにくい」、つまり**信頼性が高い**ことを意味します。\n\n---\n\n**【正解の解説】**\n\n*   **c: 保守センタを 1 か所集中から分散配置に変えて駆け付け時間を短縮することによって, MTTR は短くなる。**\n    *   これが**正解**です。保守拠点を全国に分散させると、故障が発生した現場への移動時間（駆け付け時間）が短くなります。駆け付け時間は修理作業全体に含まれるため、結果として平均修復時間（MTTR）が短縮されます。\n\n**【不正解の解説】**\n\n*   **a:** 遠隔保守によって駆け付け時間が不要になると、修理が早く完了するため**MTTRが短く**なります。故障の発生間隔であるMTBFが長くなるわけではありません。\n*   **b:** 是正保守は「故障が起きてから行う修理」のことです。MTBF（故障間隔）を長くする効果はありません。MTBFを長くするのは、故障を未然に防ぐ「予防保守」です。\n*   **d:** 予防保守は、故障しにくくするための活動なので、**MTBFが長く**なります。故障発生後の修理時間であるMTTRを短くするものではありません。"
    },
    {
      "qNo": 13,
      "text": "ユースケース駆動開発の利点はどれか。",
      "options": [
        {
          "id": "a",
          "text": "開発を反復するので, 新しい要求やビジネス目標の変化に柔軟に対応しやすい。"
        },
        {
          "id": "b",
          "text": "開発を反復するので, リスクが高い部分に対して初期段階で対処しやすく, プロジェクト全体のリスクを減らすことができる。"
        },
        {
          "id": "c",
          "text": "基本となるアーキテクチャをプロジェクトの初期に決定するので, コンポーネントを再利用しやすくなる。"
        },
        {
          "id": "d",
          "text": "ひとまとまりの要件を 1 単位として設計からテストまでを実施するので, 要件ごとに開発状況が把握できる。"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "正解は **d** です。\n\n**ユースケース駆動開発**とは、システムの利用者（アクター）がシステムを使って何をするか（＝**ユースケース**）を基準に開発を進める手法です。「商品を検索する」「カートに商品を入れる」といった、利用者から見た機能のまとまりを一つ一つ開発していきます。\n\n-   **d（正解）**: この開発手法では、「商品を検索する」といったユースケースを一つの単位として、設計からテストまでの一連の工程を進めます。そのため、**どの機能（要件）がどこまで完成しているのか、進捗状況を具体的に把握しやすい**という大きな利点があります。\n\n-   **a, b（誤り）**: 「開発を反復する」のは、アジャイル開発やスパイラルモデルなどでも行われる特徴です。ユースケース駆動開発でも反復は行いますが、これ自体がユースケース駆動開発「固有」の利点というわけではありません。\n\n-   **c（誤り）**: 「アーキテクチャを初期に決定する」のは、アーキテクチャ中心開発の考え方です。ユースケース駆動開発でもアーキテクチャは考慮されますが、最も中心的な利点ではありません。"
    },
    {
      "qNo": 14,
      "text": "プライバシーバイデザイン (Privacy by Design) の説明はどれか。",
      "options": [
        {
          "id": "a",
          "text": "製品の開発工程で, 利用者の個人情報が漏えいした場合に発見する方策を用意しておくこと"
        },
        {
          "id": "b",
          "text": "製品の設計工程で, 利用者の個人情報が適切に扱われるように考慮したシステムを設計すること"
        },
        {
          "id": "c",
          "text": "製品の設計工程で, 利用者の個人情報が漏えいしないように管理する規則を策定すること"
        },
        {
          "id": "d",
          "text": "製品の利用者の利便性を高めるために, 登録した個人情報が他のサービスでも利用できるようにすること"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "プライバシーバイデザイン（Privacy by Design）は、その名の通り「設計段階からのプライバシー保護」を意味する考え方です。システムやサービスの企画・設計といった開発の初期段階から、利用者のプライバシーを守るための仕組みを組み込んでおくことを指します。問題が発生してから対策するのではなく、初めからプライバシー侵害が起きないように設計することが重要です。\n\n-   **b（正解）**: 「**製品の設計工程で**、利用者の個人情報が適切に扱われるように考慮したシステムを設計すること」は、プライバシーバイデザインの核心的な考え方を正しく説明しています。\n\n-   **a（誤り）**: 漏えいした後の「発見」は事後対応であり、設計段階から予防する考え方とは異なります。\n-   **c（誤り）**: 「規則の策定」は組織的な対策であり、システム自体の設計にプライバシー保護を組み込むという技術的なアプローチとは異なります。\n-   **d（誤り）**: 他のサービスとの情報連携は、プライバシーリスクを高める可能性があり、プライバシー保護を目的とするこの考え方とは方向性が逆です。"
    },
    {
      "qNo": 15,
      "text": "グリーン購入法において, “環境物品等”として規定されているものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "ISO 14001 認証を取得した企業が製造又は提供する製品・サービス"
        },
        {
          "id": "b",
          "text": "IT 活用による省エネなど, グリーン IT に関わる製品・サービス"
        },
        {
          "id": "c",
          "text": "環境への負荷低減に資する原材料・部品又は製品・サービス"
        },
        {
          "id": "d",
          "text": "コーズリレーテッドマーケティング対象の, 環境配慮の製品・サービス"
        }
      ],
      "correctOption": "c",
      "point": 4,
      "explanation": "正解は選択肢 **c** です。\n\n**グリーン購入法**とは、国や地方公共団体などが物品やサービスを購入する際に、環境への負荷が少ないものを優先的に選ぶことを定めた法律です。この法律で優先的に購入する対象となるのが「**環境物品等**」です。\n\n*   **c. (正解)** 「環境への負荷低減に資する原材料・部品又は製品・サービス」は、グリーン購入法で定められている「環境物品等」の定義そのものです。例えば、再生材を利用した製品や、省エネ性能の高い家電などが該当します。\n\nその他の選択肢は以下の理由で誤りです。\n\n*   **a:** ISO 14001は、企業の「環境管理の仕組み」に関する国際規格です。認証を受けた企業の製品が、必ずしも個別に環境性能基準を満たすとは限りません。\n*   **b:** グリーンITに関する製品・サービスは「環境物品等」の一部ですが、法律の対象はIT分野に限定されず、文房具や自動車など多岐にわたります。\n*   **d:** コーズリレーテッドマーケティングは、売上の一部を寄付するなど販売促進と社会貢献を結びつけた手法です。製品自体の環境性能を直接示すものではありません。"
    },
    {
      "qNo": 16,
      "text": "“情報システム・モデル取引・契約書”によれば, ユーザ (取得者) とベンダ (供給者) 間で請負型の契約が適切であるとされるフェーズはどれか。\n\n```mermaid\ngraph LR\n    P1[システム化計画] --- P2[要件定義] --- P3[システム外部設計] --- P4[システム内部設計] --- P5[ソフトウェア設計, プログラミング, ソフトウェアテスト] --- P6[システム結合] --- P7[システムテスト] --- P8[導入・受入支援]\n```\n※図中の範囲のア〜エは以下の通り：\nア: システム化計画フェーズから導入・受入支援フェーズまで\nイ: 要件定義フェーズから導入・受入支援フェーズまで\nウ: 要件定義フェーズからシステム結合フェーズまで\nエ: システム内部設計フェーズからシステム結合フェーズまで",
      "options": [
        {
          "id": "a",
          "text": "ア"
        },
        {
          "id": "b",
          "text": "イ"
        },
        {
          "id": "c",
          "text": "ウ"
        },
        {
          "id": "d",
          "text": "エ"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "システム開発の契約には、主に**請負契約**と**準委任契約**があり、それぞれの特徴から適した開発フェーズが異なります。\n\n*   **請負契約**: **成果物（完成したシステムなど）を納品すること**を目的とする契約です。作るべきものが明確に決まっている（仕様が確定している）フェーズに適しています。\n*   **準委任契約**: **専門家として業務を適切に行うこと**を目的とする契約です。仕様を固めていく上流工程など、成果物を事前に確定しにくいフェーズに適しています。\n\nこの問題では、「システム化計画」「要件定義」「システム外部設計」といった上流工程は、ユーザとベンダが協力して仕様を固めていくため、準委任契約が適しています。\n\n一方、**正解であるエの「システム内部設計」から「システム結合」までのフェーズ**は、外部設計で仕様が確定した後に、その仕様に基づいてシステムを製造する工程です。成果物が明確であるため、**請負契約**を結ぶのに最も適切な範囲となります。\n\n他の選択肢（ア、イ、ウ）は、仕様が未確定な上流工程を含んでいるため、請負契約には適していません。"
    },
    {
      "qNo": 17,
      "text": "エンタープライズアーキテクチャ (EA) における, ビジネスアーキテクチャの成果物である機能情報関連図 (DFD) を説明したものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "業務・システムの処理過程において, 情報システム間でやり取りされる情報の種類及び方向を図式化したものである。"
        },
        {
          "id": "b",
          "text": "業務を構成する各種機能を, 階層化した 3 行 3 列の格子様式に分類して整理し, 業務・システムの対象範囲を明確化したものである。"
        },
        {
          "id": "c",
          "text": "最適化計画に基づき決定された業務対象領域の全情報 (伝票, 帳票, 文書など) を整理し, 各情報間の関連及び構造を明確化したものである。"
        },
        {
          "id": "d",
          "text": "対象の業務機能に対して, 情報の発生源と到達点, 処理, 保管, それらの間を流れる情報を, 統一記述規則に基づいて表現したものである。"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "この問題は、エンタープライズアーキテクチャ（EA）で利用される図の一つである**DFD（Data Flow Diagram: 機能情報関連図）**について問うています。DFDは、業務やシステムにおける「データの流れ」を視覚的に表現するための図です。\n\n-   **正解の選択肢 (d)**\n    DFDは、以下の4つの記号を使ってデータの流れを描きます。\n    1.  **情報の発生源と到達点**（外部実体）：データの出入り口となる人や組織、システム\n    2.  **処理**（プロセス）：データに何らかの処理を行う機能\n    3.  **保管**（データストア）：データを保存しておく場所（ファイルやデータベースなど）\n    4.  **それらの間を流れる情報**（データフロー）：データの流れそのもの\n    選択肢dは、これらDFDの構成要素をすべて含んでおり、DFDを最も的確に説明しています。\n\n-   **その他の選択肢**\n    *   **a**: システム「間」の連携に焦点を当てており、**情報システム関連図**の説明に近いです。\n    *   **b**: 「3行3列の格子様式」というキーワードは、業務機能と情報分類の関係を整理する**ファンクション/クラス・マトリックス**の特徴です。\n    *   **c**: 情報の「関連」や「構造」を明確化するのは、データの静的な関係性を表現する**E-R図**などのデータモデルの説明です。DFDはデータの動的な「流れ」を表現します。"
    },
    {
      "qNo": 18,
      "text": "RAID 1 〜 5 の方式の違いは, 何に基づいているか。",
      "options": [
        {
          "id": "a",
          "text": "構成する磁気ディスク装置のアクセス性能"
        },
        {
          "id": "b",
          "text": "コンピュータ本体とのインタフェース"
        },
        {
          "id": "c",
          "text": "磁気ディスク装置の信頼性を示す MTBF の値"
        },
        {
          "id": "d",
          "text": "データ及び冗長ビットの記録方法と記録位置との組合せ"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "RAIDは、複数のハードディスクなどを組み合わせて、1つのドライブのように使う技術です。信頼性や処理速度を向上させるために、様々な「レベル（方式）」があります。\n\nこのRAIDのレベルの違いは、**d: データ及び冗長ビットの記録方法と記録位置との組合せ**に基づいています。\n\n- **正解(d)の理由:**\n    RAIDの各レベルは、「データをどのように分割して書き込むか（記録方法）」と、「故障に備えるための冗長なデータ（冗長ビットやデータのコピー）をどこに配置するか（記録位置）」の設計思想によって区別されます。\n    *   **RAID 1 (ミラーリング):** データを丸ごと別のディスクにコピーして記録します。\n    *   **RAID 5 (パリティ付きストライピング):** データを分割し、さらに誤り訂正用の「パリティ」と呼ばれる冗長データを各ディスクに分散して記録します。\n    このように、データの記録方法と冗長化の方法の組み合わせが、RAIDの方式そのものを定義しているため、dが正解です。\n\n- **その他の選択肢:**\n    *   **a, b:** ディスクのアクセス性能やコンピュータとのインタフェースは、RAIDシステム全体の性能に影響しますが、RAIDの方式を決めるものではありません。\n    *   **c:** MTBF（平均故障間隔）はディスク単体の信頼性を示す指標であり、RAID方式の定義とは関係ありません。RAIDは、このようなディスクを組み合わせてシステム全体の信頼性を高める技術です。"
    },
    {
      "qNo": 19,
      "text": "分散処理システムにおける障害透明性 (透過性) の説明として, 適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "管理者が, システム全体の状況を常に把握でき, システムを構成する個々のコンピュータで起きた障害をリアルタイムに知ることができること"
        },
        {
          "id": "b",
          "text": "個々のコンピュータでの障害がシステム全体に影響を及ぼすことを防ぐために, データを 1 か所に集中して管理すること"
        },
        {
          "id": "c",
          "text": "どのコンピュータで障害が起きてもすぐ対処できるように, 均一なシステムとなっていること"
        },
        {
          "id": "d",
          "text": "利用者が, 個々のコンピュータに障害が起きていることを認識することなく, システムを利用できること"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "分散処理システムにおける**透明性（透過性）**とは、システムが複数のコンピュータで構成されているという複雑さを、利用者から見えなくする（隠蔽する）性質のことです。「透明」とは、ガラスの向こう側が見えるように、その存在を意識しなくてよい、という意味で使われます。\n\nこれを踏まえて、「**障害透明性**」は、システムを構成する一部のコンピュータに障害が発生しても、利用者はその障害の存在を意識することなく、システムを使い続けられることを指します。\n\n-   **d（正解）**: この選択肢は、「利用者が、個々のコンピュータの障害を認識することなくシステムを利用できる」と説明しており、障害透明性の定義に完全に一致します。例えば、Webサーバーの1台が故障しても、他のサーバーが自動で処理を引き継ぐことで、利用者はサービスを継続して利用できるのがこの例です。\n\n-   **a**: 管理者が障害を把握できることは、システムの監視や可用性の話であり、利用者から見た透明性の説明ではありません。\n-   **b**: データを1か所に集中させると、そこが故障した場合にシステム全体が停止する「単一障害点」となり、むしろ障害に弱くなります。\n-   **c**: システムが均一であることは、障害発生時の代替処理などを実現しやすくしますが、均一であること自体が障害透明性を意味するわけではありません。"
    },
    {
      "qNo": 20,
      "text": "グラフは, ある非修理系の製品の, 時刻 0 から時刻 t までの間の累積故障率 (全製品数を分母として, 時刻 0 から時刻 t までに故障した製品数を分子とした割合) を表したものである。時刻 0 付近のグラフ形状からこの製品の故障率について読み取れるものはどれか。\n\n(グラフは原点から始まり, 最初は曲線が下に凸で時間とともに勾配が増加し, その後変曲点を経て勾配が減少し1に近づくS字状の形状をしている。)",
      "options": [
        {
          "id": "a",
          "text": "故障率は, 0 に近い値からしばらくの間は時間とともに増加する。"
        },
        {
          "id": "b",
          "text": "故障率は, ある時刻まで一定で, その後時間とともに減少する。"
        },
        {
          "id": "c",
          "text": "故障率は, ある正の値から時間とともに減少し, 限りなく 0 に近づく。"
        },
        {
          "id": "d",
          "text": "故障率は, 時刻によって変化することなく, ある正の定数のまま一定である。"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "この問題のポイントは、**「累積故障率」グラフの傾きが、その時点での「故障率（故障の発生しやすさ）」の傾向を表す**ことを理解することです。\n\n-   **グラフの形状の読み取り**\n    問題のグラフは、時刻0付近で「下に凸」のカーブを描いています。これは、グラフの**傾きが時間とともにだんだん急になっている（増加している）**ことを意味します。\n\n-   **正解の選択肢 (a)**\n    グラフの傾きが増加しているため、故障率も「0に近い値からしばらくの間は時間とともに増加する」と判断できます。よって、**a**が正解です。\n    このような故障は、製品が使われることによる摩耗や劣化が原因で発生するため、**摩耗故障**と呼ばれます。\n\n-   **他の選択肢について**\n    -   **b, d**: 故障率が一定の場合、累積故障率のグラフは直線になります。\n    -   **c**: 故障率が減少する場合、グラフの傾きは時間とともに緩やかになる（上に凸のカーブになる）はずです。これは主に製造上の欠陥などが原因で起こる**初期故障**の特徴です。"
    },
    {
      "qNo": 21,
      "text": "システム障害発生時には, データベースの整合性を保ち, かつ, 最新のデータベース状態に復旧する必要がある。このために, DBMS がトランザクションのコミット処理を完了とするタイミングとして, 適切なものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "アプリケーションの更新命令完了時点"
        },
        {
          "id": "b",
          "text": "チェックポイント処理完了時点"
        },
        {
          "id": "c",
          "text": "ログバッファへのコミット情報書込み完了時点"
        },
        {
          "id": "d",
          "text": "ログファイルへのコミット情報書込み完了時点"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "この問題は、データベースがトランザクションを「確定（コミット）」させるタイミングと、障害復旧の関係を理解しているかを問うています。データの安全性を保証する上で、どの時点が最も重要かを考えましょう。\n\n### 正解の理由 (d)\nデータベース管理システム（DBMS）は、データの変更履歴を「**ログファイル**」に記録します。このログファイルは、システム障害が発生した際にデータを復旧するための命綱です。\n\nトランザクションをコミットするということは、その変更を永続的なものとして確定させることです。もし、変更内容がディスク上の**ログファイルに書き込まれる前**に障害が発生すると、その変更は失われてしまいます。\n\n逆に、**ログファイルへの書き込みが完了した時点**で障害が発生しても、ログファイルの情報を使えばトランザクションを再現し、データベースを最新の状態に復旧できます。このため、DBMSはログファイルへのコミット情報の書き込みが完了したタイミングで、トランザクションの完了とみなします。\n\n### 他の選択肢が誤りである理由\n*   **a**: アプリケーションが命令を出しただけでは、DBMSがまだ処理を開始していない可能性があり、データの永続性は保証されません。\n*   **b**: チェックポイントは、メモリ上のデータをまとめてディスクに書き出す処理ですが、個々のトランザクションのコミットとはタイミングが異なります。\n*   **c**: ログバッファは**メモリ上**の一時的な領域です。メモリは電源が切れると内容が消えてしまう（揮発性）ため、この時点ではまだ安全とは言えません。ディスク上のファイルに書き込まれて初めて永続性が確保されます。"
    },
    {
      "qNo": 22,
      "text": "磁気ディスク装置や磁気テープ装置などの外部記憶装置を, 通常の LAN とは別の高速な専用ネットワークで構成したものはどれか。",
      "options": [
        {
          "id": "a",
          "text": "DAFS"
        },
        {
          "id": "b",
          "text": "DAS"
        },
        {
          "id": "c",
          "text": "NAS"
        },
        {
          "id": "d",
          "text": "SAN"
        }
      ],
      "correctOption": "d",
      "point": 4,
      "explanation": "### 解説\n正解は **d: SAN** です。\n\nストレージ（外部記憶装置）の接続形態にはいくつかの種類があり、それぞれの特徴を理解することが重要です。\n\n*   **d: SAN (Storage Area Network)**\n    **正解**です。SANは、サーバーとストレージを接続するための**高速な専用ネットワーク**です。通常のLANとは独立しているため、LAN側の通信に影響を与えることなく、大容量のデータを高速に転送できるのが特徴です。サーバーからは、あたかも内蔵ディスクのようにストレージが見える「ブロック単位」でのアクセスを行います。\n\n*   **a: DAFS (Direct Access File System)**\n    ネットワークを介してファイルに高速アクセスするためのプロトコル（通信手順）の一種です。ネットワークの構成そのものを指す言葉ではないため、誤りです。\n\n*   **b: DAS (Direct Attached Storage)**\n    サーバーやPCにストレージを直接接続する方式です。PCの内蔵ハードディスクやUSB接続の外付けHDDがこの例です。「ネットワーク」を介さないため、誤りです。\n\n*   **c: NAS (Network Attached Storage)**\n    通常のLANに接続して使用するストレージです。ファイルサーバーのように手軽に導入できますが、**「LANとは別の専用ネットワーク」ではない**ため、誤りです。SANとNASの違いは頻出なので覚えておきましょう。"
    },
    {
      "qNo": 23,
      "text": "JIS Q 27014:2015 (情報セキュリティガバナンス) における, 情報セキュリティを統治するために経営陣が実行するガバナンスプロセスのうちの “モニタ” はどれか。",
      "options": [
        {
          "id": "a",
          "text": "情報セキュリティの目的及び戦略について, 指示を与えるガバナンスプロセス"
        },
        {
          "id": "b",
          "text": "戦略的目的の達成を評価することを可能にするガバナンスプロセス"
        },
        {
          "id": "c",
          "text": "独立した立場からの客観的な監査, レビュー又は認証を委託するガバナンスプロセス"
        },
        {
          "id": "d",
          "text": "利害関係者との間で, 特定のニーズに沿って情報セキュリティに関する情報を交換するガバナンスプロセス"
        }
      ],
      "correctOption": "b",
      "point": 4,
      "explanation": "正解は **b** です。\n\nこの問題は、情報セキュリティガバナンスの規格である **JIS Q 27014** における、経営陣の活動プロセスについて問うています。「ガバナンス」とは、企業などを適切に管理・運営する「統治」のことです。\n\nこの規格では、ガバナンスプロセスを以下の5つに分類しています。\n\n*   **指示 (Direct):** 方針や戦略を決め、実行を命じること。\n*   **モニタ (Monitor):** 計画通りに進んでいるか、目標を達成できそうかを**監視・評価**すること。\n*   **評価 (Evaluate):** 現状や課題を分析すること。\n*   **伝達 (Communicate):** 関係者と情報を共有すること。\n*   **保証 (Assure):** 第三者による監査などで客観的にチェックすること。\n\n選択肢 **b** の「戦略的目的の達成を評価する」という活動は、まさに計画の進捗や成果を監視・評価する「モニタ」プロセスそのものです。\n\n### 他選択肢の解説\n*   **a** の「指示を与える」は、「指示」プロセスの説明です。\n*   **c** の「独立した立場からの客観的な監査」は、「保証」プロセスの説明です。\n*   **d** の「情報を交換する」は、「伝達」プロセスの説明です。"
    },
    {
      "qNo": 24,
      "text": "安全な Web アプリケーションの作り方について, 攻撃と対策の適切な組合せはどれか。\n\n| | 攻撃 | 対策 |\n| :--- | :--- | :--- |\n| ア | SQL インジェクション | SQL 文の組立てに静的プレースホルダを使用する。 |\n| イ | クロスサイトスクリプティング | 任意の外部サイトのスタイルシートを取り込めるようにする。 |\n| ウ | クロスサイトリクエストフォージェリ | リクエストに GET メソッドを使用する。 |\n| エ | セッションハイジャック | 利用者ごとに固定のセッション ID を使用する。 |",
      "options": [
        {
          "id": "a",
          "text": "ア"
        },
        {
          "id": "b",
          "text": "イ"
        },
        {
          "id": "c",
          "text": "ウ"
        },
        {
          "id": "d",
          "text": "エ"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "Webアプリケーションの代表的な攻撃と、その正しい対策の組み合わせを理解することが重要です。\n\n*   **ア：正しい組み合わせです。**\n    *   **SQLインジェクション**は、Webアプリケーションの入力フォームなどに不正なSQL文（データベースへの命令文）を注入し、データベースを不正に操作する攻撃です。\n    *   対策である**静的プレースホルダ**は、まずSQL文の骨組み（`SELECT * FROM users WHERE id = ?` のようなテンプレート）をデータベースに送り、後から入力値を「データ」として当てはめる方式です。入力値がSQL文の一部として解釈されることがないため、SQLインジェクションを根本的に防ぐ有効な対策となります。\n\n*   **イ：誤りです。**\n    *   任意の外部サイトのスタイルシートを許可することは、むしろ新たなセキュリティリスクを生む可能性があります。**クロスサイトスクリプティング**の対策は、入力値に含まれるHTMLタグなどの特殊文字を無害化する**エスケープ処理**が基本です。\n\n*   **ウ：誤りです。**\n    *   重要な処理にGETメソッドを使用すると、URLにパラメータが残るため危険です。**クロスサイトリクエストフォージェリ（CSRF）**の対策としては、POSTメソッドを使用し、さらに正規の画面からのリクエストであることを証明するための**トークン**（推測困難な文字列）を埋め込む方法が有効です。\n\n*   **エ：誤りです。**\n    *   利用者ごとに固定のセッションIDを使用すると、IDが漏洩・推測された場合に永続的に悪用されてしまいます。**セッションハイジャック**の対策は、ログインのたびに**新しいセッションIDを発行**するなど、推測困難で定期的に変更される仕組みが求められます。"
    },
    {
      "qNo": 25,
      "text": "無線 LAN のセキュリティ方式として WPA2 を選択するとき, 利用される暗号化アルゴリズムはどれか。",
      "options": [
        {
          "id": "a",
          "text": "AES"
        },
        {
          "id": "b",
          "text": "ECC"
        },
        {
          "id": "c",
          "text": "RC4"
        },
        {
          "id": "d",
          "text": "RSA"
        }
      ],
      "correctOption": "a",
      "point": 4,
      "explanation": "無線LANのセキュリティ規格である**WPA2**では、暗号化アルゴリズムとして**a: AES**が標準で採用されています。\n\n*   **a: AES (Advanced Encryption Standard)**\n    *   **正解**です。AESは、現在最も広く利用されている信頼性の高い**共通鍵暗号方式**です。WPA2はこの強力なAESを使って通信データを暗号化することで、高い安全性を確保しています。\n\n*   **c: RC4**\n    *   WPA2が登場する前の規格である**WEP**や初代**WPA**で利用されていましたが、**脆弱性（セキュリティ上の弱点）**が発見されたため、現在では非推奨となっています。WPA2では、このRC4に代わって、より安全なAESが採用されました。\n\n*   **b: ECC (楕円曲線暗号)** と **d: RSA**\n    *   これらは**公開鍵暗号方式**に分類されます。主にデジタル署名や、通信を始める前の「鍵交換」という手順で使われる技術であり、WPA2のように通信データそのものを継続的に暗号化する目的では使われません。\n\n以上の理由から、WPA2で利用される暗号化アルゴリズムはAESとなります。"
    }
  ]
}